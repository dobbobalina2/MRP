"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  HttpConnection,
  JsonRpcProvider,
  esm_default,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  getBigIntRpcId,
  init_esm,
  init_esm3 as init_esm2,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isLocalhostUrl,
  isWsUrl,
  parseConnectionError,
  payloadId,
  safeJsonParse,
  safeJsonStringify
} from "./chunk-V2AXCFHR.js";
import {
  $,
  $t,
  At,
  B,
  Bt,
  D,
  Dn,
  Dt,
  Fn,
  Ft,
  Gt,
  Ht,
  Jn,
  Kn,
  Kt,
  Ln,
  Lt,
  Mn,
  Mt,
  N,
  Nt,
  Qt,
  Re,
  Rn,
  S,
  U,
  Vn,
  Vt,
  Wt,
  Xe,
  Xt,
  Zt,
  _,
  an,
  at,
  bt,
  cn,
  concat,
  ct,
  dt,
  ee,
  er,
  et,
  fromString,
  ft,
  h,
  it,
  j,
  jn,
  jt,
  kn,
  kt,
  lt,
  mt,
  nt,
  oe,
  p,
  pt,
  q,
  qt,
  require_binary,
  require_cjs,
  require_random,
  require_wipe,
  st,
  te,
  toString,
  un,
  ut,
  ve,
  w,
  xn,
  xt,
  yt,
  zn,
  zt
} from "./chunk-SRHCQTER.js";
import "./chunk-TAS4FOD4.js";
import "./chunk-YESVMCNG.js";
import {
  init_tslib_es6,
  require_events,
  tslib_es6_exports
} from "./chunk-XQJGMF32.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_dist
} from "./chunk-JQ2BQ45T.js";

// node_modules/.pnpm/@walletconnect+events@1.0.1/node_modules/@walletconnect/events/dist/esm/events.js
var import_dist6, IEvents;
var init_events = __esm({
  "node_modules/.pnpm/@walletconnect+events@1.0.1/node_modules/@walletconnect/events/dist/esm/events.js"() {
    import_dist6 = __toESM(require_dist());
    IEvents = class {
    };
  }
});

// node_modules/.pnpm/@walletconnect+events@1.0.1/node_modules/@walletconnect/events/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  IEvents: () => IEvents
});
var import_dist7;
var init_esm3 = __esm({
  "node_modules/.pnpm/@walletconnect+events@1.0.1/node_modules/@walletconnect/events/dist/esm/index.js"() {
    import_dist7 = __toESM(require_dist());
    init_events();
  }
});

// node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js
var require_heartbeat = __commonJS({
  "node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js"(exports) {
    "use strict";
    var import_dist22 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHeartBeat = void 0;
    var events_1 = (init_esm3(), __toCommonJS(esm_exports2));
    var IHeartBeat = class extends events_1.IEvents {
      constructor(opts) {
        super();
      }
    };
    exports.IHeartBeat = IHeartBeat;
  }
});

// node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js
var require_types = __commonJS({
  "node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js"(exports) {
    "use strict";
    var import_dist22 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat(), exports);
  }
});

// node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js
var require_heartbeat2 = __commonJS({
  "node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js"(exports) {
    "use strict";
    var import_dist22 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HEARTBEAT_EVENTS = exports.HEARTBEAT_INTERVAL = void 0;
    var time_1 = require_cjs();
    exports.HEARTBEAT_INTERVAL = time_1.FIVE_SECONDS;
    exports.HEARTBEAT_EVENTS = {
      pulse: "heartbeat_pulse"
    };
  }
});

// node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js
var require_constants = __commonJS({
  "node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js"(exports) {
    "use strict";
    var import_dist22 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat2(), exports);
  }
});

// node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js
var require_heartbeat3 = __commonJS({
  "node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js"(exports) {
    "use strict";
    var import_dist22 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeartBeat = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = require_events();
    var time_1 = require_cjs();
    var types_1 = require_types();
    var constants_1 = require_constants();
    var HeartBeat = class _HeartBeat extends types_1.IHeartBeat {
      constructor(opts) {
        super(opts);
        this.events = new events_1.EventEmitter();
        this.interval = constants_1.HEARTBEAT_INTERVAL;
        this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
      }
      static init(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const heartbeat = new _HeartBeat(opts);
          yield heartbeat.init();
          return heartbeat;
        });
      }
      init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.initialize();
        });
      }
      stop() {
        clearInterval(this.intervalRef);
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this.intervalRef = setInterval(() => this.pulse(), time_1.toMiliseconds(this.interval));
        });
      }
      pulse() {
        this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
      }
    };
    exports.HeartBeat = HeartBeat;
  }
});

// node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/.pnpm/@walletconnect+heartbeat@1.2.1/node_modules/@walletconnect/heartbeat/dist/cjs/index.js"(exports) {
    "use strict";
    var import_dist22 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat3(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_constants(), exports);
  }
});

// node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    var import_dist22 = __toESM(require_dist());
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f3, args, opts) {
      var ss2 = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f3 === "object" && f3 !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f3;
        var objects = new Array(len);
        objects[0] = ss2(f3);
        for (var index = 1; index < len; index++) {
          objects[index] = ss2(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f3 !== "string") {
        return f3;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f3;
      var str = "";
      var a2 = 1 - offset;
      var lastPos = -1;
      var flen = f3 && f3.length || 0;
      for (var i3 = 0; i3 < flen; ) {
        if (f3.charCodeAt(i3) === 37 && i3 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f3.charCodeAt(i3 + 1)) {
            case 100:
            case 102:
              if (a2 >= argLen)
                break;
              if (args[a2] == null)
                break;
              if (lastPos < i3)
                str += f3.slice(lastPos, i3);
              str += Number(args[a2]);
              lastPos = i3 + 2;
              i3++;
              break;
            case 105:
              if (a2 >= argLen)
                break;
              if (args[a2] == null)
                break;
              if (lastPos < i3)
                str += f3.slice(lastPos, i3);
              str += Math.floor(Number(args[a2]));
              lastPos = i3 + 2;
              i3++;
              break;
            case 79:
            case 111:
            case 106:
              if (a2 >= argLen)
                break;
              if (args[a2] === void 0)
                break;
              if (lastPos < i3)
                str += f3.slice(lastPos, i3);
              var type = typeof args[a2];
              if (type === "string") {
                str += "'" + args[a2] + "'";
                lastPos = i3 + 2;
                i3++;
                break;
              }
              if (type === "function") {
                str += args[a2].name || "<anonymous>";
                lastPos = i3 + 2;
                i3++;
                break;
              }
              str += ss2(args[a2]);
              lastPos = i3 + 2;
              i3++;
              break;
            case 115:
              if (a2 >= argLen)
                break;
              if (lastPos < i3)
                str += f3.slice(lastPos, i3);
              str += String(args[a2]);
              lastPos = i3 + 2;
              i3++;
              break;
            case 37:
              if (lastPos < i3)
                str += f3.slice(lastPos, i3);
              str += "%";
              lastPos = i3 + 2;
              i3++;
              a2--;
              break;
          }
          ++a2;
        }
        ++i3;
      }
      if (lastPos === -1)
        return f3;
      else if (lastPos < flen) {
        str += f3.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/.pnpm/pino@7.11.0/node_modules/pino/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/pino@7.11.0/node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var import_dist22 = __toESM(require_dist());
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k3) {
          return k3 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log)
        logger.log = noop;
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger.levels = pino.levels;
      logger.level = level;
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
      logger.serializers = serializers;
      logger._serialize = serialize;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = child;
      if (transmit2)
        logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(setOpts, logger, "error", "log");
        set2(setOpts, logger, "fatal", "error");
        set2(setOpts, logger, "warn", "error");
        set2(setOpts, logger, "info", "log");
        set2(setOpts, logger, "debug", "log");
        set2(setOpts, logger, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set2(opts, logger, level, fallback) {
      const proto = Object.getPrototypeOf(logger);
      logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop;
      wrap(opts, logger, level);
    }
    function wrap(opts, logger, level) {
      if (!opts.transmit && logger[level] === noop)
        return;
      logger[level] = function(write) {
        return function LOG() {
          const ts2 = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i3 = 0; i3 < args.length; i3++)
            args[i3] = arguments[i3];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject)
            write.call(proto, asObject(this, level, args, ts2));
          else
            write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts: ts2,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger.level],
              send: opts.transmit.send,
              val: logger.levelVal
            }, args);
          }
        };
      }(logger[level]);
    }
    function asObject(logger, level, args, ts2) {
      if (logger._serialize)
        applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o = {};
      if (ts2) {
        o.time = ts2;
      }
      o.level = pino.levels.values[level];
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string")
        msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0)
        o.msg = msg;
      return o;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i3 in args) {
        if (stdErrSerialize && args[i3] instanceof Error) {
          args[i3] = pino.stdSerializers.err(args[i3]);
        } else if (typeof args[i3] === "object" && !Array.isArray(args[i3])) {
          for (const k3 in args[i3]) {
            if (serialize && serialize.indexOf(k3) > -1 && k3 in serializers) {
              args[i3][k3] = serializers[k3](args[i3][k3]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i3 = 1; i3 < args.length; i3++) {
          args[i3] = arguments[i3 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger, opts, args) {
      const send = opts.send;
      const ts2 = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      applySerializers(
        args,
        logger._serialize || Object.keys(logger.serializers),
        logger.serializers,
        logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
      );
      logger._logEvent.ts = ts2;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a2) {
      return a2;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o) {
        return typeof o !== "undefined" && o;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/.pnpm/@stablelib+sha512@1.0.1/node_modules/@stablelib/sha512/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/.pnpm/@stablelib+sha512@1.0.1/node_modules/@stablelib/sha512/lib/sha512.js"(exports) {
    "use strict";
    var import_dist22 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    var SHA512 = (
      /** @class */
      function() {
        function SHA5122() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._stateHi = new Int32Array(8);
          this._stateLo = new Int32Array(8);
          this._tempHi = new Int32Array(16);
          this._tempLo = new Int32Array(16);
          this._buffer = new Uint8Array(256);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA5122.prototype._initState = function() {
          this._stateHi[0] = 1779033703;
          this._stateHi[1] = 3144134277;
          this._stateHi[2] = 1013904242;
          this._stateHi[3] = 2773480762;
          this._stateHi[4] = 1359893119;
          this._stateHi[5] = 2600822924;
          this._stateHi[6] = 528734635;
          this._stateHi[7] = 1541459225;
          this._stateLo[0] = 4089235720;
          this._stateLo[1] = 2227873595;
          this._stateLo[2] = 4271175723;
          this._stateLo[3] = 1595750129;
          this._stateLo[4] = 2917565137;
          this._stateLo[5] = 725511199;
          this._stateLo[6] = 4215389547;
          this._stateLo[7] = 327033209;
        };
        SHA5122.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._tempHi);
          wipe_1.wipe(this._tempLo);
          this.reset();
        };
        SHA5122.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA5122.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 128 < 112 ? 128 : 256;
            this._buffer[left] = 128;
            for (var i3 = left + 1; i3 < padLength - 8; i3++) {
              this._buffer[i3] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i3 = 0; i3 < this.digestLength / 8; i3++) {
            binary_1.writeUint32BE(this._stateHi[i3], out, i3 * 8);
            binary_1.writeUint32BE(this._stateLo[i3], out, i3 * 8 + 4);
          }
          return this;
        };
        SHA5122.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA5122.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA5122.prototype.restoreState = function(savedState) {
          this._stateHi.set(savedState.stateHi);
          this._stateLo.set(savedState.stateLo);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.stateHi);
          wipe_1.wipe(savedState.stateLo);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA5122;
      }()
    );
    exports.SHA512 = SHA512;
    var K3 = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh, wl, hh, hl, m2, pos, len) {
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h5, l3;
      var th, tl;
      var a2, b5, c4, d3;
      while (len >= 128) {
        for (var i3 = 0; i3 < 16; i3++) {
          var j5 = 8 * i3 + pos;
          wh[i3] = binary_1.readUint32BE(m2, j5);
          wl[i3] = binary_1.readUint32BE(m2, j5 + 4);
        }
        for (var i3 = 0; i3 < 80; i3++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h5 = ah7;
          l3 = al7;
          a2 = l3 & 65535;
          b5 = l3 >>> 16;
          c4 = h5 & 65535;
          d3 = h5 >>> 16;
          h5 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l3 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a2 += l3 & 65535;
          b5 += l3 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          h5 = ah4 & ah5 ^ ~ah4 & ah6;
          l3 = al4 & al5 ^ ~al4 & al6;
          a2 += l3 & 65535;
          b5 += l3 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          h5 = K3[i3 * 2];
          l3 = K3[i3 * 2 + 1];
          a2 += l3 & 65535;
          b5 += l3 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          h5 = wh[i3 % 16];
          l3 = wl[i3 % 16];
          a2 += l3 & 65535;
          b5 += l3 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          b5 += a2 >>> 16;
          c4 += b5 >>> 16;
          d3 += c4 >>> 16;
          th = c4 & 65535 | d3 << 16;
          tl = a2 & 65535 | b5 << 16;
          h5 = th;
          l3 = tl;
          a2 = l3 & 65535;
          b5 = l3 >>> 16;
          c4 = h5 & 65535;
          d3 = h5 >>> 16;
          h5 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l3 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a2 += l3 & 65535;
          b5 += l3 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          h5 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l3 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a2 += l3 & 65535;
          b5 += l3 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          b5 += a2 >>> 16;
          c4 += b5 >>> 16;
          d3 += c4 >>> 16;
          bh7 = c4 & 65535 | d3 << 16;
          bl7 = a2 & 65535 | b5 << 16;
          h5 = bh3;
          l3 = bl3;
          a2 = l3 & 65535;
          b5 = l3 >>> 16;
          c4 = h5 & 65535;
          d3 = h5 >>> 16;
          h5 = th;
          l3 = tl;
          a2 += l3 & 65535;
          b5 += l3 >>> 16;
          c4 += h5 & 65535;
          d3 += h5 >>> 16;
          b5 += a2 >>> 16;
          c4 += b5 >>> 16;
          d3 += c4 >>> 16;
          bh3 = c4 & 65535 | d3 << 16;
          bl3 = a2 & 65535 | b5 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i3 % 16 === 15) {
            for (var j5 = 0; j5 < 16; j5++) {
              h5 = wh[j5];
              l3 = wl[j5];
              a2 = l3 & 65535;
              b5 = l3 >>> 16;
              c4 = h5 & 65535;
              d3 = h5 >>> 16;
              h5 = wh[(j5 + 9) % 16];
              l3 = wl[(j5 + 9) % 16];
              a2 += l3 & 65535;
              b5 += l3 >>> 16;
              c4 += h5 & 65535;
              d3 += h5 >>> 16;
              th = wh[(j5 + 1) % 16];
              tl = wl[(j5 + 1) % 16];
              h5 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l3 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a2 += l3 & 65535;
              b5 += l3 >>> 16;
              c4 += h5 & 65535;
              d3 += h5 >>> 16;
              th = wh[(j5 + 14) % 16];
              tl = wl[(j5 + 14) % 16];
              h5 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l3 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a2 += l3 & 65535;
              b5 += l3 >>> 16;
              c4 += h5 & 65535;
              d3 += h5 >>> 16;
              b5 += a2 >>> 16;
              c4 += b5 >>> 16;
              d3 += c4 >>> 16;
              wh[j5] = c4 & 65535 | d3 << 16;
              wl[j5] = a2 & 65535 | b5 << 16;
            }
          }
        }
        h5 = ah0;
        l3 = al0;
        a2 = l3 & 65535;
        b5 = l3 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[0];
        l3 = hl[0];
        a2 += l3 & 65535;
        b5 += l3 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b5 += a2 >>> 16;
        c4 += b5 >>> 16;
        d3 += c4 >>> 16;
        hh[0] = ah0 = c4 & 65535 | d3 << 16;
        hl[0] = al0 = a2 & 65535 | b5 << 16;
        h5 = ah1;
        l3 = al1;
        a2 = l3 & 65535;
        b5 = l3 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[1];
        l3 = hl[1];
        a2 += l3 & 65535;
        b5 += l3 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b5 += a2 >>> 16;
        c4 += b5 >>> 16;
        d3 += c4 >>> 16;
        hh[1] = ah1 = c4 & 65535 | d3 << 16;
        hl[1] = al1 = a2 & 65535 | b5 << 16;
        h5 = ah2;
        l3 = al2;
        a2 = l3 & 65535;
        b5 = l3 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[2];
        l3 = hl[2];
        a2 += l3 & 65535;
        b5 += l3 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b5 += a2 >>> 16;
        c4 += b5 >>> 16;
        d3 += c4 >>> 16;
        hh[2] = ah2 = c4 & 65535 | d3 << 16;
        hl[2] = al2 = a2 & 65535 | b5 << 16;
        h5 = ah3;
        l3 = al3;
        a2 = l3 & 65535;
        b5 = l3 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[3];
        l3 = hl[3];
        a2 += l3 & 65535;
        b5 += l3 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b5 += a2 >>> 16;
        c4 += b5 >>> 16;
        d3 += c4 >>> 16;
        hh[3] = ah3 = c4 & 65535 | d3 << 16;
        hl[3] = al3 = a2 & 65535 | b5 << 16;
        h5 = ah4;
        l3 = al4;
        a2 = l3 & 65535;
        b5 = l3 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[4];
        l3 = hl[4];
        a2 += l3 & 65535;
        b5 += l3 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b5 += a2 >>> 16;
        c4 += b5 >>> 16;
        d3 += c4 >>> 16;
        hh[4] = ah4 = c4 & 65535 | d3 << 16;
        hl[4] = al4 = a2 & 65535 | b5 << 16;
        h5 = ah5;
        l3 = al5;
        a2 = l3 & 65535;
        b5 = l3 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[5];
        l3 = hl[5];
        a2 += l3 & 65535;
        b5 += l3 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b5 += a2 >>> 16;
        c4 += b5 >>> 16;
        d3 += c4 >>> 16;
        hh[5] = ah5 = c4 & 65535 | d3 << 16;
        hl[5] = al5 = a2 & 65535 | b5 << 16;
        h5 = ah6;
        l3 = al6;
        a2 = l3 & 65535;
        b5 = l3 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[6];
        l3 = hl[6];
        a2 += l3 & 65535;
        b5 += l3 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b5 += a2 >>> 16;
        c4 += b5 >>> 16;
        d3 += c4 >>> 16;
        hh[6] = ah6 = c4 & 65535 | d3 << 16;
        hl[6] = al6 = a2 & 65535 | b5 << 16;
        h5 = ah7;
        l3 = al7;
        a2 = l3 & 65535;
        b5 = l3 >>> 16;
        c4 = h5 & 65535;
        d3 = h5 >>> 16;
        h5 = hh[7];
        l3 = hl[7];
        a2 += l3 & 65535;
        b5 += l3 >>> 16;
        c4 += h5 & 65535;
        d3 += h5 >>> 16;
        b5 += a2 >>> 16;
        c4 += b5 >>> 16;
        d3 += c4 >>> 16;
        hh[7] = ah7 = c4 & 65535 | d3 << 16;
        hl[7] = al7 = a2 & 65535 | b5 << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    function hash(data) {
      var h5 = new SHA512();
      h5.update(data);
      var digest = h5.digest();
      h5.clean();
      return digest;
    }
    exports.hash = hash;
  }
});

// node_modules/.pnpm/@stablelib+ed25519@1.0.3/node_modules/@stablelib/ed25519/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/.pnpm/@stablelib+ed25519@1.0.3/node_modules/@stablelib/ed25519/lib/ed25519.js"(exports) {
    "use strict";
    var import_dist22 = __toESM(require_dist());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
    var random_1 = require_random();
    var sha512_1 = require_sha512();
    var wipe_1 = require_wipe();
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32;
    function gf(init) {
      const r = new Float64Array(16);
      if (init) {
        for (let i3 = 0; i3 < init.length; i3++) {
          r[i3] = init[i3];
        }
      }
      return r;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf();
    var gf1 = gf([1]);
    var D5 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X3 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var I2 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r, a2) {
      for (let i3 = 0; i3 < 16; i3++) {
        r[i3] = a2[i3] | 0;
      }
    }
    function car25519(o) {
      let c4 = 1;
      for (let i3 = 0; i3 < 16; i3++) {
        let v4 = o[i3] + c4 + 65535;
        c4 = Math.floor(v4 / 65536);
        o[i3] = v4 - c4 * 65536;
      }
      o[0] += c4 - 1 + 37 * (c4 - 1);
    }
    function sel25519(p5, q3, b5) {
      const c4 = ~(b5 - 1);
      for (let i3 = 0; i3 < 16; i3++) {
        const t = c4 & (p5[i3] ^ q3[i3]);
        p5[i3] ^= t;
        q3[i3] ^= t;
      }
    }
    function pack25519(o, n3) {
      const m2 = gf();
      const t = gf();
      for (let i3 = 0; i3 < 16; i3++) {
        t[i3] = n3[i3];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j5 = 0; j5 < 2; j5++) {
        m2[0] = t[0] - 65517;
        for (let i3 = 1; i3 < 15; i3++) {
          m2[i3] = t[i3] - 65535 - (m2[i3 - 1] >> 16 & 1);
          m2[i3 - 1] &= 65535;
        }
        m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
        const b5 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t, m2, 1 - b5);
      }
      for (let i3 = 0; i3 < 16; i3++) {
        o[2 * i3] = t[i3] & 255;
        o[2 * i3 + 1] = t[i3] >> 8;
      }
    }
    function verify32(x3, y6) {
      let d3 = 0;
      for (let i3 = 0; i3 < 32; i3++) {
        d3 |= x3[i3] ^ y6[i3];
      }
      return (1 & d3 - 1 >>> 8) - 1;
    }
    function neq25519(a2, b5) {
      const c4 = new Uint8Array(32);
      const d3 = new Uint8Array(32);
      pack25519(c4, a2);
      pack25519(d3, b5);
      return verify32(c4, d3);
    }
    function par25519(a2) {
      const d3 = new Uint8Array(32);
      pack25519(d3, a2);
      return d3[0] & 1;
    }
    function unpack25519(o, n3) {
      for (let i3 = 0; i3 < 16; i3++) {
        o[i3] = n3[2 * i3] + (n3[2 * i3 + 1] << 8);
      }
      o[15] &= 32767;
    }
    function add(o, a2, b5) {
      for (let i3 = 0; i3 < 16; i3++) {
        o[i3] = a2[i3] + b5[i3];
      }
    }
    function sub(o, a2, b5) {
      for (let i3 = 0; i3 < 16; i3++) {
        o[i3] = a2[i3] - b5[i3];
      }
    }
    function mul(o, a2, b5) {
      let v4, c4, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b5[0], b1 = b5[1], b22 = b5[2], b32 = b5[3], b42 = b5[4], b52 = b5[5], b6 = b5[6], b7 = b5[7], b8 = b5[8], b9 = b5[9], b10 = b5[10], b11 = b5[11], b12 = b5[12], b13 = b5[13], b14 = b5[14], b15 = b5[15];
      v4 = a2[0];
      t0 += v4 * b0;
      t1 += v4 * b1;
      t2 += v4 * b22;
      t3 += v4 * b32;
      t4 += v4 * b42;
      t5 += v4 * b52;
      t6 += v4 * b6;
      t7 += v4 * b7;
      t8 += v4 * b8;
      t9 += v4 * b9;
      t10 += v4 * b10;
      t11 += v4 * b11;
      t12 += v4 * b12;
      t13 += v4 * b13;
      t14 += v4 * b14;
      t15 += v4 * b15;
      v4 = a2[1];
      t1 += v4 * b0;
      t2 += v4 * b1;
      t3 += v4 * b22;
      t4 += v4 * b32;
      t5 += v4 * b42;
      t6 += v4 * b52;
      t7 += v4 * b6;
      t8 += v4 * b7;
      t9 += v4 * b8;
      t10 += v4 * b9;
      t11 += v4 * b10;
      t12 += v4 * b11;
      t13 += v4 * b12;
      t14 += v4 * b13;
      t15 += v4 * b14;
      t16 += v4 * b15;
      v4 = a2[2];
      t2 += v4 * b0;
      t3 += v4 * b1;
      t4 += v4 * b22;
      t5 += v4 * b32;
      t6 += v4 * b42;
      t7 += v4 * b52;
      t8 += v4 * b6;
      t9 += v4 * b7;
      t10 += v4 * b8;
      t11 += v4 * b9;
      t12 += v4 * b10;
      t13 += v4 * b11;
      t14 += v4 * b12;
      t15 += v4 * b13;
      t16 += v4 * b14;
      t17 += v4 * b15;
      v4 = a2[3];
      t3 += v4 * b0;
      t4 += v4 * b1;
      t5 += v4 * b22;
      t6 += v4 * b32;
      t7 += v4 * b42;
      t8 += v4 * b52;
      t9 += v4 * b6;
      t10 += v4 * b7;
      t11 += v4 * b8;
      t12 += v4 * b9;
      t13 += v4 * b10;
      t14 += v4 * b11;
      t15 += v4 * b12;
      t16 += v4 * b13;
      t17 += v4 * b14;
      t18 += v4 * b15;
      v4 = a2[4];
      t4 += v4 * b0;
      t5 += v4 * b1;
      t6 += v4 * b22;
      t7 += v4 * b32;
      t8 += v4 * b42;
      t9 += v4 * b52;
      t10 += v4 * b6;
      t11 += v4 * b7;
      t12 += v4 * b8;
      t13 += v4 * b9;
      t14 += v4 * b10;
      t15 += v4 * b11;
      t16 += v4 * b12;
      t17 += v4 * b13;
      t18 += v4 * b14;
      t19 += v4 * b15;
      v4 = a2[5];
      t5 += v4 * b0;
      t6 += v4 * b1;
      t7 += v4 * b22;
      t8 += v4 * b32;
      t9 += v4 * b42;
      t10 += v4 * b52;
      t11 += v4 * b6;
      t12 += v4 * b7;
      t13 += v4 * b8;
      t14 += v4 * b9;
      t15 += v4 * b10;
      t16 += v4 * b11;
      t17 += v4 * b12;
      t18 += v4 * b13;
      t19 += v4 * b14;
      t20 += v4 * b15;
      v4 = a2[6];
      t6 += v4 * b0;
      t7 += v4 * b1;
      t8 += v4 * b22;
      t9 += v4 * b32;
      t10 += v4 * b42;
      t11 += v4 * b52;
      t12 += v4 * b6;
      t13 += v4 * b7;
      t14 += v4 * b8;
      t15 += v4 * b9;
      t16 += v4 * b10;
      t17 += v4 * b11;
      t18 += v4 * b12;
      t19 += v4 * b13;
      t20 += v4 * b14;
      t21 += v4 * b15;
      v4 = a2[7];
      t7 += v4 * b0;
      t8 += v4 * b1;
      t9 += v4 * b22;
      t10 += v4 * b32;
      t11 += v4 * b42;
      t12 += v4 * b52;
      t13 += v4 * b6;
      t14 += v4 * b7;
      t15 += v4 * b8;
      t16 += v4 * b9;
      t17 += v4 * b10;
      t18 += v4 * b11;
      t19 += v4 * b12;
      t20 += v4 * b13;
      t21 += v4 * b14;
      t22 += v4 * b15;
      v4 = a2[8];
      t8 += v4 * b0;
      t9 += v4 * b1;
      t10 += v4 * b22;
      t11 += v4 * b32;
      t12 += v4 * b42;
      t13 += v4 * b52;
      t14 += v4 * b6;
      t15 += v4 * b7;
      t16 += v4 * b8;
      t17 += v4 * b9;
      t18 += v4 * b10;
      t19 += v4 * b11;
      t20 += v4 * b12;
      t21 += v4 * b13;
      t22 += v4 * b14;
      t23 += v4 * b15;
      v4 = a2[9];
      t9 += v4 * b0;
      t10 += v4 * b1;
      t11 += v4 * b22;
      t12 += v4 * b32;
      t13 += v4 * b42;
      t14 += v4 * b52;
      t15 += v4 * b6;
      t16 += v4 * b7;
      t17 += v4 * b8;
      t18 += v4 * b9;
      t19 += v4 * b10;
      t20 += v4 * b11;
      t21 += v4 * b12;
      t22 += v4 * b13;
      t23 += v4 * b14;
      t24 += v4 * b15;
      v4 = a2[10];
      t10 += v4 * b0;
      t11 += v4 * b1;
      t12 += v4 * b22;
      t13 += v4 * b32;
      t14 += v4 * b42;
      t15 += v4 * b52;
      t16 += v4 * b6;
      t17 += v4 * b7;
      t18 += v4 * b8;
      t19 += v4 * b9;
      t20 += v4 * b10;
      t21 += v4 * b11;
      t22 += v4 * b12;
      t23 += v4 * b13;
      t24 += v4 * b14;
      t25 += v4 * b15;
      v4 = a2[11];
      t11 += v4 * b0;
      t12 += v4 * b1;
      t13 += v4 * b22;
      t14 += v4 * b32;
      t15 += v4 * b42;
      t16 += v4 * b52;
      t17 += v4 * b6;
      t18 += v4 * b7;
      t19 += v4 * b8;
      t20 += v4 * b9;
      t21 += v4 * b10;
      t22 += v4 * b11;
      t23 += v4 * b12;
      t24 += v4 * b13;
      t25 += v4 * b14;
      t26 += v4 * b15;
      v4 = a2[12];
      t12 += v4 * b0;
      t13 += v4 * b1;
      t14 += v4 * b22;
      t15 += v4 * b32;
      t16 += v4 * b42;
      t17 += v4 * b52;
      t18 += v4 * b6;
      t19 += v4 * b7;
      t20 += v4 * b8;
      t21 += v4 * b9;
      t22 += v4 * b10;
      t23 += v4 * b11;
      t24 += v4 * b12;
      t25 += v4 * b13;
      t26 += v4 * b14;
      t27 += v4 * b15;
      v4 = a2[13];
      t13 += v4 * b0;
      t14 += v4 * b1;
      t15 += v4 * b22;
      t16 += v4 * b32;
      t17 += v4 * b42;
      t18 += v4 * b52;
      t19 += v4 * b6;
      t20 += v4 * b7;
      t21 += v4 * b8;
      t22 += v4 * b9;
      t23 += v4 * b10;
      t24 += v4 * b11;
      t25 += v4 * b12;
      t26 += v4 * b13;
      t27 += v4 * b14;
      t28 += v4 * b15;
      v4 = a2[14];
      t14 += v4 * b0;
      t15 += v4 * b1;
      t16 += v4 * b22;
      t17 += v4 * b32;
      t18 += v4 * b42;
      t19 += v4 * b52;
      t20 += v4 * b6;
      t21 += v4 * b7;
      t22 += v4 * b8;
      t23 += v4 * b9;
      t24 += v4 * b10;
      t25 += v4 * b11;
      t26 += v4 * b12;
      t27 += v4 * b13;
      t28 += v4 * b14;
      t29 += v4 * b15;
      v4 = a2[15];
      t15 += v4 * b0;
      t16 += v4 * b1;
      t17 += v4 * b22;
      t18 += v4 * b32;
      t19 += v4 * b42;
      t20 += v4 * b52;
      t21 += v4 * b6;
      t22 += v4 * b7;
      t23 += v4 * b8;
      t24 += v4 * b9;
      t25 += v4 * b10;
      t26 += v4 * b11;
      t27 += v4 * b12;
      t28 += v4 * b13;
      t29 += v4 * b14;
      t30 += v4 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c4 = 1;
      v4 = t0 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t0 = v4 - c4 * 65536;
      v4 = t1 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t1 = v4 - c4 * 65536;
      v4 = t2 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t2 = v4 - c4 * 65536;
      v4 = t3 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t3 = v4 - c4 * 65536;
      v4 = t4 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t4 = v4 - c4 * 65536;
      v4 = t5 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t5 = v4 - c4 * 65536;
      v4 = t6 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t6 = v4 - c4 * 65536;
      v4 = t7 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t7 = v4 - c4 * 65536;
      v4 = t8 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t8 = v4 - c4 * 65536;
      v4 = t9 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t9 = v4 - c4 * 65536;
      v4 = t10 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t10 = v4 - c4 * 65536;
      v4 = t11 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t11 = v4 - c4 * 65536;
      v4 = t12 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t12 = v4 - c4 * 65536;
      v4 = t13 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t13 = v4 - c4 * 65536;
      v4 = t14 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t14 = v4 - c4 * 65536;
      v4 = t15 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t15 = v4 - c4 * 65536;
      t0 += c4 - 1 + 37 * (c4 - 1);
      c4 = 1;
      v4 = t0 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t0 = v4 - c4 * 65536;
      v4 = t1 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t1 = v4 - c4 * 65536;
      v4 = t2 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t2 = v4 - c4 * 65536;
      v4 = t3 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t3 = v4 - c4 * 65536;
      v4 = t4 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t4 = v4 - c4 * 65536;
      v4 = t5 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t5 = v4 - c4 * 65536;
      v4 = t6 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t6 = v4 - c4 * 65536;
      v4 = t7 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t7 = v4 - c4 * 65536;
      v4 = t8 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t8 = v4 - c4 * 65536;
      v4 = t9 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t9 = v4 - c4 * 65536;
      v4 = t10 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t10 = v4 - c4 * 65536;
      v4 = t11 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t11 = v4 - c4 * 65536;
      v4 = t12 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t12 = v4 - c4 * 65536;
      v4 = t13 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t13 = v4 - c4 * 65536;
      v4 = t14 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t14 = v4 - c4 * 65536;
      v4 = t15 + c4 + 65535;
      c4 = Math.floor(v4 / 65536);
      t15 = v4 - c4 * 65536;
      t0 += c4 - 1 + 37 * (c4 - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function square(o, a2) {
      mul(o, a2, a2);
    }
    function inv25519(o, i3) {
      const c4 = gf();
      let a2;
      for (a2 = 0; a2 < 16; a2++) {
        c4[a2] = i3[a2];
      }
      for (a2 = 253; a2 >= 0; a2--) {
        square(c4, c4);
        if (a2 !== 2 && a2 !== 4) {
          mul(c4, c4, i3);
        }
      }
      for (a2 = 0; a2 < 16; a2++) {
        o[a2] = c4[a2];
      }
    }
    function pow2523(o, i3) {
      const c4 = gf();
      let a2;
      for (a2 = 0; a2 < 16; a2++) {
        c4[a2] = i3[a2];
      }
      for (a2 = 250; a2 >= 0; a2--) {
        square(c4, c4);
        if (a2 !== 1) {
          mul(c4, c4, i3);
        }
      }
      for (a2 = 0; a2 < 16; a2++) {
        o[a2] = c4[a2];
      }
    }
    function edadd(p5, q3) {
      const a2 = gf(), b5 = gf(), c4 = gf(), d3 = gf(), e = gf(), f3 = gf(), g6 = gf(), h5 = gf(), t = gf();
      sub(a2, p5[1], p5[0]);
      sub(t, q3[1], q3[0]);
      mul(a2, a2, t);
      add(b5, p5[0], p5[1]);
      add(t, q3[0], q3[1]);
      mul(b5, b5, t);
      mul(c4, p5[3], q3[3]);
      mul(c4, c4, D22);
      mul(d3, p5[2], q3[2]);
      add(d3, d3, d3);
      sub(e, b5, a2);
      sub(f3, d3, c4);
      add(g6, d3, c4);
      add(h5, b5, a2);
      mul(p5[0], e, f3);
      mul(p5[1], h5, g6);
      mul(p5[2], g6, f3);
      mul(p5[3], e, h5);
    }
    function cswap(p5, q3, b5) {
      for (let i3 = 0; i3 < 4; i3++) {
        sel25519(p5[i3], q3[i3], b5);
      }
    }
    function pack(r, p5) {
      const tx = gf(), ty = gf(), zi2 = gf();
      inv25519(zi2, p5[2]);
      mul(tx, p5[0], zi2);
      mul(ty, p5[1], zi2);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p5, q3, s2) {
      set25519(p5[0], gf0);
      set25519(p5[1], gf1);
      set25519(p5[2], gf1);
      set25519(p5[3], gf0);
      for (let i3 = 255; i3 >= 0; --i3) {
        const b5 = s2[i3 / 8 | 0] >> (i3 & 7) & 1;
        cswap(p5, q3, b5);
        edadd(q3, p5);
        edadd(p5, p5);
        cswap(p5, q3, b5);
      }
    }
    function scalarbase(p5, s2) {
      const q3 = [gf(), gf(), gf(), gf()];
      set25519(q3[0], X3);
      set25519(q3[1], Y);
      set25519(q3[2], gf1);
      mul(q3[3], X3, Y);
      scalarmult(p5, q3, s2);
    }
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
      }
      const d3 = (0, sha512_1.hash)(seed);
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const publicKey = new Uint8Array(32);
      const p5 = [gf(), gf(), gf(), gf()];
      scalarbase(p5, d3);
      pack(publicKey, p5);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair2(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair2;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L3 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r, x3) {
      let carry;
      let i3;
      let j5;
      let k3;
      for (i3 = 63; i3 >= 32; --i3) {
        carry = 0;
        for (j5 = i3 - 32, k3 = i3 - 12; j5 < k3; ++j5) {
          x3[j5] += carry - 16 * x3[i3] * L3[j5 - (i3 - 32)];
          carry = Math.floor((x3[j5] + 128) / 256);
          x3[j5] -= carry * 256;
        }
        x3[j5] += carry;
        x3[i3] = 0;
      }
      carry = 0;
      for (j5 = 0; j5 < 32; j5++) {
        x3[j5] += carry - (x3[31] >> 4) * L3[j5];
        carry = x3[j5] >> 8;
        x3[j5] &= 255;
      }
      for (j5 = 0; j5 < 32; j5++) {
        x3[j5] -= carry * L3[j5];
      }
      for (i3 = 0; i3 < 32; i3++) {
        x3[i3 + 1] += x3[i3] >> 8;
        r[i3] = x3[i3] & 255;
      }
    }
    function reduce(r) {
      const x3 = new Float64Array(64);
      for (let i3 = 0; i3 < 64; i3++) {
        x3[i3] = r[i3];
      }
      for (let i3 = 0; i3 < 64; i3++) {
        r[i3] = 0;
      }
      modL(r, x3);
    }
    function sign2(secretKey, message) {
      const x3 = new Float64Array(64);
      const p5 = [gf(), gf(), gf(), gf()];
      const d3 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const signature = new Uint8Array(64);
      signature.set(d3.subarray(32), 32);
      const hs3 = new sha512_1.SHA512();
      hs3.update(signature.subarray(32));
      hs3.update(message);
      const r = hs3.digest();
      hs3.clean();
      reduce(r);
      scalarbase(p5, r);
      pack(signature, p5);
      hs3.reset();
      hs3.update(signature.subarray(0, 32));
      hs3.update(secretKey.subarray(32));
      hs3.update(message);
      const h5 = hs3.digest();
      reduce(h5);
      for (let i3 = 0; i3 < 32; i3++) {
        x3[i3] = r[i3];
      }
      for (let i3 = 0; i3 < 32; i3++) {
        for (let j5 = 0; j5 < 32; j5++) {
          x3[i3 + j5] += h5[i3] * d3[j5];
        }
      }
      modL(signature.subarray(32), x3);
      return signature;
    }
    exports.sign = sign2;
    function unpackneg(r, p5) {
      const t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p5);
      square(num, r[1]);
      mul(den, num, D5);
      sub(num, num, r[2]);
      add(den, r[2], den);
      square(den2, den);
      square(den4, den2);
      mul(den6, den4, den2);
      mul(t, den6, num);
      mul(t, t, den);
      pow2523(t, t);
      mul(t, t, num);
      mul(t, t, den);
      mul(t, t, den);
      mul(r[0], t, den);
      square(chk, r[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        mul(r[0], r[0], I2);
      }
      square(chk, r[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r[0]) === p5[31] >> 7) {
        sub(r[0], gf0, r[0]);
      }
      mul(r[3], r[0], r[1]);
      return 0;
    }
    function verify2(publicKey, message, signature) {
      const t = new Uint8Array(32);
      const p5 = [gf(), gf(), gf(), gf()];
      const q3 = [gf(), gf(), gf(), gf()];
      if (signature.length !== exports.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
      }
      if (unpackneg(q3, publicKey)) {
        return false;
      }
      const hs3 = new sha512_1.SHA512();
      hs3.update(signature.subarray(0, 32));
      hs3.update(publicKey);
      hs3.update(message);
      const h5 = hs3.digest();
      reduce(h5);
      scalarmult(p5, q3, h5);
      scalarbase(q3, signature.subarray(32));
      edadd(p5, q3);
      pack(t, p5);
      if (verify32(signature, t)) {
        return false;
      }
      return true;
    }
    exports.verify = verify2;
    function convertPublicKeyToX25519(publicKey) {
      let q3 = [gf(), gf(), gf(), gf()];
      if (unpackneg(q3, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      let a2 = gf();
      let b5 = gf();
      let y6 = q3[1];
      add(a2, gf1, y6);
      sub(b5, gf1, y6);
      inv25519(b5, b5);
      mul(a2, a2, b5);
      let z4 = new Uint8Array(32);
      pack25519(z4, a2);
      return z4;
    }
    exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    function convertSecretKeyToX25519(secretKey) {
      const d3 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const o = new Uint8Array(d3.subarray(0, 32));
      (0, wipe_1.wipe)(d3);
      return o;
    }
    exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
  }
});

// node_modules/.pnpm/ws@7.5.9/node_modules/ws/browser.js
var require_browser2 = __commonJS({
  "node_modules/.pnpm/ws@7.5.9/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    var import_dist22 = __toESM(require_dist());
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/.pnpm/lodash.isequal@4.5.0/node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash.isequal@4.5.0/node_modules/lodash.isequal/index.js"(exports, module) {
    var import_dist22 = __toESM(require_dist());
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n3, iteratee) {
      var index = -1, result = Array(n3);
      while (++index < n3) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys2, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/.pnpm/@walletconnect+ethereum-provider@2.10.2_@walletconnect+modal@2.6.2/node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var import_dist21 = __toESM(require_dist());
var import_events7 = __toESM(require_events());

// node_modules/.pnpm/@walletconnect+universal-provider@2.10.2/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_dist20 = __toESM(require_dist());

// node_modules/.pnpm/@walletconnect+sign-client@2.10.2/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_dist19 = __toESM(require_dist());

// node_modules/.pnpm/@walletconnect+core@2.10.2/node_modules/@walletconnect/core/dist/index.es.js
var import_dist18 = __toESM(require_dist());
var import_events4 = __toESM(require_events());

// node_modules/.pnpm/@walletconnect+keyvaluestorage@1.1.1/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var import_dist5 = __toESM(require_dist());

// node_modules/.pnpm/unstorage@1.10.2_idb-keyval@6.2.1/node_modules/unstorage/dist/index.mjs
var import_dist3 = __toESM(require_dist(), 1);

// node_modules/.pnpm/destr@2.0.3/node_modules/destr/dist/index.mjs
var import_dist = __toESM(require_dist(), 1);
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  const _value = value.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    value[0] === '"' && value.endsWith('"') && !value.includes("\\")
  ) {
    return _value.slice(1, -1);
  }
  if (_value.length <= 9) {
    const _lval = _value.toLowerCase();
    if (_lval === "true") {
      return true;
    }
    if (_lval === "false") {
      return false;
    }
    if (_lval === "undefined") {
      return void 0;
    }
    if (_lval === "null") {
      return null;
    }
    if (_lval === "nan") {
      return Number.NaN;
    }
    if (_lval === "infinity") {
      return Number.POSITIVE_INFINITY;
    }
    if (_lval === "-infinity") {
      return Number.NEGATIVE_INFINITY;
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/.pnpm/unstorage@1.10.2_idb-keyval@6.2.1/node_modules/unstorage/dist/shared/unstorage.8581f561.mjs
var import_dist2 = __toESM(require_dist(), 1);
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof Buffer === void 0) {
    throw new TypeError("[unstorage] Buffer is not supported!");
  }
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  checkBufferSupport();
  const base64 = Buffer.from(value).toString("base64");
  return BASE64_PREFIX + base64;
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  checkBufferSupport();
  return Buffer.from(value.slice(BASE64_PREFIX.length), "base64");
}
function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "");
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}

// node_modules/.pnpm/unstorage@1.10.2_idb-keyval@6.2.1/node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    options: {},
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return Array.from(data.keys());
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r) => r.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r) => r.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      for (const mount of mounts) {
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        const keys2 = rawKeys.map((key) => mount.mountpoint + normalizeKey(key)).filter((key) => !maskedMounts.some((p5) => key.startsWith(p5)));
        allKeys.push(...keys2);
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p5) => !p5.startsWith(mount.mountpoint))
        ];
      }
      return base ? allKeys.filter((key) => key.startsWith(base) && !key.endsWith("$")) : allKeys.filter((key) => !key.endsWith("$"));
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m2) => {
          if (m2.driver.clear) {
            return asyncCall(m2.driver.clear, m2.relativeBase, opts);
          }
          if (m2.driver.removeItem) {
            const keys2 = await m2.driver.getKeys(m2.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m2.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a2, b5) => b5.length - a2.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        context.unwatch[base]();
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m2 = getMount(key);
      return {
        driver: m2.driver,
        base: m2.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m2) => ({
        driver: m2.driver,
        base: m2.mountpoint
      }));
    }
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/.pnpm/idb-keyval@6.2.1/node_modules/idb-keyval/dist/index.js
var import_dist4 = __toESM(require_dist());
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}

// node_modules/.pnpm/@walletconnect+keyvaluestorage@1.1.1/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
init_esm();
var x = "idb-keyval";
var z = (i3 = {}) => {
  const t = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e = (s2) => t + s2;
  let n3;
  return i3.dbName && i3.storeName && (n3 = createStore(i3.dbName, i3.storeName)), { name: x, options: i3, async hasItem(s2) {
    return !(typeof await get(e(s2), n3) > "u");
  }, async getItem(s2) {
    return await get(e(s2), n3) ?? null;
  }, setItem(s2, a2) {
    return set(e(s2), a2, n3);
  }, removeItem(s2) {
    return del(e(s2), n3);
  }, getKeys() {
    return keys(n3);
  }, clear() {
    return clear(n3);
  } };
};
var D2 = "WALLET_CONNECT_V2_INDEXED_DB";
var E = "keyvaluestorage";
var _2 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D2, storeName: E }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null)
      return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i3;
  function t() {
  }
  i3 = t, i3.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i3.prototype.setItem = function(e, n3) {
    this[e] = String(n3);
  }, i3.prototype.removeItem = function(e) {
    delete this[e];
  }, i3.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n3) {
      e[n3] = void 0, delete e[n3];
    });
  }, i3.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k(i3) {
  var t;
  return [i3[0], safeJsonParse((t = i3[1]) != null ? t : "")];
}
var K = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k);
  }
  async getItem(t) {
    const e = this.localStorage.getItem(t);
    if (e !== null)
      return safeJsonParse(e);
  }
  async setItem(t, e) {
    this.localStorage.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N2 = "wc_storage_version";
var y = 1;
var O = async (i3, t, e) => {
  const n3 = N2, s2 = await t.getItem(n3);
  if (s2 && s2 >= y) {
    e(t);
    return;
  }
  const a2 = await i3.getKeys();
  if (!a2.length) {
    e(t);
    return;
  }
  const m2 = [];
  for (; a2.length; ) {
    const r = a2.shift();
    if (!r)
      continue;
    const o = r.toLowerCase();
    if (o.includes("wc@") || o.includes("walletconnect") || o.includes("wc_") || o.includes("wallet_connect")) {
      const f3 = await i3.getItem(r);
      await t.setItem(r, f3), m2.push(r);
    }
  }
  await t.setItem(n3, y), e(t), j2(i3, m2);
};
var j2 = async (i3, t) => {
  t.length && t.forEach(async (e) => {
    await i3.removeItem(e);
  });
};
var h2 = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e) => {
      this.storage = e, this.initialized = true;
    };
    const t = new K();
    this.storage = t;
    try {
      const e = new _2();
      O(t, e, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};

// node_modules/.pnpm/@walletconnect+core@2.10.2/node_modules/@walletconnect/core/dist/index.es.js
var import_heartbeat = __toESM(require_cjs2());

// node_modules/.pnpm/@walletconnect+logger@2.1.2/node_modules/@walletconnect/logger/dist/index.es.js
var import_dist8 = __toESM(require_dist());
var import_pino = __toESM(require_browser());
var import_pino2 = __toESM(require_browser());
init_esm();
var c2 = { level: "info" };
var n = "custom_context";
var l2 = 1e3 * 1024;
var O2 = class {
  constructor(e) {
    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
};
var d = class {
  constructor(e) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
  }
  append(e) {
    const t = new O2(e);
    if (t.size > this.maxSizeInBytes)
      throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);
    for (; this.size + t.size > this.maxSizeInBytes; )
      this.shift();
    this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;
  }
  shift() {
    if (!this.head)
      return;
    const e = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
  }
  toArray() {
    const e = [];
    let t = this.head;
    for (; t !== null; )
      e.push(t.value), t = t.next;
    return e;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this.head;
    return { next: () => {
      if (!e)
        return { done: true, value: null };
      const t = e.value;
      return e = e.next, { done: false, value: t };
    } };
  }
};
var x2 = Object.defineProperty;
var S2 = Object.defineProperties;
var _3 = Object.getOwnPropertyDescriptors;
var p2 = Object.getOwnPropertySymbols;
var T = Object.prototype.hasOwnProperty;
var z2 = Object.prototype.propertyIsEnumerable;
var f = (r, e, t) => e in r ? x2(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var i = (r, e) => {
  for (var t in e || (e = {}))
    T.call(e, t) && f(r, t, e[t]);
  if (p2)
    for (var t of p2(e))
      z2.call(e, t) && f(r, t, e[t]);
  return r;
};
var g = (r, e) => S2(r, _3(e));
function k2(r) {
  return g(i({}, r), { level: (r == null ? void 0 : r.level) || c2.level });
}
function v(r, e = n) {
  return r[e] || "";
}
function b(r, e, t = n) {
  return r[t] = e, r;
}
function y2(r, e = n) {
  let t = "";
  return typeof r.bindings > "u" ? t = v(r, e) : t = r.bindings().context || "", t;
}
function w2(r, e, t = n) {
  const o = y2(r, t);
  return o.trim() ? `${o}/${e}` : e;
}
function E2(r, e, t = n) {
  const o = w2(r, e, t), a2 = r.child({ context: o });
  return b(a2, o, t);
}

// node_modules/.pnpm/@walletconnect+types@2.10.2/node_modules/@walletconnect/types/dist/index.es.js
var import_dist9 = __toESM(require_dist());
init_esm3();
var import_events2 = __toESM(require_events());
var n2 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var h4 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a = class {
  constructor(s2, t) {
    this.logger = s2, this.core = t;
  }
};
var u = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var g2 = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var p3 = class {
  constructor(s2, t, o, w4) {
    this.core = s2, this.logger = t, this.name = o;
  }
};
var d2 = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var E3 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t;
  }
};
var y3 = class {
  constructor(s2, t) {
    this.projectId = s2, this.logger = t;
  }
};
var b2 = class {
  constructor(s2) {
    this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var S3 = class {
  constructor(s2) {
    this.client = s2;
  }
};

// node_modules/.pnpm/@walletconnect+core@2.10.2/node_modules/@walletconnect/core/dist/index.es.js
init_esm();

// node_modules/.pnpm/@walletconnect+relay-auth@1.0.4/node_modules/@walletconnect/relay-auth/dist/esm/index.js
var import_dist14 = __toESM(require_dist());

// node_modules/.pnpm/@walletconnect+relay-auth@1.0.4/node_modules/@walletconnect/relay-auth/dist/esm/api.js
var import_dist12 = __toESM(require_dist());
var ed25519 = __toESM(require_ed25519());
var import_random = __toESM(require_random());
var import_time = __toESM(require_cjs());

// node_modules/.pnpm/@walletconnect+relay-auth@1.0.4/node_modules/@walletconnect/relay-auth/dist/esm/constants.js
var import_dist10 = __toESM(require_dist());
var JWT_IRIDIUM_ALG = "EdDSA";
var JWT_IRIDIUM_TYP = "JWT";
var JWT_DELIMITER = ".";
var JWT_ENCODING = "base64url";
var JSON_ENCODING = "utf8";
var DATA_ENCODING = "utf8";
var DID_DELIMITER = ":";
var DID_PREFIX = "did";
var DID_METHOD = "key";
var MULTICODEC_ED25519_ENCODING = "base58btc";
var MULTICODEC_ED25519_BASE = "z";
var MULTICODEC_ED25519_HEADER = "K36";
var KEY_PAIR_SEED_LENGTH = 32;

// node_modules/.pnpm/@walletconnect+relay-auth@1.0.4/node_modules/@walletconnect/relay-auth/dist/esm/utils.js
var import_dist11 = __toESM(require_dist());
init_esm();
function encodeJSON(val) {
  return toString(fromString(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(publicKey) {
  const header = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
  const multicodec = MULTICODEC_ED25519_BASE + toString(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
}
function encodeSig(bytes) {
  return toString(bytes, JWT_ENCODING);
}
function encodeData(params) {
  return fromString([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(params) {
  return [
    encodeJSON(params.header),
    encodeJSON(params.payload),
    encodeSig(params.signature)
  ].join(JWT_DELIMITER);
}

// node_modules/.pnpm/@walletconnect+relay-auth@1.0.4/node_modules/@walletconnect/relay-auth/dist/esm/api.js
function generateKeyPair(seed = (0, import_random.randomBytes)(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(seed);
}
async function signJWT(sub, aud, ttl, keyPair, iat = (0, import_time.fromMiliseconds)(Date.now())) {
  const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
  const iss = encodeIss(keyPair.publicKey);
  const exp = iat + ttl;
  const payload = { iss, sub, aud, iat, exp };
  const data = encodeData({ header, payload });
  const signature = ed25519.sign(keyPair.secretKey, data);
  return encodeJWT({ header, payload, signature });
}

// node_modules/.pnpm/@walletconnect+relay-auth@1.0.4/node_modules/@walletconnect/relay-auth/dist/esm/types.js
var import_dist13 = __toESM(require_dist());

// node_modules/.pnpm/@walletconnect+core@2.10.2/node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());
init_esm2();

// node_modules/.pnpm/@walletconnect+jsonrpc-ws-connection@1.0.13/node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/index.js
var import_dist17 = __toESM(require_dist());

// node_modules/.pnpm/@walletconnect+jsonrpc-ws-connection@1.0.13/node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/ws.js
var import_dist16 = __toESM(require_dist());
var import_events3 = __toESM(require_events());
init_esm();
init_esm2();

// node_modules/.pnpm/@walletconnect+jsonrpc-ws-connection@1.0.13/node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/utils.js
var import_dist15 = __toESM(require_dist());
var resolveWebSocketImplementation = () => {
  if (typeof WebSocket !== "undefined") {
    return WebSocket;
  } else if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
    return global.WebSocket;
  } else if (typeof window !== "undefined" && typeof window.WebSocket !== "undefined") {
    return window.WebSocket;
  } else if (typeof self !== "undefined" && typeof self.WebSocket !== "undefined") {
    return self.WebSocket;
  }
  return require_browser2();
};
var hasBuiltInWebSocket = () => typeof WebSocket !== "undefined" || typeof global !== "undefined" && typeof global.WebSocket !== "undefined" || typeof window !== "undefined" && typeof window.WebSocket !== "undefined" || typeof self !== "undefined" && typeof self.WebSocket !== "undefined";
var truncateQuery = (wssUrl) => wssUrl.split("?")[0];

// node_modules/.pnpm/@walletconnect+jsonrpc-ws-connection@1.0.13/node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/ws.js
var EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
var WS = resolveWebSocketImplementation();
var WsConnection = class {
  constructor(url) {
    this.url = url;
    this.events = new import_events3.EventEmitter();
    this.registering = false;
    if (!isWsUrl(url)) {
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
    }
    this.url = url;
  }
  get connected() {
    return typeof this.socket !== "undefined";
  }
  get connecting() {
    return this.registering;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(url = this.url) {
    await this.register(url);
  }
  async close() {
    return new Promise((resolve, reject) => {
      if (typeof this.socket === "undefined") {
        reject(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (event) => {
        this.onClose(event);
        resolve();
      };
      this.socket.close();
    });
  }
  async send(payload, context) {
    if (typeof this.socket === "undefined") {
      this.socket = await this.register();
    }
    try {
      this.socket.send(safeJsonStringify(payload));
    } catch (e) {
      this.onError(payload.id, e);
    }
  }
  register(url = this.url) {
    if (!isWsUrl(url)) {
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
    }
    if (this.registering) {
      const currentMaxListeners = this.events.getMaxListeners();
      if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
        this.events.setMaxListeners(currentMaxListeners + 1);
      }
      return new Promise((resolve, reject) => {
        this.events.once("register_error", (error) => {
          this.resetMaxListeners();
          reject(error);
        });
        this.events.once("open", () => {
          this.resetMaxListeners();
          if (typeof this.socket === "undefined") {
            return reject(new Error("WebSocket connection is missing or invalid"));
          }
          resolve(this.socket);
        });
      });
    }
    this.url = url;
    this.registering = true;
    return new Promise((resolve, reject) => {
      const opts = !(0, esm_exports.isReactNative)() ? { rejectUnauthorized: !isLocalhostUrl(url) } : void 0;
      const socket = new WS(url, [], opts);
      if (hasBuiltInWebSocket()) {
        socket.onerror = (event) => {
          const errorEvent = event;
          reject(this.emitError(errorEvent.error));
        };
      } else {
        socket.on("error", (errorEvent) => {
          reject(this.emitError(errorEvent));
        });
      }
      socket.onopen = () => {
        this.onOpen(socket);
        resolve(socket);
      };
    });
  }
  onOpen(socket) {
    socket.onmessage = (event) => this.onPayload(event);
    socket.onclose = (event) => this.onClose(event);
    this.socket = socket;
    this.registering = false;
    this.events.emit("open");
  }
  onClose(event) {
    this.socket = void 0;
    this.registering = false;
    this.events.emit("close", event);
  }
  onPayload(e) {
    if (typeof e.data === "undefined")
      return;
    const payload = typeof e.data === "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", payload);
  }
  onError(id, e) {
    const error = this.parseError(e);
    const message = error.message || error.toString();
    const payload = formatJsonRpcError(id, message);
    this.events.emit("payload", payload);
  }
  parseError(e, url = this.url) {
    return parseConnectionError(e, truncateQuery(url), "WS");
  }
  resetMaxListeners() {
    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
    }
  }
  emitError(errorEvent) {
    const error = this.parseError(new Error((errorEvent === null || errorEvent === void 0 ? void 0 : errorEvent.message) || `WebSocket connection failed for host: ${truncateQuery(this.url)}`));
    this.events.emit("register_error", error);
    return error;
  }
};
var ws_default = WsConnection;

// node_modules/.pnpm/@walletconnect+jsonrpc-ws-connection@1.0.13/node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/index.js
var esm_default2 = ws_default;

// node_modules/.pnpm/@walletconnect+core@2.10.2/node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
function Ki(r, e) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i3 = 0; i3 < t.length; i3++)
    t[i3] = 255;
  for (var s2 = 0; s2 < r.length; s2++) {
    var n3 = r.charAt(s2), a2 = n3.charCodeAt(0);
    if (t[a2] !== 255)
      throw new TypeError(n3 + " is ambiguous");
    t[a2] = s2;
  }
  var o = r.length, h5 = r.charAt(0), u3 = Math.log(o) / Math.log(256), d3 = Math.log(256) / Math.log(o);
  function p5(c4) {
    if (c4 instanceof Uint8Array || (ArrayBuffer.isView(c4) ? c4 = new Uint8Array(c4.buffer, c4.byteOffset, c4.byteLength) : Array.isArray(c4) && (c4 = Uint8Array.from(c4))), !(c4 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c4.length === 0)
      return "";
    for (var m2 = 0, z4 = 0, I2 = 0, _5 = c4.length; I2 !== _5 && c4[I2] === 0; )
      I2++, m2++;
    for (var S5 = (_5 - I2) * d3 + 1 >>> 0, b5 = new Uint8Array(S5); I2 !== _5; ) {
      for (var P2 = c4[I2], A2 = 0, C = S5 - 1; (P2 !== 0 || A2 < z4) && C !== -1; C--, A2++)
        P2 += 256 * b5[C] >>> 0, b5[C] = P2 % o >>> 0, P2 = P2 / o >>> 0;
      if (P2 !== 0)
        throw new Error("Non-zero carry");
      z4 = A2, I2++;
    }
    for (var x3 = S5 - z4; x3 !== S5 && b5[x3] === 0; )
      x3++;
    for (var q3 = h5.repeat(m2); x3 < S5; ++x3)
      q3 += r.charAt(b5[x3]);
    return q3;
  }
  function y6(c4) {
    if (typeof c4 != "string")
      throw new TypeError("Expected String");
    if (c4.length === 0)
      return new Uint8Array();
    var m2 = 0;
    if (c4[m2] !== " ") {
      for (var z4 = 0, I2 = 0; c4[m2] === h5; )
        z4++, m2++;
      for (var _5 = (c4.length - m2) * u3 + 1 >>> 0, S5 = new Uint8Array(_5); c4[m2]; ) {
        var b5 = t[c4.charCodeAt(m2)];
        if (b5 === 255)
          return;
        for (var P2 = 0, A2 = _5 - 1; (b5 !== 0 || P2 < I2) && A2 !== -1; A2--, P2++)
          b5 += o * S5[A2] >>> 0, S5[A2] = b5 % 256 >>> 0, b5 = b5 / 256 >>> 0;
        if (b5 !== 0)
          throw new Error("Non-zero carry");
        I2 = P2, m2++;
      }
      if (c4[m2] !== " ") {
        for (var C = _5 - I2; C !== _5 && S5[C] === 0; )
          C++;
        for (var x3 = new Uint8Array(z4 + (_5 - C)), q3 = z4; C !== _5; )
          x3[q3++] = S5[C++];
        return x3;
      }
    }
  }
  function $3(c4) {
    var m2 = y6(c4);
    if (m2)
      return m2;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p5, decodeUnsafe: y6, decode: $3 };
}
var Bi = Ki;
var Vi = Bi;
var ze = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var qi = (r) => new TextEncoder().encode(r);
var ji = (r) => new TextDecoder().decode(r);
var Yi = class {
  constructor(e, t, i3) {
    this.name = e, this.prefix = t, this.baseEncode = i3;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Gi = class {
  constructor(e, t, i3) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i3;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Ne(this, e);
  }
};
var Hi = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Ne(this, e);
  }
  decode(e) {
    const t = e[0], i3 = this.decoders[t];
    if (i3)
      return i3.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Ne = (r, e) => new Hi({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
var Ji = class {
  constructor(e, t, i3, s2) {
    this.name = e, this.prefix = t, this.baseEncode = i3, this.baseDecode = s2, this.encoder = new Yi(e, t, i3), this.decoder = new Gi(e, t, s2);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var W = ({ name: r, prefix: e, encode: t, decode: i3 }) => new Ji(r, e, t, i3);
var K2 = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: i3, decode: s2 } = Vi(t, e);
  return W({ prefix: r, name: e, encode: i3, decode: (n3) => ze(s2(n3)) });
};
var Wi = (r, e, t, i3) => {
  const s2 = {};
  for (let d3 = 0; d3 < e.length; ++d3)
    s2[e[d3]] = d3;
  let n3 = r.length;
  for (; r[n3 - 1] === "="; )
    --n3;
  const a2 = new Uint8Array(n3 * t / 8 | 0);
  let o = 0, h5 = 0, u3 = 0;
  for (let d3 = 0; d3 < n3; ++d3) {
    const p5 = s2[r[d3]];
    if (p5 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    h5 = h5 << t | p5, o += t, o >= 8 && (o -= 8, a2[u3++] = 255 & h5 >> o);
  }
  if (o >= t || 255 & h5 << 8 - o)
    throw new SyntaxError("Unexpected end of data");
  return a2;
};
var Xi = (r, e, t) => {
  const i3 = e[e.length - 1] === "=", s2 = (1 << t) - 1;
  let n3 = "", a2 = 0, o = 0;
  for (let h5 = 0; h5 < r.length; ++h5)
    for (o = o << 8 | r[h5], a2 += 8; a2 > t; )
      a2 -= t, n3 += e[s2 & o >> a2];
  if (a2 && (n3 += e[s2 & o << t - a2]), i3)
    for (; n3.length * t & 7; )
      n3 += "=";
  return n3;
};
var g3 = ({ name: r, prefix: e, bitsPerChar: t, alphabet: i3 }) => W({ prefix: e, name: r, encode(s2) {
  return Xi(s2, i3, t);
}, decode(s2) {
  return Wi(s2, i3, t, r);
} });
var Qi = W({ prefix: "\0", name: "identity", encode: (r) => ji(r), decode: (r) => qi(r) });
var Zi = Object.freeze({ __proto__: null, identity: Qi });
var es = g3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var ts = Object.freeze({ __proto__: null, base2: es });
var is = g3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var ss = Object.freeze({ __proto__: null, base8: is });
var rs = K2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var ns = Object.freeze({ __proto__: null, base10: rs });
var as = g3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var os = g3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var hs = Object.freeze({ __proto__: null, base16: as, base16upper: os });
var cs = g3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var us = g3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var ls = g3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var ds = g3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var gs = g3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var ps = g3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Ds = g3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var ys = g3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var ms = g3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var bs = Object.freeze({ __proto__: null, base32: cs, base32upper: us, base32pad: ls, base32padupper: ds, base32hex: gs, base32hexupper: ps, base32hexpad: Ds, base32hexpadupper: ys, base32z: ms });
var fs = K2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Es = K2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var ws = Object.freeze({ __proto__: null, base36: fs, base36upper: Es });
var vs = K2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Is = K2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Cs = Object.freeze({ __proto__: null, base58btc: vs, base58flickr: Is });
var Rs = g3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var _s = g3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Ss = g3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Ps = g3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ts = Object.freeze({ __proto__: null, base64: Rs, base64pad: _s, base64url: Ss, base64urlpad: Ps });
var Le = Array.from("");
var xs = Le.reduce((r, e, t) => (r[t] = e, r), []);
var Os = Le.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function As(r) {
  return r.reduce((e, t) => (e += xs[t], e), "");
}
function zs(r) {
  const e = [];
  for (const t of r) {
    const i3 = Os[t.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i3);
  }
  return new Uint8Array(e);
}
var Ns = W({ prefix: "", name: "base256emoji", encode: As, decode: zs });
var Ls = Object.freeze({ __proto__: null, base256emoji: Ns });
var Us = Fe;
var Ue = 128;
var Fs = 127;
var $s = ~Fs;
var Ms = Math.pow(2, 31);
function Fe(r, e, t) {
  e = e || [], t = t || 0;
  for (var i3 = t; r >= Ms; )
    e[t++] = r & 255 | Ue, r /= 128;
  for (; r & $s; )
    e[t++] = r & 255 | Ue, r >>>= 7;
  return e[t] = r | 0, Fe.bytes = t - i3 + 1, e;
}
var ks = oe2;
var Ks = 128;
var $e = 127;
function oe2(r, i3) {
  var t = 0, i3 = i3 || 0, s2 = 0, n3 = i3, a2, o = r.length;
  do {
    if (n3 >= o)
      throw oe2.bytes = 0, new RangeError("Could not decode varint");
    a2 = r[n3++], t += s2 < 28 ? (a2 & $e) << s2 : (a2 & $e) * Math.pow(2, s2), s2 += 7;
  } while (a2 >= Ks);
  return oe2.bytes = n3 - i3, t;
}
var Bs = Math.pow(2, 7);
var Vs = Math.pow(2, 14);
var qs = Math.pow(2, 21);
var js = Math.pow(2, 28);
var Ys = Math.pow(2, 35);
var Gs = Math.pow(2, 42);
var Hs = Math.pow(2, 49);
var Js = Math.pow(2, 56);
var Ws = Math.pow(2, 63);
var Xs = function(r) {
  return r < Bs ? 1 : r < Vs ? 2 : r < qs ? 3 : r < js ? 4 : r < Ys ? 5 : r < Gs ? 6 : r < Hs ? 7 : r < Js ? 8 : r < Ws ? 9 : 10;
};
var Qs = { encode: Us, decode: ks, encodingLength: Xs };
var Me = Qs;
var ke = (r, e, t = 0) => (Me.encode(r, e, t), e);
var Ke = (r) => Me.encodingLength(r);
var he = (r, e) => {
  const t = e.byteLength, i3 = Ke(r), s2 = i3 + Ke(t), n3 = new Uint8Array(s2 + t);
  return ke(r, n3, 0), ke(t, n3, i3), n3.set(e, s2), new Zs(r, t, e, n3);
};
var Zs = class {
  constructor(e, t, i3, s2) {
    this.code = e, this.size = t, this.digest = i3, this.bytes = s2;
  }
};
var Be = ({ name: r, code: e, encode: t }) => new er2(r, e, t);
var er2 = class {
  constructor(e, t, i3) {
    this.name = e, this.code = t, this.encode = i3;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? he(this.code, t) : t.then((i3) => he(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Ve = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e));
var tr = Be({ name: "sha2-256", code: 18, encode: Ve("SHA-256") });
var ir = Be({ name: "sha2-512", code: 19, encode: Ve("SHA-512") });
var sr = Object.freeze({ __proto__: null, sha256: tr, sha512: ir });
var qe = 0;
var rr = "identity";
var je = ze;
var nr = (r) => he(qe, je(r));
var ar = { code: qe, name: rr, encode: je, digest: nr };
var or = Object.freeze({ __proto__: null, identity: ar });
new TextEncoder(), new TextDecoder();
var Ye = { ...Zi, ...ts, ...ss, ...ns, ...hs, ...bs, ...ws, ...Cs, ...Ts, ...Ls };
({ ...sr, ...or });
function Ge(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function hr(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ge(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function He(r, e, t, i3) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: i3 } };
}
var Je = He("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var ce = He("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++)
    e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = hr(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
});
var cr = { utf8: Je, "utf-8": Je, hex: Ye.base16, latin1: ce, ascii: ce, binary: ce, ...Ye };
function ur(r, e = "utf8") {
  const t = cr[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ge(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
var ue = "wc";
var We = 2;
var X = "core";
var O3 = `${ue}@2:${X}:`;
var Xe2 = { name: X, logger: "error" };
var Qe = { database: ":memory:" };
var Ze = "crypto";
var le = "client_ed25519_seed";
var et2 = import_time2.ONE_DAY;
var tt = "keychain";
var it2 = "0.3";
var st2 = "messages";
var rt = "0.3";
var nt2 = import_time2.SIX_HOURS;
var at2 = "publisher";
var ot = "irn";
var ht = "error";
var de = "wss://relay.walletconnect.com";
var ge = "wss://relay.walletconnect.org";
var ct2 = "relayer";
var D3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var ut2 = "_subscription";
var T2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var lt2 = import_time2.ONE_SECOND;
var dt2 = "2.10.2";
var gt = 1e4;
var pt2 = "0.3";
var Dt2 = "WALLETCONNECT_CLIENT_ID";
var w3 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var yt2 = "subscription";
var mt2 = "0.3";
var bt2 = import_time2.FIVE_SECONDS * 1e3;
var ft2 = "pairing";
var Et = "0.3";
var F = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var B2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var R = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var wt = "history";
var vt = "0.3";
var It = "expirer";
var v2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Ct = "0.3";
var Q = "verify-api";
var Z = "https://verify.walletconnect.com";
var pe = "https://verify.walletconnect.org";
var Rt = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = tt, this.version = it2, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }, this.has = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.set = async (i3, s2) => {
      this.isInitialized(), this.keychain.set(i3, s2), await this.persist();
    }, this.get = (i3) => {
      this.isInitialized();
      const s2 = this.keychain.get(i3);
      if (typeof s2 > "u") {
        const { message: n3 } = N("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(n3);
      }
      return s2;
    }, this.del = async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }, this.core = e, this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, et(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? nt(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var _t = class {
  constructor(e, t, i3) {
    this.core = e, this.logger = t, this.name = Ze, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s2) => (this.isInitialized(), this.keychain.has(s2)), this.getClientId = async () => {
      this.isInitialized();
      const s2 = await this.getClientSeed(), n3 = generateKeyPair(s2);
      return encodeIss(n3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s2 = jn();
      return this.setPrivateKey(s2.publicKey, s2.privateKey);
    }, this.signJWT = async (s2) => {
      this.isInitialized();
      const n3 = await this.getClientSeed(), a2 = generateKeyPair(n3), o = Dn(), h5 = et2;
      return await signJWT(o, s2, h5, a2);
    }, this.generateSharedKey = (s2, n3, a2) => {
      this.isInitialized();
      const o = this.getPrivateKey(s2), h5 = kn(o, n3);
      return this.setSymKey(h5, a2);
    }, this.setSymKey = async (s2, n3) => {
      this.isInitialized();
      const a2 = n3 || Vn(s2);
      return await this.keychain.set(a2, s2), a2;
    }, this.deleteKeyPair = async (s2) => {
      this.isInitialized(), await this.keychain.del(s2);
    }, this.deleteSymKey = async (s2) => {
      this.isInitialized(), await this.keychain.del(s2);
    }, this.encode = async (s2, n3, a2) => {
      this.isInitialized();
      const o = Re(a2), h5 = safeJsonStringify(n3);
      if (Fn(o)) {
        const y6 = o.senderPublicKey, $3 = o.receiverPublicKey;
        s2 = await this.generateSharedKey(y6, $3);
      }
      const u3 = this.getSymKey(s2), { type: d3, senderPublicKey: p5 } = o;
      return Kn({ type: d3, symKey: u3, message: h5, senderPublicKey: p5 });
    }, this.decode = async (s2, n3, a2) => {
      this.isInitialized();
      const o = xn(n3, a2);
      if (Fn(o)) {
        const h5 = o.receiverPublicKey, u3 = o.senderPublicKey;
        s2 = await this.generateSharedKey(h5, u3);
      }
      try {
        const h5 = this.getSymKey(s2), u3 = Ln({ symKey: h5, encoded: n3 });
        return safeJsonParse(u3);
      } catch (h5) {
        this.logger.error(`Failed to decode message from topic: '${s2}', clientId: '${await this.getClientId()}'`), this.logger.error(h5);
      }
    }, this.getPayloadType = (s2) => {
      const n3 = ee(s2);
      return $(n3.type);
    }, this.getPayloadSenderPublicKey = (s2) => {
      const n3 = ee(s2);
      return n3.senderPublicKey ? toString(n3.senderPublicKey, p) : void 0;
    }, this.core = e, this.logger = E2(t, this.name), this.keychain = i3 || new Rt(this.core, this.logger);
  }
  get context() {
    return y2(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(le);
    } catch {
      e = Dn(), await this.keychain.set(le, e);
    }
    return ur(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var St = class extends a {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = st2, this.version = rt, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i3, s2) => {
      this.isInitialized();
      const n3 = Mn(s2);
      let a2 = this.messages.get(i3);
      return typeof a2 > "u" && (a2 = {}), typeof a2[n3] < "u" || (a2[n3] = s2, this.messages.set(i3, a2), await this.persist()), n3;
    }, this.get = (i3) => {
      this.isInitialized();
      let s2 = this.messages.get(i3);
      return typeof s2 > "u" && (s2 = {}), s2;
    }, this.has = (i3, s2) => {
      this.isInitialized();
      const n3 = this.get(i3), a2 = Mn(s2);
      return typeof n3[a2] < "u";
    }, this.del = async (i3) => {
      this.isInitialized(), this.messages.delete(i3), await this.persist();
    }, this.logger = E2(e, this.name), this.core = t;
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, et(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? nt(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Dr = class extends u {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events4.EventEmitter(), this.name = at2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time2.toMiliseconds)(import_time2.TEN_SECONDS), this.needsTransportRestart = false, this.publish = async (i3, s2, n3) => {
      var a2;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s2, opts: n3 } });
      try {
        const o = (n3 == null ? void 0 : n3.ttl) || nt2, h5 = mt(n3), u3 = (n3 == null ? void 0 : n3.prompt) || false, d3 = (n3 == null ? void 0 : n3.tag) || 0, p5 = (n3 == null ? void 0 : n3.id) || getBigIntRpcId().toString(), y6 = { topic: i3, message: s2, opts: { ttl: o, relay: h5, prompt: u3, tag: d3, id: p5 } }, $3 = setTimeout(() => this.queue.set(p5, y6), this.publishTimeout);
        try {
          await await it(this.rpcPublish(i3, s2, o, h5, u3, d3, p5), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(p5), this.relayer.events.emit(D3.publish, y6);
        } catch (c4) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = true, (a2 = n3 == null ? void 0 : n3.internal) != null && a2.throwOnFailedPublish)
            throw this.removeRequestFromQueue(p5), c4;
          return;
        } finally {
          clearTimeout($3);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s2, opts: n3 } });
      } catch (o) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(o), o;
      }
    }, this.on = (i3, s2) => {
      this.events.on(i3, s2);
    }, this.once = (i3, s2) => {
      this.events.once(i3, s2);
    }, this.off = (i3, s2) => {
      this.events.off(i3, s2);
    }, this.removeListener = (i3, s2) => {
      this.events.removeListener(i3, s2);
    }, this.relayer = e, this.logger = E2(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y2(this.logger);
  }
  rpcPublish(e, t, i3, s2, n3, a2, o) {
    var h5, u3, d3, p5;
    const y6 = { method: yt(s2.protocol).publish, params: { topic: e, message: t, ttl: i3, prompt: n3, tag: a2 }, id: o };
    return w((h5 = y6.params) == null ? void 0 : h5.prompt) && ((u3 = y6.params) == null || delete u3.prompt), w((d3 = y6.params) == null ? void 0 : d3.tag) && ((p5 = y6.params) == null || delete p5.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: y6 }), this.relayer.request(y6);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: i3, opts: s2 } = e;
      await this.publish(t, i3, s2);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(D3.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D3.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var yr = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const i3 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i3, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const i3 = this.get(e);
      if (!this.exists(e, t))
        return;
      const s2 = i3.filter((n3) => n3 !== t);
      if (!s2.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s2);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var mr = Object.defineProperty;
var br = Object.defineProperties;
var fr = Object.getOwnPropertyDescriptors;
var Pt = Object.getOwnPropertySymbols;
var Er = Object.prototype.hasOwnProperty;
var wr = Object.prototype.propertyIsEnumerable;
var Tt = (r, e, t) => e in r ? mr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var V = (r, e) => {
  for (var t in e || (e = {}))
    Er.call(e, t) && Tt(r, t, e[t]);
  if (Pt)
    for (var t of Pt(e))
      wr.call(e, t) && Tt(r, t, e[t]);
  return r;
};
var De = (r, e) => br(r, fr(e));
var xt2 = class extends d2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new yr(), this.events = new import_events4.EventEmitter(), this.name = yt2, this.version = mt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O3, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i3, s2) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s2 } });
      try {
        const n3 = mt(s2), a2 = { topic: i3, relay: n3 };
        this.pending.set(i3, a2);
        const o = await this.rpcSubscribe(i3, n3);
        return this.onSubscribe(o, a2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s2 } }), o;
      } catch (n3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n3), n3;
      }
    }, this.unsubscribe = async (i3, s2) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s2 == null ? void 0 : s2.id) < "u" ? await this.unsubscribeById(i3, s2.id, s2) : await this.unsubscribeByTopic(i3, s2);
    }, this.isSubscribed = async (i3) => this.topics.includes(i3) ? true : await new Promise((s2, n3) => {
      const a2 = new import_time2.Watch();
      a2.start(this.pendingSubscriptionWatchLabel);
      const o = setInterval(() => {
        !this.pending.has(i3) && this.topics.includes(i3) && (clearInterval(o), a2.stop(this.pendingSubscriptionWatchLabel), s2(true)), a2.elapsed(this.pendingSubscriptionWatchLabel) >= bt2 && (clearInterval(o), a2.stop(this.pendingSubscriptionWatchLabel), n3(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => false), this.on = (i3, s2) => {
      this.events.on(i3, s2);
    }, this.once = (i3, s2) => {
      this.events.once(i3, s2);
    }, this.off = (i3, s2) => {
      this.events.off(i3, s2);
    }, this.removeListener = (i3, s2) => {
      this.events.removeListener(i3, s2);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = E2(t, this.name), this.clientId = "";
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i3;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i3 = this.topicMap.get(e);
    await Promise.all(i3.map(async (s2) => await this.unsubscribeById(e, s2, t)));
  }
  async unsubscribeById(e, t, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    try {
      const s2 = mt(i3);
      await this.rpcUnsubscribe(e, t, s2);
      const n3 = U("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    } catch (s2) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s2), s2;
    }
  }
  async rpcSubscribe(e, t) {
    const i3 = { method: yt(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await it(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D3.connection_stalled);
    }
    return Mn(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const t = e[0].relay, i3 = { method: yt(t.protocol).batchSubscribe, params: { topics: e.map((s2) => s2.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      return await await it(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D3.connection_stalled);
    }
  }
  rpcUnsubscribe(e, t, i3) {
    const s2 = { method: yt(i3.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 }), this.relayer.request(s2);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, De(V({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, V({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i3) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i3), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t));
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, V({}, t)), this.topicMap.set(t.topic, e), this.events.emit(w3.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i3 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i3.topic, e), this.events.emit(w3.deleted, De(V({}, i3), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(w3.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const i3 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i3);
      }
    }
    this.events.emit(w3.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const t = await this.rpcBatchSubscribe(e);
    D(t) && this.onBatchSubscribe(t.map((i3, s2) => De(V({}, e[s2]), { id: i3 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D3.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D3.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(w3.created, async (e) => {
      const t = w3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(w3.deleted, async (e) => {
      const t = w3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var vr = Object.defineProperty;
var Ot = Object.getOwnPropertySymbols;
var Ir = Object.prototype.hasOwnProperty;
var Cr = Object.prototype.propertyIsEnumerable;
var At2 = (r, e, t) => e in r ? vr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Rr = (r, e) => {
  for (var t in e || (e = {}))
    Ir.call(e, t) && At2(r, t, e[t]);
  if (Ot)
    for (var t of Ot(e))
      Cr.call(e, t) && At2(r, t, e[t]);
  return r;
};
var zt2 = class extends g2 {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events4.EventEmitter(), this.name = ct2, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = false, this.request = async (t) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t);
      } catch (i3) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i3), i3;
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t);
    }, this.onConnectHandler = () => {
      this.events.emit(D3.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(D3.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(T2.payload, this.onPayloadHandler), this.provider.on(T2.connect, this.onConnectHandler), this.provider.on(T2.disconnect, this.onDisconnectHandler), this.provider.on(T2.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E2(e.logger, this.name) : (0, import_pino2.default)(k2({ level: e.logger || ht })), this.messages = new St(this.logger, e.core), this.subscriber = new xt2(this, this.logger), this.publisher = new Dr(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || de, this.projectId = e.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${ge}...`), await this.restartTransport(ge);
    }
    this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, gt);
  }
  get context() {
    return y2(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, t, i3) {
    this.isInitialized(), await this.publisher.publish(e, t, i3), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });
  }
  async subscribe(e, t) {
    var i3;
    this.isInitialized();
    let s2 = ((i3 = this.subscriber.topicMap.get(e)) == null ? void 0 : i3[0]) || "";
    if (s2)
      return s2;
    let n3;
    const a2 = (o) => {
      o.topic === e && (this.subscriber.off(w3.created, a2), n3());
    };
    return await Promise.all([new Promise((o) => {
      n3 = o, this.subscriber.on(w3.created, a2);
    }), new Promise(async (o) => {
      s2 = await this.subscriber.subscribe(e, t), o();
    })]), s2;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, this.hasExperiencedNetworkDisruption && this.connected ? await it(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = false, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = true;
      try {
        await Promise.all([new Promise((t) => {
          if (!this.initialized)
            return t();
          this.subscriber.once(w3.resubscribed, () => {
            t();
          });
        }), new Promise(async (t, i3) => {
          try {
            await it(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (s2) {
            i3(s2);
            return;
          }
          t();
        })]);
      } catch (t) {
        this.logger.error(t);
        const i3 = t;
        if (!this.isConnectionStalled(i3.message))
          throw t;
        this.provider.events.emit(T2.disconnect);
      } finally {
        this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false;
      }
    }
  }
  async restartTransport(e) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Zt())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new esm_default2(Jn({ sdkVersion: dt2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    await this.messages.set(t, i3);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    if (!i3 || i3.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i3}`), true;
    if (!await this.subscriber.isSubscribed(t))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const s2 = this.messages.has(t, i3);
    return s2 && this.logger.debug(`Ignoring duplicate message: ${i3}`), s2;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(ut2))
        return;
      const t = e.params, { topic: i3, message: s2, publishedAt: n3 } = t.data, a2 = { topic: i3, message: s2, publishedAt: n3 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Rr({ type: "event", event: t.id }, a2)), this.events.emit(t.id, a2), await this.acknowledgePayload(e), await this.onMessageEvent(a2);
    } else
      isJsonRpcResponse(e) && this.events.emit(D3.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(D3.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(T2.payload, this.onPayloadHandler), this.provider.off(T2.connect, this.onConnectHandler), this.provider.off(T2.disconnect, this.onDisconnectHandler), this.provider.off(T2.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D3.connection_stalled, () => {
      this.restartTransport().catch((t) => this.logger.error(t));
    });
    let e = await Zt();
    Xt(async (t) => {
      this.initialized && e !== t && (e = t, t ? await this.restartTransport().catch((i3) => this.logger.error(i3)) : (this.hasExperiencedNetworkDisruption = true, await this.transportClose().catch((i3) => this.logger.error(i3))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D3.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e) => this.logger.error(e));
    }, (0, import_time2.toMiliseconds)(lt2)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var _r = Object.defineProperty;
var Nt2 = Object.getOwnPropertySymbols;
var Sr = Object.prototype.hasOwnProperty;
var Pr = Object.prototype.propertyIsEnumerable;
var Lt2 = (r, e, t) => e in r ? _r(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Ut = (r, e) => {
  for (var t in e || (e = {}))
    Sr.call(e, t) && Lt2(r, t, e[t]);
  if (Nt2)
    for (var t of Nt2(e))
      Pr.call(e, t) && Lt2(r, t, e[t]);
  return r;
};
var Ft2 = class extends p3 {
  constructor(e, t, i3, s2 = O3, n3 = void 0) {
    super(e, t, i3, s2), this.core = e, this.logger = t, this.name = i3, this.map = /* @__PURE__ */ new Map(), this.version = pt2, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a2) => {
        this.getKey && a2 !== null && !w(a2) ? this.map.set(this.getKey(a2), a2) : Dt(a2) ? this.map.set(a2.id, a2) : kt(a2) && this.map.set(a2.topic, a2);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (a2, o) => {
      this.isInitialized(), this.map.has(a2) ? await this.update(a2, o) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a2, value: o }), this.map.set(a2, o), await this.persist());
    }, this.get = (a2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a2 }), this.getData(a2)), this.getAll = (a2) => (this.isInitialized(), a2 ? this.values.filter((o) => Object.keys(a2).every((h5) => (0, import_lodash.default)(o[h5], a2[h5]))) : this.values), this.update = async (a2, o) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a2, update: o });
      const h5 = Ut(Ut({}, this.getData(a2)), o);
      this.map.set(a2, h5), await this.persist();
    }, this.delete = async (a2, o) => {
      this.isInitialized(), this.map.has(a2) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a2, reason: o }), this.map.delete(a2), await this.persist());
    }, this.logger = E2(t, this.name), this.storagePrefix = s2, this.getKey = n3;
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var $t2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = ft2, this.version = Et, this.events = new import_events4.default(), this.initialized = false, this.storagePrefix = O3, this.ignoredPayloadTypes = [_], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }, this.create = async () => {
      this.isInitialized();
      const i3 = Dn(), s2 = await this.core.crypto.setSymKey(i3), n3 = lt(import_time2.FIVE_MINUTES), a2 = { protocol: ot }, o = { topic: s2, expiry: n3, relay: a2, active: false }, h5 = Nt({ protocol: this.core.protocol, version: this.core.version, topic: s2, symKey: i3, relay: a2 });
      return await this.pairings.set(s2, o), await this.core.relayer.subscribe(s2), this.core.expirer.set(s2, n3), { topic: s2, uri: h5 };
    }, this.pair = async (i3) => {
      this.isInitialized(), this.isValidPair(i3);
      const { topic: s2, symKey: n3, relay: a2 } = bt(i3.uri);
      let o;
      if (this.pairings.keys.includes(s2) && (o = this.pairings.get(s2), o.active))
        throw new Error(`Pairing already exists: ${s2}. Please try again with a new connection URI.`);
      this.core.crypto.keychain.has(s2) || (await this.core.crypto.setSymKey(n3, s2), await this.core.relayer.subscribe(s2, { relay: a2 }));
      const h5 = lt(import_time2.FIVE_MINUTES), u3 = { topic: s2, relay: a2, expiry: h5, active: false };
      return await this.pairings.set(s2, u3), this.core.expirer.set(s2, h5), i3.activatePairing && await this.activate({ topic: s2 }), this.events.emit(B2.create, u3), u3;
    }, this.activate = async ({ topic: i3 }) => {
      this.isInitialized();
      const s2 = lt(import_time2.THIRTY_DAYS);
      await this.pairings.update(i3, { active: true, expiry: s2 }), this.core.expirer.set(i3, s2);
    }, this.ping = async (i3) => {
      this.isInitialized(), await this.isValidPing(i3);
      const { topic: s2 } = i3;
      if (this.pairings.keys.includes(s2)) {
        const n3 = await this.sendRequest(s2, "wc_pairingPing", {}), { done: a2, resolve: o, reject: h5 } = st();
        this.events.once(ft("pairing_ping", n3), ({ error: u3 }) => {
          u3 ? h5(u3) : o();
        }), await a2();
      }
    }, this.updateExpiry = async ({ topic: i3, expiry: s2 }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s2 });
    }, this.updateMetadata = async ({ topic: i3, metadata: s2 }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s2 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s2 } = i3;
      this.pairings.keys.includes(s2) && (await this.sendRequest(s2, "wc_pairingDelete", U("USER_DISCONNECTED")), await this.deletePairing(s2));
    }, this.sendRequest = async (i3, s2, n3) => {
      const a2 = formatJsonRpcRequest(s2, n3), o = await this.core.crypto.encode(i3, a2), h5 = F[s2].req;
      return this.core.history.set(i3, a2), this.core.relayer.publish(i3, o, h5), a2.id;
    }, this.sendResult = async (i3, s2, n3) => {
      const a2 = formatJsonRpcResult(i3, n3), o = await this.core.crypto.encode(s2, a2), h5 = await this.core.history.get(s2, i3), u3 = F[h5.request.method].res;
      await this.core.relayer.publish(s2, o, u3), await this.core.history.resolve(a2);
    }, this.sendError = async (i3, s2, n3) => {
      const a2 = formatJsonRpcError(i3, n3), o = await this.core.crypto.encode(s2, a2), h5 = await this.core.history.get(s2, i3), u3 = F[h5.request.method] ? F[h5.request.method].res : F.unregistered_method.res;
      await this.core.relayer.publish(s2, o, u3), await this.core.history.resolve(a2);
    }, this.deletePairing = async (i3, s2) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s2 ? Promise.resolve() : this.core.expirer.del(i3)]);
    }, this.cleanup = async () => {
      const i3 = this.pairings.getAll().filter((s2) => dt(s2.expiry));
      await Promise.all(i3.map((s2) => this.deletePairing(s2.topic)));
    }, this.onRelayEventRequest = (i3) => {
      const { topic: s2, payload: n3 } = i3;
      switch (n3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s2, n3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s2, n3);
        default:
          return this.onUnknownRpcMethodRequest(s2, n3);
      }
    }, this.onRelayEventResponse = async (i3) => {
      const { topic: s2, payload: n3 } = i3, a2 = (await this.core.history.get(s2, n3.id)).request.method;
      switch (a2) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s2, n3);
        default:
          return this.onUnknownRpcMethodResponse(a2);
      }
    }, this.onPairingPingRequest = async (i3, s2) => {
      const { id: n3 } = s2;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(n3, i3, true), this.events.emit(B2.ping, { id: n3, topic: i3 });
      } catch (a2) {
        await this.sendError(n3, i3, a2), this.logger.error(a2);
      }
    }, this.onPairingPingResponse = (i3, s2) => {
      const { id: n3 } = s2;
      setTimeout(() => {
        isJsonRpcResult(s2) ? this.events.emit(ft("pairing_ping", n3), {}) : isJsonRpcError(s2) && this.events.emit(ft("pairing_ping", n3), { error: s2.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i3, s2) => {
      const { id: n3 } = s2;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit(B2.delete, { id: n3, topic: i3 });
      } catch (a2) {
        await this.sendError(n3, i3, a2), this.logger.error(a2);
      }
    }, this.onUnknownRpcMethodRequest = async (i3, s2) => {
      const { id: n3, method: a2 } = s2;
      try {
        if (this.registeredMethods.includes(a2))
          return;
        const o = U("WC_METHOD_UNSUPPORTED", a2);
        await this.sendError(n3, i3, o), this.logger.error(o);
      } catch (o) {
        await this.sendError(n3, i3, o), this.logger.error(o);
      }
    }, this.onUnknownRpcMethodResponse = (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(U("WC_METHOD_UNSUPPORTED", i3));
    }, this.isValidPair = (i3) => {
      if (!xt(i3)) {
        const { message: s2 } = N("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw new Error(s2);
      }
      if (!jt(i3.uri)) {
        const { message: s2 } = N("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw new Error(s2);
      }
    }, this.isValidPing = async (i3) => {
      if (!xt(i3)) {
        const { message: n3 } = N("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(n3);
      }
      const { topic: s2 } = i3;
      await this.isValidPairingTopic(s2);
    }, this.isValidDisconnect = async (i3) => {
      if (!xt(i3)) {
        const { message: n3 } = N("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(n3);
      }
      const { topic: s2 } = i3;
      await this.isValidPairingTopic(s2);
    }, this.isValidPairingTopic = async (i3) => {
      if (!h(i3, false)) {
        const { message: s2 } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s2);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s2 } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s2);
      }
      if (dt(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s2 } = N("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s2);
      }
    }, this.core = e, this.logger = E2(t, this.name), this.pairings = new Ft2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y2(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D3.message, async (e) => {
      const { topic: t, message: i3 } = e;
      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3)))
        return;
      const s2 = await this.core.crypto.decode(t, i3);
      try {
        isJsonRpcRequest(s2) ? (this.core.history.set(t, s2), this.onRelayEventRequest({ topic: t, payload: s2 })) : isJsonRpcResponse(s2) && (await this.core.history.resolve(s2), await this.onRelayEventResponse({ topic: t, payload: s2 }), this.core.history.delete(t, s2.id));
      } catch (n3) {
        this.logger.error(n3);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(v2.expired, async (e) => {
      const { topic: t } = ut(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(B2.expire, { topic: t }));
    });
  }
};
var Mt2 = class extends h4 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = wt, this.version = vt, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i3, s2, n3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s2, chainId: n3 }), this.records.has(s2.id))
        return;
      const a2 = { id: s2.id, topic: i3, request: { method: s2.method, params: s2.params || null }, chainId: n3, expiry: lt(import_time2.THIRTY_DAYS) };
      this.records.set(a2.id, a2), this.events.emit(R.created, a2);
    }, this.resolve = async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id))
        return;
      const s2 = await this.getRecord(i3.id);
      typeof s2.response > "u" && (s2.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s2.id, s2), this.events.emit(R.updated, s2));
    }, this.get = async (i3, s2) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s2 }), await this.getRecord(s2)), this.delete = (i3, s2) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s2 }), this.values.forEach((n3) => {
        if (n3.topic === i3) {
          if (typeof s2 < "u" && n3.id !== s2)
            return;
          this.records.delete(n3.id), this.events.emit(R.deleted, n3);
        }
      });
    }, this.exists = async (i3, s2) => (this.isInitialized(), this.records.has(s2) ? (await this.getRecord(s2)).topic === i3 : false), this.on = (i3, s2) => {
      this.events.on(i3, s2);
    }, this.once = (i3, s2) => {
      this.events.once(i3, s2);
    }, this.off = (i3, s2) => {
      this.events.off(i3, s2);
    }, this.removeListener = (i3, s2) => {
      this.events.removeListener(i3, s2);
    }, this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i3 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i3);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(R.created, (e) => {
      const t = R.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R.updated, (e) => {
      const t = R.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.events.on(R.deleted, (e) => {
      const t = R.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e }), this.persist();
    }), this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        (0, import_time2.toMiliseconds)(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var kt2 = class extends E3 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = It, this.version = Ct, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i3) => {
      try {
        const s2 = this.formatTarget(i3);
        return typeof this.getExpiration(s2) < "u";
      } catch {
        return false;
      }
    }, this.set = (i3, s2) => {
      this.isInitialized();
      const n3 = this.formatTarget(i3), a2 = { target: n3, expiry: s2 };
      this.expirations.set(n3, a2), this.checkExpiry(n3, a2), this.events.emit(v2.created, { target: n3, expiration: a2 });
    }, this.get = (i3) => {
      this.isInitialized();
      const s2 = this.formatTarget(i3);
      return this.getExpiration(s2);
    }, this.del = (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s2 = this.formatTarget(i3), n3 = this.getExpiration(s2);
        this.expirations.delete(s2), this.events.emit(v2.deleted, { target: s2, expiration: n3 });
      }
    }, this.on = (i3, s2) => {
      this.events.on(i3, s2);
    }, this.once = (i3, s2) => {
      this.events.once(i3, s2);
    }, this.off = (i3, s2) => {
      this.events.off(i3, s2);
    }, this.removeListener = (i3, s2) => {
      this.events.removeListener(i3, s2);
    }, this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return ct(e);
    if (typeof e == "number")
      return at(e);
    const { message: t } = N("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(v2.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: t } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i3 } = t;
    (0, import_time2.toMiliseconds)(i3) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(v2.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(v2.created, (e) => {
      const t = v2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(v2.expired, (e) => {
      const t = v2.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(v2.deleted, (e) => {
      const t = v2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = N("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Kt2 = class extends y3 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.name = Q, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async () => {
      if (this.verifyDisabled || j() || !q())
        return;
      const i3 = Z;
      this.verifyUrl !== i3 && this.removeIframe(), this.verifyUrl = i3;
      try {
        await this.createIframe();
      } catch (s2) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s2);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = pe;
        try {
          await this.createIframe();
        } catch (s2) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s2), this.verifyDisabled = true;
        }
      }
    }, this.register = async (i3) => {
      this.initialized ? this.sendPost(i3.attestationId) : (this.addToQueue(i3.attestationId), await this.init());
    }, this.resolve = async (i3) => {
      if (this.isDevEnv)
        return "";
      const s2 = (i3 == null ? void 0 : i3.verifyUrl) || Z;
      let n3;
      try {
        n3 = await this.fetchAttestation(i3.attestationId, s2);
      } catch (a2) {
        this.logger.info(`failed to resolve attestation: ${i3.attestationId} from url: ${s2}`), this.logger.info(a2), n3 = await this.fetchAttestation(i3.attestationId, pe);
      }
      return n3;
    }, this.fetchAttestation = async (i3, s2) => {
      this.logger.info(`resolving attestation: ${i3} from url: ${s2}`);
      const n3 = this.startAbortTimer(import_time2.ONE_SECOND * 2), a2 = await fetch(`${s2}/attestation/${i3}`, { signal: this.abortController.signal });
      return clearTimeout(n3), a2.status === 200 ? await a2.json() : void 0;
    }, this.addToQueue = (i3) => {
      this.queue.push(i3);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i3) => this.sendPost(i3)), this.queue = []);
    }, this.sendPost = (i3) => {
      var s2;
      try {
        if (!this.iframe)
          return;
        (s2 = this.iframe.contentWindow) == null || s2.postMessage(i3, "*"), this.logger.info(`postMessage sent: ${i3} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i3;
      const s2 = (n3) => {
        n3.data === "verify_ready" && (this.initialized = true, this.processQueue(), window.removeEventListener("message", s2), i3());
      };
      await Promise.race([new Promise((n3) => {
        if (document.getElementById(Q))
          return n3();
        window.addEventListener("message", s2);
        const a2 = document.createElement("iframe");
        a2.id = Q, a2.src = `${this.verifyUrl}/${this.projectId}`, a2.style.display = "none", document.body.append(a2), this.iframe = a2, i3 = n3;
      }), new Promise((n3, a2) => setTimeout(() => {
        window.removeEventListener("message", s2), a2("verify iframe load timeout");
      }, (0, import_time2.toMiliseconds)(import_time2.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
    }, this.logger = E2(t, this.name), this.verifyUrl = Z, this.abortController = new AbortController(), this.isDevEnv = te() && process.env.IS_VITEST;
  }
  get context() {
    return y2(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e));
  }
};
var Tr = Object.defineProperty;
var Bt2 = Object.getOwnPropertySymbols;
var xr = Object.prototype.hasOwnProperty;
var Or = Object.prototype.propertyIsEnumerable;
var Vt2 = (r, e, t) => e in r ? Tr(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var qt2 = (r, e) => {
  for (var t in e || (e = {}))
    xr.call(e, t) && Vt2(r, t, e[t]);
  if (Bt2)
    for (var t of Bt2(e))
      Or.call(e, t) && Vt2(r, t, e[t]);
  return r;
};
var ee2 = class _ee extends n2 {
  constructor(e) {
    super(e), this.protocol = ue, this.version = We, this.name = X, this.events = new import_events4.EventEmitter(), this.initialized = false, this.on = (i3, s2) => this.events.on(i3, s2), this.once = (i3, s2) => this.events.once(i3, s2), this.off = (i3, s2) => this.events.off(i3, s2), this.removeListener = (i3, s2) => this.events.removeListener(i3, s2), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || de, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_pino2.default)(k2({ level: (e == null ? void 0 : e.logger) || Xe2.logger }));
    this.logger = E2(t, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new _t(this, this.logger, e == null ? void 0 : e.keychain), this.history = new Mt2(this, this.logger), this.expirer = new kt2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h2(qt2(qt2({}, Qe), e == null ? void 0 : e.storageOptions)), this.relayer = new zt2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new $t2(this, this.logger), this.verify = new Kt2(this.projectId || "", this.logger);
  }
  static async init(e) {
    const t = new _ee(e);
    await t.initialize();
    const i3 = await t.crypto.getClientId();
    return await t.storage.setItem(Dt2, i3), t;
  }
  get context() {
    return y2(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var Ar = ee2;

// node_modules/.pnpm/@walletconnect+sign-client@2.10.2/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events5 = __toESM(require_events());
var import_time3 = __toESM(require_cjs());
init_esm2();
var X2 = "wc";
var F2 = 2;
var H = "client";
var G = `${X2}@${F2}:${H}:`;
var M = { name: H, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
var W2 = "WALLETCONNECT_DEEPLINK_CHOICE";
var ne = "proposal";
var oe3 = "Proposal expired";
var ae = "session";
var A = import_time3.SEVEN_DAYS;
var ce2 = "engine";
var V2 = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1115 } } };
var U4 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var I = { idle: "IDLE", active: "ACTIVE" };
var le2 = "request";
var pe2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var ns2 = Object.defineProperty;
var os2 = Object.defineProperties;
var as2 = Object.getOwnPropertyDescriptors;
var he2 = Object.getOwnPropertySymbols;
var cs2 = Object.prototype.hasOwnProperty;
var ls2 = Object.prototype.propertyIsEnumerable;
var de2 = (m2, r, e) => r in m2 ? ns2(m2, r, { enumerable: true, configurable: true, writable: true, value: e }) : m2[r] = e;
var g4 = (m2, r) => {
  for (var e in r || (r = {}))
    cs2.call(r, e) && de2(m2, e, r[e]);
  if (he2)
    for (var e of he2(r))
      ls2.call(r, e) && de2(m2, e, r[e]);
  return m2;
};
var b3 = (m2, r) => os2(m2, as2(r));
var ps2 = class extends S3 {
  constructor(r) {
    super(r), this.name = ce2, this.events = new import_events5.default(), this.initialized = false, this.ignoredPayloadTypes = [_], this.requestQueue = { state: I.idle, queue: [] }, this.sessionRequestQueue = { state: I.idle, queue: [] }, this.requestQueueDelay = import_time3.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(V2) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e) => {
      await this.isInitialized();
      const s2 = b3(g4({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(s2);
      const { pairingTopic: t, requiredNamespaces: i3, optionalNamespaces: n3, sessionProperties: o, relays: a2 } = s2;
      let c4 = t, p5, d3 = false;
      if (c4 && (d3 = this.client.core.pairing.pairings.get(c4).active), !c4 || !d3) {
        const { topic: v4, uri: S5 } = await this.client.core.pairing.create();
        c4 = v4, p5 = S5;
      }
      const h5 = await this.client.core.crypto.generateKeyPair(), R2 = g4({ requiredNamespaces: i3, optionalNamespaces: n3, relays: a2 ?? [{ protocol: ot }], proposer: { publicKey: h5, metadata: this.client.metadata } }, o && { sessionProperties: o }), { reject: w4, resolve: T3, done: K3 } = st(import_time3.FIVE_MINUTES, oe3);
      if (this.events.once(ft("session_connect"), async ({ error: v4, session: S5 }) => {
        if (v4)
          w4(v4);
        else if (S5) {
          S5.self.publicKey = h5;
          const B3 = b3(g4({}, S5), { requiredNamespaces: S5.requiredNamespaces, optionalNamespaces: S5.optionalNamespaces });
          await this.client.session.set(S5.topic, B3), await this.setExpiry(S5.topic, S5.expiry), c4 && await this.client.core.pairing.updateMetadata({ topic: c4, metadata: S5.peer.metadata }), T3(B3);
        }
      }), !c4) {
        const { message: v4 } = N("NO_MATCHING_KEY", `connect() pairing topic: ${c4}`);
        throw new Error(v4);
      }
      const L3 = await this.sendRequest({ topic: c4, method: "wc_sessionPropose", params: R2 }), ue2 = lt(import_time3.FIVE_MINUTES);
      return await this.setProposal(L3, g4({ id: L3, expiry: ue2 }, R2)), { uri: p5, approval: K3 };
    }, this.pair = async (e) => (await this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async (e) => {
      await this.isInitialized(), await this.isValidApprove(e);
      const { id: s2, relayProtocol: t, namespaces: i3, sessionProperties: n3 } = e, o = this.client.proposal.get(s2);
      let { pairingTopic: a2, proposer: c4, requiredNamespaces: p5, optionalNamespaces: d3 } = o;
      a2 = a2 || "", B(p5) || (p5 = At(i3, "approve()"));
      const h5 = await this.client.core.crypto.generateKeyPair(), R2 = c4.publicKey, w4 = await this.client.core.crypto.generateSharedKey(h5, R2);
      a2 && s2 && (await this.client.core.pairing.updateMetadata({ topic: a2, metadata: c4.metadata }), await this.sendResult({ id: s2, topic: a2, result: { relay: { protocol: t ?? "irn" }, responderPublicKey: h5 } }), await this.client.proposal.delete(s2, U("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a2 }));
      const T3 = g4({ relay: { protocol: t ?? "irn" }, namespaces: i3, requiredNamespaces: p5, optionalNamespaces: d3, pairingTopic: a2, controller: { publicKey: h5, metadata: this.client.metadata }, expiry: lt(A) }, n3 && { sessionProperties: n3 });
      await this.client.core.relayer.subscribe(w4), await this.sendRequest({ topic: w4, method: "wc_sessionSettle", params: T3, throwOnFailedPublish: true });
      const K3 = b3(g4({}, T3), { topic: w4, pairingTopic: a2, acknowledged: false, self: T3.controller, peer: { publicKey: c4.publicKey, metadata: c4.metadata }, controller: h5 });
      return await this.client.session.set(w4, K3), await this.setExpiry(w4, lt(A)), { topic: w4, acknowledged: () => new Promise((L3) => setTimeout(() => L3(this.client.session.get(w4)), 500)) };
    }, this.reject = async (e) => {
      await this.isInitialized(), await this.isValidReject(e);
      const { id: s2, reason: t } = e, { pairingTopic: i3 } = this.client.proposal.get(s2);
      i3 && (await this.sendError(s2, i3, t), await this.client.proposal.delete(s2, U("USER_DISCONNECTED")));
    }, this.update = async (e) => {
      await this.isInitialized(), await this.isValidUpdate(e);
      const { topic: s2, namespaces: t } = e, i3 = await this.sendRequest({ topic: s2, method: "wc_sessionUpdate", params: { namespaces: t } }), { done: n3, resolve: o, reject: a2 } = st();
      return this.events.once(ft("session_update", i3), ({ error: c4 }) => {
        c4 ? a2(c4) : o();
      }), await this.client.session.update(s2, { namespaces: t }), { acknowledged: n3 };
    }, this.extend = async (e) => {
      await this.isInitialized(), await this.isValidExtend(e);
      const { topic: s2 } = e, t = await this.sendRequest({ topic: s2, method: "wc_sessionExtend", params: {} }), { done: i3, resolve: n3, reject: o } = st();
      return this.events.once(ft("session_extend", t), ({ error: a2 }) => {
        a2 ? o(a2) : n3();
      }), await this.setExpiry(s2, lt(A)), { acknowledged: i3 };
    }, this.request = async (e) => {
      await this.isInitialized(), await this.isValidRequest(e);
      const { chainId: s2, request: t, topic: i3, expiry: n3 } = e, o = payloadId(), { done: a2, resolve: c4, reject: p5 } = st(n3, "Request expired. Please try again.");
      return this.events.once(ft("session_request", o), ({ error: d3, result: h5 }) => {
        d3 ? p5(d3) : c4(h5);
      }), await Promise.all([new Promise(async (d3) => {
        await this.sendRequest({ clientRpcId: o, topic: i3, method: "wc_sessionRequest", params: { request: t, chainId: s2 }, expiry: n3, throwOnFailedPublish: true }).catch((h5) => p5(h5)), this.client.events.emit("session_request_sent", { topic: i3, request: t, chainId: s2, id: o }), d3();
      }), new Promise(async (d3) => {
        const h5 = await this.client.core.storage.getItem(W2);
        pt({ id: o, topic: i3, wcDeepLink: h5 }), d3();
      }), a2()]).then((d3) => d3[2]);
    }, this.respond = async (e) => {
      await this.isInitialized(), await this.isValidRespond(e);
      const { topic: s2, response: t } = e, { id: i3 } = t;
      isJsonRpcResult(t) ? await this.sendResult({ id: i3, topic: s2, result: t.result, throwOnFailedPublish: true }) : isJsonRpcError(t) && await this.sendError(i3, s2, t.error), this.cleanupAfterResponse(e);
    }, this.ping = async (e) => {
      await this.isInitialized(), await this.isValidPing(e);
      const { topic: s2 } = e;
      if (this.client.session.keys.includes(s2)) {
        const t = await this.sendRequest({ topic: s2, method: "wc_sessionPing", params: {} }), { done: i3, resolve: n3, reject: o } = st();
        this.events.once(ft("session_ping", t), ({ error: a2 }) => {
          a2 ? o(a2) : n3();
        }), await i3();
      } else
        this.client.core.pairing.pairings.keys.includes(s2) && await this.client.core.pairing.ping({ topic: s2 });
    }, this.emit = async (e) => {
      await this.isInitialized(), await this.isValidEmit(e);
      const { topic: s2, event: t, chainId: i3 } = e;
      await this.sendRequest({ topic: s2, method: "wc_sessionEvent", params: { event: t, chainId: i3 } });
    }, this.disconnect = async (e) => {
      await this.isInitialized(), await this.isValidDisconnect(e);
      const { topic: s2 } = e;
      this.client.session.keys.includes(s2) ? (await this.sendRequest({ topic: s2, method: "wc_sessionDelete", params: U("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession(s2)) : await this.client.core.pairing.disconnect({ topic: s2 });
    }, this.find = (e) => (this.isInitialized(), this.client.session.getAll().filter((s2) => $t(s2, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (e) => {
      if (e.pairingTopic)
        try {
          const s2 = this.client.core.pairing.pairings.get(e.pairingTopic), t = this.client.core.pairing.pairings.getAll().filter((i3) => {
            var n3, o;
            return ((n3 = i3.peerMetadata) == null ? void 0 : n3.url) && ((o = i3.peerMetadata) == null ? void 0 : o.url) === e.peer.metadata.url && i3.topic && i3.topic !== s2.topic;
          });
          if (t.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (s2) {
          this.client.logger.error(s2);
        }
    }, this.deleteSession = async (e, s2) => {
      const { self: t } = this.client.session.get(e);
      await this.client.core.relayer.unsubscribe(e), this.client.session.delete(e, U("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(t.publicKey) && await this.client.core.crypto.deleteKeyPair(t.publicKey), this.client.core.crypto.keychain.has(e) && await this.client.core.crypto.deleteSymKey(e), s2 || this.client.core.expirer.del(e), this.client.core.storage.removeItem(W2).catch((i3) => this.client.logger.warn(i3));
    }, this.deleteProposal = async (e, s2) => {
      await Promise.all([this.client.proposal.delete(e, U("USER_DISCONNECTED")), s2 ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.deletePendingSessionRequest = async (e, s2, t = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, s2), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e), t && (this.sessionRequestQueue.state = I.idle);
    }, this.setExpiry = async (e, s2) => {
      this.client.session.keys.includes(e) && await this.client.session.update(e, { expiry: s2 }), this.client.core.expirer.set(e, s2);
    }, this.setProposal = async (e, s2) => {
      await this.client.proposal.set(e, s2), this.client.core.expirer.set(e, s2.expiry);
    }, this.setPendingSessionRequest = async (e) => {
      const s2 = V2.wc_sessionRequest.req.ttl, { id: t, topic: i3, params: n3, verifyContext: o } = e;
      await this.client.pendingRequest.set(t, { id: t, topic: i3, params: n3, verifyContext: o }), s2 && this.client.core.expirer.set(t, lt(s2));
    }, this.sendRequest = async (e) => {
      const { topic: s2, method: t, params: i3, expiry: n3, relayRpcId: o, clientRpcId: a2, throwOnFailedPublish: c4 } = e, p5 = formatJsonRpcRequest(t, i3, a2);
      if (q() && pe2.includes(t)) {
        const R2 = Mn(JSON.stringify(p5));
        this.client.core.verify.register({ attestationId: R2 });
      }
      const d3 = await this.client.core.crypto.encode(s2, p5), h5 = V2[t].req;
      return n3 && (h5.ttl = n3), o && (h5.id = o), this.client.core.history.set(s2, p5), c4 ? (h5.internal = b3(g4({}, h5.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, d3, h5)) : this.client.core.relayer.publish(s2, d3, h5).catch((R2) => this.client.logger.error(R2)), p5.id;
    }, this.sendResult = async (e) => {
      const { id: s2, topic: t, result: i3, throwOnFailedPublish: n3 } = e, o = formatJsonRpcResult(s2, i3), a2 = await this.client.core.crypto.encode(t, o), c4 = await this.client.core.history.get(t, s2), p5 = V2[c4.request.method].res;
      n3 ? (p5.internal = b3(g4({}, p5.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, a2, p5)) : this.client.core.relayer.publish(t, a2, p5).catch((d3) => this.client.logger.error(d3)), await this.client.core.history.resolve(o);
    }, this.sendError = async (e, s2, t) => {
      const i3 = formatJsonRpcError(e, t), n3 = await this.client.core.crypto.encode(s2, i3), o = await this.client.core.history.get(s2, e), a2 = V2[o.request.method].res;
      this.client.core.relayer.publish(s2, n3, a2), await this.client.core.history.resolve(i3);
    }, this.cleanup = async () => {
      const e = [], s2 = [];
      this.client.session.getAll().forEach((t) => {
        dt(t.expiry) && e.push(t.topic);
      }), this.client.proposal.getAll().forEach((t) => {
        dt(t.expiry) && s2.push(t.id);
      }), await Promise.all([...e.map((t) => this.deleteSession(t)), ...s2.map((t) => this.deleteProposal(t))]);
    }, this.onRelayEventRequest = async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === I.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = I.active;
        const e = this.requestQueue.queue.shift();
        if (e)
          try {
            this.processRequest(e), await new Promise((s2) => setTimeout(s2, 300));
          } catch (s2) {
            this.client.logger.warn(s2);
          }
      }
      this.requestQueue.state = I.idle;
    }, this.processRequest = (e) => {
      const { topic: s2, payload: t } = e, i3 = t.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(s2, t);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(s2, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(s2, t);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(s2, t);
        case "wc_sessionPing":
          return this.onSessionPingRequest(s2, t);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(s2, t);
        case "wc_sessionRequest":
          return this.onSessionRequest(s2, t);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(s2, t);
        default:
          return this.client.logger.info(`Unsupported request method ${i3}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: s2, payload: t } = e, i3 = (await this.client.core.history.get(s2, t.id)).request.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(s2, t);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(s2, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(s2, t);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(s2, t);
        case "wc_sessionPing":
          return this.onSessionPingResponse(s2, t);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(s2, t);
        default:
          return this.client.logger.info(`Unsupported response method ${i3}`);
      }
    }, this.onRelayEventUnknownPayload = (e) => {
      const { topic: s2 } = e, { message: t } = N("MISSING_OR_INVALID", `Decoded payload on topic ${s2} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(t);
    }, this.onSessionProposeRequest = async (e, s2) => {
      const { params: t, id: i3 } = s2;
      try {
        this.isValidConnect(g4({}, s2.params));
        const n3 = lt(import_time3.FIVE_MINUTES), o = g4({ id: i3, pairingTopic: e, expiry: n3 }, t);
        await this.setProposal(i3, o);
        const a2 = Mn(JSON.stringify(s2)), c4 = await this.getVerifyContext(a2, o.proposer.metadata);
        this.client.events.emit("session_proposal", { id: i3, params: o, verifyContext: c4 });
      } catch (n3) {
        await this.sendError(i3, e, n3), this.client.logger.error(n3);
      }
    }, this.onSessionProposeResponse = async (e, s2) => {
      const { id: t } = s2;
      if (isJsonRpcResult(s2)) {
        const { result: i3 } = s2;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i3 });
        const n3 = this.client.proposal.get(t);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n3 });
        const o = n3.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o });
        const a2 = i3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a2 });
        const c4 = await this.client.core.crypto.generateSharedKey(o, a2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: c4 });
        const p5 = await this.client.core.relayer.subscribe(c4);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p5 }), await this.client.core.pairing.activate({ topic: e });
      } else
        isJsonRpcError(s2) && (await this.client.proposal.delete(t, U("USER_DISCONNECTED")), this.events.emit(ft("session_connect"), { error: s2.error }));
    }, this.onSessionSettleRequest = async (e, s2) => {
      const { id: t, params: i3 } = s2;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: n3, controller: o, expiry: a2, namespaces: c4, requiredNamespaces: p5, optionalNamespaces: d3, sessionProperties: h5, pairingTopic: R2 } = s2.params, w4 = g4({ topic: e, relay: n3, expiry: a2, namespaces: c4, acknowledged: true, pairingTopic: R2, requiredNamespaces: p5, optionalNamespaces: d3, controller: o.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o.publicKey, metadata: o.metadata } }, h5 && { sessionProperties: h5 });
        await this.sendResult({ id: s2.id, topic: e, result: true }), this.events.emit(ft("session_connect"), { session: w4 }), this.cleanupDuplicatePairings(w4);
      } catch (n3) {
        await this.sendError(t, e, n3), this.client.logger.error(n3);
      }
    }, this.onSessionSettleResponse = async (e, s2) => {
      const { id: t } = s2;
      isJsonRpcResult(s2) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(ft("session_approve", t), {})) : isJsonRpcError(s2) && (await this.client.session.delete(e, U("USER_DISCONNECTED")), this.events.emit(ft("session_approve", t), { error: s2.error }));
    }, this.onSessionUpdateRequest = async (e, s2) => {
      const { params: t, id: i3 } = s2;
      try {
        const n3 = `${e}_session_update`, o = er.get(n3);
        if (o && this.isRequestOutOfSync(o, i3)) {
          this.client.logger.info(`Discarding out of sync request - ${i3}`);
          return;
        }
        this.isValidUpdate(g4({ topic: e }, t)), await this.client.session.update(e, { namespaces: t.namespaces }), await this.sendResult({ id: i3, topic: e, result: true }), this.client.events.emit("session_update", { id: i3, topic: e, params: t }), er.set(n3, i3);
      } catch (n3) {
        await this.sendError(i3, e, n3), this.client.logger.error(n3);
      }
    }, this.isRequestOutOfSync = (e, s2) => parseInt(s2.toString().slice(0, -3)) <= parseInt(e.toString().slice(0, -3)), this.onSessionUpdateResponse = (e, s2) => {
      const { id: t } = s2;
      isJsonRpcResult(s2) ? this.events.emit(ft("session_update", t), {}) : isJsonRpcError(s2) && this.events.emit(ft("session_update", t), { error: s2.error });
    }, this.onSessionExtendRequest = async (e, s2) => {
      const { id: t } = s2;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, lt(A)), await this.sendResult({ id: t, topic: e, result: true }), this.client.events.emit("session_extend", { id: t, topic: e });
      } catch (i3) {
        await this.sendError(t, e, i3), this.client.logger.error(i3);
      }
    }, this.onSessionExtendResponse = (e, s2) => {
      const { id: t } = s2;
      isJsonRpcResult(s2) ? this.events.emit(ft("session_extend", t), {}) : isJsonRpcError(s2) && this.events.emit(ft("session_extend", t), { error: s2.error });
    }, this.onSessionPingRequest = async (e, s2) => {
      const { id: t } = s2;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: t, topic: e, result: true }), this.client.events.emit("session_ping", { id: t, topic: e });
      } catch (i3) {
        await this.sendError(t, e, i3), this.client.logger.error(i3);
      }
    }, this.onSessionPingResponse = (e, s2) => {
      const { id: t } = s2;
      setTimeout(() => {
        isJsonRpcResult(s2) ? this.events.emit(ft("session_ping", t), {}) : isJsonRpcError(s2) && this.events.emit(ft("session_ping", t), { error: s2.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e, s2) => {
      const { id: t } = s2;
      try {
        this.isValidDisconnect({ topic: e, reason: s2.params }), await Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(D3.publish, async () => {
            i3(await this.deleteSession(e));
          });
        }), this.sendResult({ id: t, topic: e, result: true })]), this.client.events.emit("session_delete", { id: t, topic: e });
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }, this.onSessionRequest = async (e, s2) => {
      const { id: t, params: i3 } = s2;
      try {
        this.isValidRequest(g4({ topic: e }, i3));
        const n3 = Mn(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", i3, t))), o = this.client.session.get(e), a2 = await this.getVerifyContext(n3, o.peer.metadata), c4 = { id: t, topic: e, params: i3, verifyContext: a2 };
        await this.setPendingSessionRequest(c4), this.addSessionRequestToSessionRequestQueue(c4), this.processSessionRequestQueue();
      } catch (n3) {
        await this.sendError(t, e, n3), this.client.logger.error(n3);
      }
    }, this.onSessionRequestResponse = (e, s2) => {
      const { id: t } = s2;
      isJsonRpcResult(s2) ? this.events.emit(ft("session_request", t), { result: s2.result }) : isJsonRpcError(s2) && this.events.emit(ft("session_request", t), { error: s2.error });
    }, this.onSessionEventRequest = async (e, s2) => {
      const { id: t, params: i3 } = s2;
      try {
        const n3 = `${e}_session_event_${i3.event.name}`, o = er.get(n3);
        if (o && this.isRequestOutOfSync(o, t)) {
          this.client.logger.info(`Discarding out of sync request - ${t}`);
          return;
        }
        this.isValidEmit(g4({ topic: e }, i3)), this.client.events.emit("session_event", { id: t, topic: e, params: i3 }), er.set(n3, t);
      } catch (n3) {
        await this.sendError(t, e, n3), this.client.logger.error(n3);
      }
    }, this.addSessionRequestToSessionRequestQueue = (e) => {
      this.sessionRequestQueue.queue.push(e);
    }, this.cleanupAfterResponse = (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = I.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === I.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = I.active, this.client.events.emit("session_request", e);
      } catch (s2) {
        this.client.logger.error(s2);
      }
    }, this.onPairingCreated = (e) => {
      if (e.active)
        return;
      const s2 = this.client.proposal.getAll().find((t) => t.pairingTopic === e.topic);
      s2 && this.onSessionProposeRequest(e.topic, formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: s2.requiredNamespaces, optionalNamespaces: s2.optionalNamespaces, relays: s2.relays, proposer: s2.proposer }, s2.id));
    }, this.isValidConnect = async (e) => {
      if (!xt(e)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(a2);
      }
      const { pairingTopic: s2, requiredNamespaces: t, optionalNamespaces: i3, sessionProperties: n3, relays: o } = e;
      if (w(s2) || await this.isValidPairingTopic(s2), !Kt(o, true)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `connect() relays: ${o}`);
        throw new Error(a2);
      }
      !w(t) && B(t) !== 0 && this.validateNamespaces(t, "requiredNamespaces"), !w(i3) && B(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), w(n3) || this.validateSessionProps(n3, "sessionProperties");
    }, this.validateNamespaces = (e, s2) => {
      const t = Mt(e, "connect()", s2);
      if (t)
        throw new Error(t.message);
    }, this.isValidApprove = async (e) => {
      if (!xt(e))
        throw new Error(N("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: s2, namespaces: t, relayProtocol: i3, sessionProperties: n3 } = e;
      await this.isValidProposalId(s2);
      const o = this.client.proposal.get(s2), a2 = cn(t, "approve()");
      if (a2)
        throw new Error(a2.message);
      const c4 = un(o.requiredNamespaces, t, "approve()");
      if (c4)
        throw new Error(c4.message);
      if (!h(i3, true)) {
        const { message: p5 } = N("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(p5);
      }
      w(n3) || this.validateSessionProps(n3, "sessionProperties");
    }, this.isValidReject = async (e) => {
      if (!xt(e)) {
        const { message: i3 } = N("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i3);
      }
      const { id: s2, reason: t } = e;
      if (await this.isValidProposalId(s2), !Ft(t)) {
        const { message: i3 } = N("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t)}`);
        throw new Error(i3);
      }
    }, this.isValidSessionSettleRequest = (e) => {
      if (!xt(e)) {
        const { message: c4 } = N("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(c4);
      }
      const { relay: s2, controller: t, namespaces: i3, expiry: n3 } = e;
      if (!an(s2)) {
        const { message: c4 } = N("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c4);
      }
      const o = Vt(t, "onSessionSettleRequest()");
      if (o)
        throw new Error(o.message);
      const a2 = cn(i3, "onSessionSettleRequest()");
      if (a2)
        throw new Error(a2.message);
      if (dt(n3)) {
        const { message: c4 } = N("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c4);
      }
    }, this.isValidUpdate = async (e) => {
      if (!xt(e)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: s2, namespaces: t } = e;
      await this.isValidSessionTopic(s2);
      const i3 = this.client.session.get(s2), n3 = cn(t, "update()");
      if (n3)
        throw new Error(n3.message);
      const o = un(i3.requiredNamespaces, t, "update()");
      if (o)
        throw new Error(o.message);
    }, this.isValidExtend = async (e) => {
      if (!xt(e)) {
        const { message: t } = N("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s2 } = e;
      await this.isValidSessionTopic(s2);
    }, this.isValidRequest = async (e) => {
      if (!xt(e)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: s2, request: t, chainId: i3, expiry: n3 } = e;
      await this.isValidSessionTopic(s2);
      const { namespaces: o } = this.client.session.get(s2);
      if (!Gt(o, i3)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a2);
      }
      if (!Ht(t)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `request() ${JSON.stringify(t)}`);
        throw new Error(a2);
      }
      if (!Wt(o, i3, t.method)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `request() method: ${t.method}`);
        throw new Error(a2);
      }
      if (n3 && !Qt(n3, U4)) {
        const { message: a2 } = N("MISSING_OR_INVALID", `request() expiry: ${n3}. Expiry must be a number (in seconds) between ${U4.min} and ${U4.max}`);
        throw new Error(a2);
      }
    }, this.isValidRespond = async (e) => {
      if (!xt(e)) {
        const { message: i3 } = N("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(i3);
      }
      const { topic: s2, response: t } = e;
      if (await this.isValidSessionTopic(s2), !qt(t)) {
        const { message: i3 } = N("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(t)}`);
        throw new Error(i3);
      }
    }, this.isValidPing = async (e) => {
      if (!xt(e)) {
        const { message: t } = N("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s2 } = e;
      await this.isValidSessionOrPairingTopic(s2);
    }, this.isValidEmit = async (e) => {
      if (!xt(e)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(o);
      }
      const { topic: s2, event: t, chainId: i3 } = e;
      await this.isValidSessionTopic(s2);
      const { namespaces: n3 } = this.client.session.get(s2);
      if (!Gt(n3, i3)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(o);
      }
      if (!Bt(t)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o);
      }
      if (!zt(n3, i3, t.name)) {
        const { message: o } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o);
      }
    }, this.isValidDisconnect = async (e) => {
      if (!xt(e)) {
        const { message: t } = N("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(t);
      }
      const { topic: s2 } = e;
      await this.isValidSessionOrPairingTopic(s2);
    }, this.getVerifyContext = async (e, s2) => {
      const t = { verified: { verifyUrl: s2.verifyUrl || Z, validation: "UNKNOWN", origin: s2.url || "" } };
      try {
        const i3 = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: s2.verifyUrl });
        i3 && (t.verified.origin = i3.origin, t.verified.isScam = i3.isScam, t.verified.validation = i3.origin === new URL(s2.url).origin ? "VALID" : "INVALID");
      } catch (i3) {
        this.client.logger.info(i3);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;
    }, this.validateSessionProps = (e, s2) => {
      Object.values(e).forEach((t) => {
        if (!h(t, false)) {
          const { message: i3 } = N("MISSING_OR_INVALID", `${s2} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);
          throw new Error(i3);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: r } = N("NOT_INITIALIZED", this.name);
      throw new Error(r);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D3.message, async (r) => {
      const { topic: e, message: s2 } = r;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s2)))
        return;
      const t = await this.client.core.crypto.decode(e, s2);
      try {
        isJsonRpcRequest(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({ topic: e, payload: t })) : isJsonRpcResponse(t) ? (await this.client.core.history.resolve(t), await this.onRelayEventResponse({ topic: e, payload: t }), this.client.core.history.delete(e, t.id)) : this.onRelayEventUnknownPayload({ topic: e, payload: t });
      } catch (i3) {
        this.client.logger.error(i3);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(v2.expired, async (r) => {
      const { topic: e, id: s2 } = ut(r.target);
      if (s2 && this.client.pendingRequest.keys.includes(s2))
        return await this.deletePendingSessionRequest(s2, N("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, true), this.client.events.emit("session_expire", { topic: e })) : s2 && (await this.deleteProposal(s2, true), this.client.events.emit("proposal_expire", { id: s2 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(B2.create, (r) => this.onPairingCreated(r));
  }
  isValidPairingTopic(r) {
    if (!h(r, false)) {
      const { message: e } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${r}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(r)) {
      const { message: e } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (dt(this.client.core.pairing.pairings.get(r).expiry)) {
      const { message: e } = N("EXPIRED", `pairing topic: ${r}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(r) {
    if (!h(r, false)) {
      const { message: e } = N("MISSING_OR_INVALID", `session topic should be a string: ${r}`);
      throw new Error(e);
    }
    if (!this.client.session.keys.includes(r)) {
      const { message: e } = N("NO_MATCHING_KEY", `session topic doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (dt(this.client.session.get(r).expiry)) {
      await this.deleteSession(r);
      const { message: e } = N("EXPIRED", `session topic: ${r}`);
      throw new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(r) {
    if (this.client.session.keys.includes(r))
      await this.isValidSessionTopic(r);
    else if (this.client.core.pairing.pairings.keys.includes(r))
      this.isValidPairingTopic(r);
    else if (h(r, false)) {
      const { message: e } = N("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r}`);
      throw new Error(e);
    } else {
      const { message: e } = N("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(r) {
    if (!Lt(r)) {
      const { message: e } = N("MISSING_OR_INVALID", `proposal id should be a number: ${r}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(r)) {
      const { message: e } = N("NO_MATCHING_KEY", `proposal id doesn't exist: ${r}`);
      throw new Error(e);
    }
    if (dt(this.client.proposal.get(r).expiry)) {
      await this.deleteProposal(r);
      const { message: e } = N("EXPIRED", `proposal id: ${r}`);
      throw new Error(e);
    }
  }
};
var hs2 = class extends Ft2 {
  constructor(r, e) {
    super(r, e, ne, G), this.core = r, this.logger = e;
  }
};
var ds2 = class extends Ft2 {
  constructor(r, e) {
    super(r, e, ae, G), this.core = r, this.logger = e;
  }
};
var us2 = class extends Ft2 {
  constructor(r, e) {
    super(r, e, le2, G, (s2) => s2.id), this.core = r, this.logger = e;
  }
};
var Q2 = class _Q extends b2 {
  constructor(r) {
    super(r), this.protocol = X2, this.version = F2, this.name = M.name, this.events = new import_events5.EventEmitter(), this.on = (s2, t) => this.events.on(s2, t), this.once = (s2, t) => this.events.once(s2, t), this.off = (s2, t) => this.events.off(s2, t), this.removeListener = (s2, t) => this.events.removeListener(s2, t), this.removeAllListeners = (s2) => this.events.removeAllListeners(s2), this.connect = async (s2) => {
      try {
        return await this.engine.connect(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.pair = async (s2) => {
      try {
        return await this.engine.pair(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.approve = async (s2) => {
      try {
        return await this.engine.approve(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.reject = async (s2) => {
      try {
        return await this.engine.reject(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.update = async (s2) => {
      try {
        return await this.engine.update(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.extend = async (s2) => {
      try {
        return await this.engine.extend(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.request = async (s2) => {
      try {
        return await this.engine.request(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respond = async (s2) => {
      try {
        return await this.engine.respond(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.ping = async (s2) => {
      try {
        return await this.engine.ping(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.emit = async (s2) => {
      try {
        return await this.engine.emit(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.disconnect = async (s2) => {
      try {
        return await this.engine.disconnect(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.find = (s2) => {
      try {
        return this.engine.find(s2);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.name = (r == null ? void 0 : r.name) || M.name, this.metadata = (r == null ? void 0 : r.metadata) || zn();
    const e = typeof (r == null ? void 0 : r.logger) < "u" && typeof (r == null ? void 0 : r.logger) != "string" ? r.logger : (0, import_pino2.default)(k2({ level: (r == null ? void 0 : r.logger) || M.logger }));
    this.core = (r == null ? void 0 : r.core) || new Ar(r), this.logger = E2(e, this.name), this.session = new ds2(this.core, this.logger), this.proposal = new hs2(this.core, this.logger), this.pendingRequest = new us2(this.core, this.logger), this.engine = new ps2(this);
  }
  static async init(r) {
    const e = new _Q(r);
    return await e.initialize(), e;
  }
  get context() {
    return y2(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (r) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r.message), r;
    }
  }
};

// node_modules/.pnpm/@walletconnect+universal-provider@2.10.2/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events6 = __toESM(require_events());
var Ia = "error";
var Ug = "wss://relay.walletconnect.com";
var Wg = "wc";
var Fg = "universal_provider";
var xa = `${Wg}@2:${Fg}:`;
var Mg = "https://rpc.walletconnect.com/v1/";
var Vn2 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var ge2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var Ui = { exports: {} };
(function(C, u3) {
  (function() {
    var i3, d3 = "4.17.21", w4 = 200, T3 = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", $3 = "Expected a function", En = "Invalid `variable` option passed into `_.template`", zt3 = "__lodash_hash_undefined__", pr = 500, It2 = "__lodash_placeholder__", Ln2 = 1, Fn2 = 2, xt3 = 4, Et2 = 1, ve2 = 2, vn = 1, ct3 = 2, qi2 = 4, Dn2 = 8, yt3 = 16, Hn = 32, St2 = 64, Mn2 = 128, Kt3 = 256, dr = 512, La = 30, Da = "...", Ha = 800, Na = 16, Bi2 = 1, $a = 2, Ua = 3, ht2 = 1 / 0, kn2 = 9007199254740991, Wa = 17976931348623157e292, _e2 = 0 / 0, Nn = 4294967295, Fa = Nn - 1, Ma = Nn >>> 1, qa = [["ary", Mn2], ["bind", vn], ["bindKey", ct3], ["curry", Dn2], ["curryRight", yt3], ["flip", dr], ["partial", Hn], ["partialRight", St2], ["rearg", Kt3]], Ot2 = "[object Arguments]", me = "[object Array]", Ba = "[object AsyncFunction]", Yt = "[object Boolean]", Zt2 = "[object Date]", Ga = "[object DOMException]", we = "[object Error]", Pe = "[object Function]", Gi2 = "[object GeneratorFunction]", yn = "[object Map]", Jt = "[object Number]", za = "[object Null]", qn = "[object Object]", zi2 = "[object Promise]", Ka = "[object Proxy]", Xt2 = "[object RegExp]", Sn = "[object Set]", Qt2 = "[object String]", Ae = "[object Symbol]", Ya = "[object Undefined]", Vt3 = "[object WeakMap]", Za = "[object WeakSet]", kt3 = "[object ArrayBuffer]", Rt2 = "[object DataView]", gr = "[object Float32Array]", vr2 = "[object Float64Array]", _r2 = "[object Int8Array]", mr2 = "[object Int16Array]", wr2 = "[object Int32Array]", Pr2 = "[object Uint8Array]", Ar2 = "[object Uint8ClampedArray]", Cr2 = "[object Uint16Array]", Ir2 = "[object Uint32Array]", Ja = /\b__p \+= '';/g, Xa = /\b(__p \+=) '' \+/g, Qa = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Ki2 = /&(?:amp|lt|gt|quot|#39);/g, Yi2 = /[&<>"']/g, Va = RegExp(Ki2.source), ka = RegExp(Yi2.source), ja = /<%-([\s\S]+?)%>/g, no = /<%([\s\S]+?)%>/g, Zi2 = /<%=([\s\S]+?)%>/g, to = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, eo = /^\w*$/, ro = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, xr2 = /[\\^$.*+?()[\]{}|]/g, io = RegExp(xr2.source), Er2 = /^\s+/, so = /\s/, uo = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ao = /\{\n\/\* \[wrapped with (.+)\] \*/, oo = /,? & /, fo = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, co = /[()=,{}\[\]\/\s]/, ho = /\\(\\)?/g, lo = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ji2 = /\w*$/, po = /^[-+]0x[0-9a-f]+$/i, go = /^0b[01]+$/i, vo = /^\[object .+?Constructor\]$/, _o = /^0o[0-7]+$/i, mo = /^(?:0|[1-9]\d*)$/, wo = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ce2 = /($^)/, Po = /['\n\r\u2028\u2029\\]/g, Ie = "\\ud800-\\udfff", Ao = "\\u0300-\\u036f", Co = "\\ufe20-\\ufe2f", Io = "\\u20d0-\\u20ff", Xi2 = Ao + Co + Io, Qi2 = "\\u2700-\\u27bf", Vi2 = "a-z\\xdf-\\xf6\\xf8-\\xff", xo = "\\xac\\xb1\\xd7\\xf7", Eo = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", yo = "\\u2000-\\u206f", So = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ki2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", ji2 = "\\ufe0e\\ufe0f", ns3 = xo + Eo + yo + So, yr2 = "[']", Oo = "[" + Ie + "]", ts2 = "[" + ns3 + "]", xe = "[" + Xi2 + "]", es2 = "\\d+", Ro = "[" + Qi2 + "]", rs2 = "[" + Vi2 + "]", is2 = "[^" + Ie + ns3 + es2 + Qi2 + Vi2 + ki2 + "]", Sr2 = "\\ud83c[\\udffb-\\udfff]", bo = "(?:" + xe + "|" + Sr2 + ")", ss2 = "[^" + Ie + "]", Or2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", Rr2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", bt3 = "[" + ki2 + "]", us3 = "\\u200d", as3 = "(?:" + rs2 + "|" + is2 + ")", To = "(?:" + bt3 + "|" + is2 + ")", os3 = "(?:" + yr2 + "(?:d|ll|m|re|s|t|ve))?", fs2 = "(?:" + yr2 + "(?:D|LL|M|RE|S|T|VE))?", cs3 = bo + "?", hs3 = "[" + ji2 + "]?", Lo = "(?:" + us3 + "(?:" + [ss2, Or2, Rr2].join("|") + ")" + hs3 + cs3 + ")*", Do = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Ho = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ls3 = hs3 + cs3 + Lo, No = "(?:" + [Ro, Or2, Rr2].join("|") + ")" + ls3, $o = "(?:" + [ss2 + xe + "?", xe, Or2, Rr2, Oo].join("|") + ")", Uo = RegExp(yr2, "g"), Wo = RegExp(xe, "g"), br2 = RegExp(Sr2 + "(?=" + Sr2 + ")|" + $o + ls3, "g"), Fo = RegExp([bt3 + "?" + rs2 + "+" + os3 + "(?=" + [ts2, bt3, "$"].join("|") + ")", To + "+" + fs2 + "(?=" + [ts2, bt3 + as3, "$"].join("|") + ")", bt3 + "?" + as3 + "+" + os3, bt3 + "+" + fs2, Ho, Do, es2, No].join("|"), "g"), Mo = RegExp("[" + us3 + Ie + Xi2 + ji2 + "]"), qo = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Bo = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Go = -1, B3 = {};
    B3[gr] = B3[vr2] = B3[_r2] = B3[mr2] = B3[wr2] = B3[Pr2] = B3[Ar2] = B3[Cr2] = B3[Ir2] = true, B3[Ot2] = B3[me] = B3[kt3] = B3[Yt] = B3[Rt2] = B3[Zt2] = B3[we] = B3[Pe] = B3[yn] = B3[Jt] = B3[qn] = B3[Xt2] = B3[Sn] = B3[Qt2] = B3[Vt3] = false;
    var q3 = {};
    q3[Ot2] = q3[me] = q3[kt3] = q3[Rt2] = q3[Yt] = q3[Zt2] = q3[gr] = q3[vr2] = q3[_r2] = q3[mr2] = q3[wr2] = q3[yn] = q3[Jt] = q3[qn] = q3[Xt2] = q3[Sn] = q3[Qt2] = q3[Ae] = q3[Pr2] = q3[Ar2] = q3[Cr2] = q3[Ir2] = true, q3[we] = q3[Pe] = q3[Vt3] = false;
    var zo = { : "A", : "A", : "A", : "A", : "A", : "A", : "a", : "a", : "a", : "a", : "a", : "a", : "C", : "c", : "D", : "d", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "N", : "n", : "O", : "O", : "O", : "O", : "O", : "O", : "o", : "o", : "o", : "o", : "o", : "o", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "Y", : "y", : "y", : "Ae", : "ae", : "Th", : "th", : "ss", : "A", : "A", : "A", : "a", : "a", : "a", : "C", : "C", : "C", : "C", : "c", : "c", : "c", : "c", : "D", : "D", : "d", : "d", : "E", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "e", : "G", : "G", : "G", : "G", : "g", : "g", : "g", : "g", : "H", : "H", : "h", : "h", : "I", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "i", : "J", : "j", : "K", : "k", : "k", : "L", : "L", : "L", : "L", : "L", : "l", : "l", : "l", : "l", : "l", : "N", : "N", : "N", : "N", : "n", : "n", : "n", : "n", : "O", : "O", : "O", : "o", : "o", : "o", : "R", : "R", : "R", : "r", : "r", : "r", : "S", : "S", : "S", : "S", : "s", : "s", : "s", : "s", : "T", : "T", : "T", : "t", : "t", : "t", : "U", : "U", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "u", : "u", : "W", : "w", : "Y", : "y", : "Y", : "Z", : "Z", : "Z", : "z", : "z", : "z", : "IJ", : "ij", : "Oe", : "oe", : "'n", : "s" }, Ko = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Yo = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, Zo = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Jo = parseFloat, Xo = parseInt, ps3 = typeof ge2 == "object" && ge2 && ge2.Object === Object && ge2, Qo = typeof self == "object" && self && self.Object === Object && self, k3 = ps3 || Qo || Function("return this")(), Tr2 = u3 && !u3.nodeType && u3, lt3 = Tr2 && true && C && !C.nodeType && C, ds3 = lt3 && lt3.exports === Tr2, Lr = ds3 && ps3.process, _n = function() {
      try {
        var h5 = lt3 && lt3.require && lt3.require("util").types;
        return h5 || Lr && Lr.binding && Lr.binding("util");
      } catch {
      }
    }(), gs2 = _n && _n.isArrayBuffer, vs2 = _n && _n.isDate, _s2 = _n && _n.isMap, ms2 = _n && _n.isRegExp, ws2 = _n && _n.isSet, Ps2 = _n && _n.isTypedArray;
    function cn2(h5, g6, p5) {
      switch (p5.length) {
        case 0:
          return h5.call(g6);
        case 1:
          return h5.call(g6, p5[0]);
        case 2:
          return h5.call(g6, p5[0], p5[1]);
        case 3:
          return h5.call(g6, p5[0], p5[1], p5[2]);
      }
      return h5.apply(g6, p5);
    }
    function Vo(h5, g6, p5, A2) {
      for (var S5 = -1, U6 = h5 == null ? 0 : h5.length; ++S5 < U6; ) {
        var X3 = h5[S5];
        g6(A2, X3, p5(X3), h5);
      }
      return A2;
    }
    function mn(h5, g6) {
      for (var p5 = -1, A2 = h5 == null ? 0 : h5.length; ++p5 < A2 && g6(h5[p5], p5, h5) !== false; )
        ;
      return h5;
    }
    function ko(h5, g6) {
      for (var p5 = h5 == null ? 0 : h5.length; p5-- && g6(h5[p5], p5, h5) !== false; )
        ;
      return h5;
    }
    function As2(h5, g6) {
      for (var p5 = -1, A2 = h5 == null ? 0 : h5.length; ++p5 < A2; )
        if (!g6(h5[p5], p5, h5))
          return false;
      return true;
    }
    function jn2(h5, g6) {
      for (var p5 = -1, A2 = h5 == null ? 0 : h5.length, S5 = 0, U6 = []; ++p5 < A2; ) {
        var X3 = h5[p5];
        g6(X3, p5, h5) && (U6[S5++] = X3);
      }
      return U6;
    }
    function Ee(h5, g6) {
      var p5 = h5 == null ? 0 : h5.length;
      return !!p5 && Tt2(h5, g6, 0) > -1;
    }
    function Dr2(h5, g6, p5) {
      for (var A2 = -1, S5 = h5 == null ? 0 : h5.length; ++A2 < S5; )
        if (p5(g6, h5[A2]))
          return true;
      return false;
    }
    function G3(h5, g6) {
      for (var p5 = -1, A2 = h5 == null ? 0 : h5.length, S5 = Array(A2); ++p5 < A2; )
        S5[p5] = g6(h5[p5], p5, h5);
      return S5;
    }
    function nt3(h5, g6) {
      for (var p5 = -1, A2 = g6.length, S5 = h5.length; ++p5 < A2; )
        h5[S5 + p5] = g6[p5];
      return h5;
    }
    function Hr(h5, g6, p5, A2) {
      var S5 = -1, U6 = h5 == null ? 0 : h5.length;
      for (A2 && U6 && (p5 = h5[++S5]); ++S5 < U6; )
        p5 = g6(p5, h5[S5], S5, h5);
      return p5;
    }
    function jo(h5, g6, p5, A2) {
      var S5 = h5 == null ? 0 : h5.length;
      for (A2 && S5 && (p5 = h5[--S5]); S5--; )
        p5 = g6(p5, h5[S5], S5, h5);
      return p5;
    }
    function Nr(h5, g6) {
      for (var p5 = -1, A2 = h5 == null ? 0 : h5.length; ++p5 < A2; )
        if (g6(h5[p5], p5, h5))
          return true;
      return false;
    }
    var nf = $r("length");
    function tf(h5) {
      return h5.split("");
    }
    function ef(h5) {
      return h5.match(fo) || [];
    }
    function Cs2(h5, g6, p5) {
      var A2;
      return p5(h5, function(S5, U6, X3) {
        if (g6(S5, U6, X3))
          return A2 = U6, false;
      }), A2;
    }
    function ye(h5, g6, p5, A2) {
      for (var S5 = h5.length, U6 = p5 + (A2 ? 1 : -1); A2 ? U6-- : ++U6 < S5; )
        if (g6(h5[U6], U6, h5))
          return U6;
      return -1;
    }
    function Tt2(h5, g6, p5) {
      return g6 === g6 ? gf(h5, g6, p5) : ye(h5, Is2, p5);
    }
    function rf(h5, g6, p5, A2) {
      for (var S5 = p5 - 1, U6 = h5.length; ++S5 < U6; )
        if (A2(h5[S5], g6))
          return S5;
      return -1;
    }
    function Is2(h5) {
      return h5 !== h5;
    }
    function xs2(h5, g6) {
      var p5 = h5 == null ? 0 : h5.length;
      return p5 ? Wr(h5, g6) / p5 : _e2;
    }
    function $r(h5) {
      return function(g6) {
        return g6 == null ? i3 : g6[h5];
      };
    }
    function Ur(h5) {
      return function(g6) {
        return h5 == null ? i3 : h5[g6];
      };
    }
    function Es2(h5, g6, p5, A2, S5) {
      return S5(h5, function(U6, X3, M3) {
        p5 = A2 ? (A2 = false, U6) : g6(p5, U6, X3, M3);
      }), p5;
    }
    function sf(h5, g6) {
      var p5 = h5.length;
      for (h5.sort(g6); p5--; )
        h5[p5] = h5[p5].value;
      return h5;
    }
    function Wr(h5, g6) {
      for (var p5, A2 = -1, S5 = h5.length; ++A2 < S5; ) {
        var U6 = g6(h5[A2]);
        U6 !== i3 && (p5 = p5 === i3 ? U6 : p5 + U6);
      }
      return p5;
    }
    function Fr(h5, g6) {
      for (var p5 = -1, A2 = Array(h5); ++p5 < h5; )
        A2[p5] = g6(p5);
      return A2;
    }
    function uf(h5, g6) {
      return G3(g6, function(p5) {
        return [p5, h5[p5]];
      });
    }
    function ys2(h5) {
      return h5 && h5.slice(0, bs2(h5) + 1).replace(Er2, "");
    }
    function hn(h5) {
      return function(g6) {
        return h5(g6);
      };
    }
    function Mr(h5, g6) {
      return G3(g6, function(p5) {
        return h5[p5];
      });
    }
    function jt3(h5, g6) {
      return h5.has(g6);
    }
    function Ss2(h5, g6) {
      for (var p5 = -1, A2 = h5.length; ++p5 < A2 && Tt2(g6, h5[p5], 0) > -1; )
        ;
      return p5;
    }
    function Os2(h5, g6) {
      for (var p5 = h5.length; p5-- && Tt2(g6, h5[p5], 0) > -1; )
        ;
      return p5;
    }
    function af(h5, g6) {
      for (var p5 = h5.length, A2 = 0; p5--; )
        h5[p5] === g6 && ++A2;
      return A2;
    }
    var of = Ur(zo), ff = Ur(Ko);
    function cf(h5) {
      return "\\" + Zo[h5];
    }
    function hf(h5, g6) {
      return h5 == null ? i3 : h5[g6];
    }
    function Lt3(h5) {
      return Mo.test(h5);
    }
    function lf(h5) {
      return qo.test(h5);
    }
    function pf(h5) {
      for (var g6, p5 = []; !(g6 = h5.next()).done; )
        p5.push(g6.value);
      return p5;
    }
    function qr(h5) {
      var g6 = -1, p5 = Array(h5.size);
      return h5.forEach(function(A2, S5) {
        p5[++g6] = [S5, A2];
      }), p5;
    }
    function Rs2(h5, g6) {
      return function(p5) {
        return h5(g6(p5));
      };
    }
    function tt2(h5, g6) {
      for (var p5 = -1, A2 = h5.length, S5 = 0, U6 = []; ++p5 < A2; ) {
        var X3 = h5[p5];
        (X3 === g6 || X3 === It2) && (h5[p5] = It2, U6[S5++] = p5);
      }
      return U6;
    }
    function Se2(h5) {
      var g6 = -1, p5 = Array(h5.size);
      return h5.forEach(function(A2) {
        p5[++g6] = A2;
      }), p5;
    }
    function df(h5) {
      var g6 = -1, p5 = Array(h5.size);
      return h5.forEach(function(A2) {
        p5[++g6] = [A2, A2];
      }), p5;
    }
    function gf(h5, g6, p5) {
      for (var A2 = p5 - 1, S5 = h5.length; ++A2 < S5; )
        if (h5[A2] === g6)
          return A2;
      return -1;
    }
    function vf(h5, g6, p5) {
      for (var A2 = p5 + 1; A2--; )
        if (h5[A2] === g6)
          return A2;
      return A2;
    }
    function Dt3(h5) {
      return Lt3(h5) ? mf(h5) : nf(h5);
    }
    function On(h5) {
      return Lt3(h5) ? wf(h5) : tf(h5);
    }
    function bs2(h5) {
      for (var g6 = h5.length; g6-- && so.test(h5.charAt(g6)); )
        ;
      return g6;
    }
    var _f = Ur(Yo);
    function mf(h5) {
      for (var g6 = br2.lastIndex = 0; br2.test(h5); )
        ++g6;
      return g6;
    }
    function wf(h5) {
      return h5.match(br2) || [];
    }
    function Pf(h5) {
      return h5.match(Fo) || [];
    }
    var Af = function h5(g6) {
      g6 = g6 == null ? k3 : Ht2.defaults(k3.Object(), g6, Ht2.pick(k3, Bo));
      var p5 = g6.Array, A2 = g6.Date, S5 = g6.Error, U6 = g6.Function, X3 = g6.Math, M3 = g6.Object, Br = g6.RegExp, Cf = g6.String, wn = g6.TypeError, Oe = p5.prototype, If = U6.prototype, Nt3 = M3.prototype, Re3 = g6["__core-js_shared__"], be = If.toString, F3 = Nt3.hasOwnProperty, xf = 0, Ts2 = function() {
        var n3 = /[^.]+$/.exec(Re3 && Re3.keys && Re3.keys.IE_PROTO || "");
        return n3 ? "Symbol(src)_1." + n3 : "";
      }(), Te = Nt3.toString, Ef = be.call(M3), yf = k3._, Sf = Br("^" + be.call(F3).replace(xr2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Le2 = ds3 ? g6.Buffer : i3, et3 = g6.Symbol, De2 = g6.Uint8Array, Ls2 = Le2 ? Le2.allocUnsafe : i3, He2 = Rs2(M3.getPrototypeOf, M3), Ds2 = M3.create, Hs2 = Nt3.propertyIsEnumerable, Ne2 = Oe.splice, Ns2 = et3 ? et3.isConcatSpreadable : i3, ne2 = et3 ? et3.iterator : i3, pt3 = et3 ? et3.toStringTag : i3, $e2 = function() {
        try {
          var n3 = mt3(M3, "defineProperty");
          return n3({}, "", {}), n3;
        } catch {
        }
      }(), Of = g6.clearTimeout !== k3.clearTimeout && g6.clearTimeout, Rf = A2 && A2.now !== k3.Date.now && A2.now, bf = g6.setTimeout !== k3.setTimeout && g6.setTimeout, Ue2 = X3.ceil, We2 = X3.floor, Gr = M3.getOwnPropertySymbols, Tf = Le2 ? Le2.isBuffer : i3, $s2 = g6.isFinite, Lf = Oe.join, Df = Rs2(M3.keys, M3), Q4 = X3.max, nn = X3.min, Hf = A2.now, Nf = g6.parseInt, Us2 = X3.random, $f = Oe.reverse, zr = mt3(g6, "DataView"), te3 = mt3(g6, "Map"), Kr = mt3(g6, "Promise"), $t3 = mt3(g6, "Set"), ee3 = mt3(g6, "WeakMap"), re2 = mt3(M3, "create"), Fe2 = ee3 && new ee3(), Ut2 = {}, Uf = wt2(zr), Wf = wt2(te3), Ff = wt2(Kr), Mf = wt2($t3), qf = wt2(ee3), Me2 = et3 ? et3.prototype : i3, ie2 = Me2 ? Me2.valueOf : i3, Ws2 = Me2 ? Me2.toString : i3;
      function a2(n3) {
        if (Y(n3) && !O6(n3) && !(n3 instanceof H2)) {
          if (n3 instanceof Pn)
            return n3;
          if (F3.call(n3, "__wrapped__"))
            return Fu(n3);
        }
        return new Pn(n3);
      }
      var Wt2 = function() {
        function n3() {
        }
        return function(t) {
          if (!K3(t))
            return {};
          if (Ds2)
            return Ds2(t);
          n3.prototype = t;
          var e = new n3();
          return n3.prototype = i3, e;
        };
      }();
      function qe2() {
      }
      function Pn(n3, t) {
        this.__wrapped__ = n3, this.__actions__ = [], this.__chain__ = !!t, this.__index__ = 0, this.__values__ = i3;
      }
      a2.templateSettings = { escape: ja, evaluate: no, interpolate: Zi2, variable: "", imports: { _: a2 } }, a2.prototype = qe2.prototype, a2.prototype.constructor = a2, Pn.prototype = Wt2(qe2.prototype), Pn.prototype.constructor = Pn;
      function H2(n3) {
        this.__wrapped__ = n3, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = Nn, this.__views__ = [];
      }
      function Bf() {
        var n3 = new H2(this.__wrapped__);
        return n3.__actions__ = un2(this.__actions__), n3.__dir__ = this.__dir__, n3.__filtered__ = this.__filtered__, n3.__iteratees__ = un2(this.__iteratees__), n3.__takeCount__ = this.__takeCount__, n3.__views__ = un2(this.__views__), n3;
      }
      function Gf() {
        if (this.__filtered__) {
          var n3 = new H2(this);
          n3.__dir__ = -1, n3.__filtered__ = true;
        } else
          n3 = this.clone(), n3.__dir__ *= -1;
        return n3;
      }
      function zf() {
        var n3 = this.__wrapped__.value(), t = this.__dir__, e = O6(n3), r = t < 0, s2 = e ? n3.length : 0, o = eh(0, s2, this.__views__), f3 = o.start, c4 = o.end, l3 = c4 - f3, v4 = r ? c4 : f3 - 1, _5 = this.__iteratees__, m2 = _5.length, P2 = 0, I2 = nn(l3, this.__takeCount__);
        if (!e || !r && s2 == l3 && I2 == l3)
          return ou(n3, this.__actions__);
        var E5 = [];
        n:
          for (; l3-- && P2 < I2; ) {
            v4 += t;
            for (var b5 = -1, y6 = n3[v4]; ++b5 < m2; ) {
              var D5 = _5[b5], N5 = D5.iteratee, dn = D5.type, sn = N5(y6);
              if (dn == $a)
                y6 = sn;
              else if (!sn) {
                if (dn == Bi2)
                  continue n;
                break n;
              }
            }
            E5[P2++] = y6;
          }
        return E5;
      }
      H2.prototype = Wt2(qe2.prototype), H2.prototype.constructor = H2;
      function dt3(n3) {
        var t = -1, e = n3 == null ? 0 : n3.length;
        for (this.clear(); ++t < e; ) {
          var r = n3[t];
          this.set(r[0], r[1]);
        }
      }
      function Kf() {
        this.__data__ = re2 ? re2(null) : {}, this.size = 0;
      }
      function Yf(n3) {
        var t = this.has(n3) && delete this.__data__[n3];
        return this.size -= t ? 1 : 0, t;
      }
      function Zf(n3) {
        var t = this.__data__;
        if (re2) {
          var e = t[n3];
          return e === zt3 ? i3 : e;
        }
        return F3.call(t, n3) ? t[n3] : i3;
      }
      function Jf(n3) {
        var t = this.__data__;
        return re2 ? t[n3] !== i3 : F3.call(t, n3);
      }
      function Xf(n3, t) {
        var e = this.__data__;
        return this.size += this.has(n3) ? 0 : 1, e[n3] = re2 && t === i3 ? zt3 : t, this;
      }
      dt3.prototype.clear = Kf, dt3.prototype.delete = Yf, dt3.prototype.get = Zf, dt3.prototype.has = Jf, dt3.prototype.set = Xf;
      function Bn(n3) {
        var t = -1, e = n3 == null ? 0 : n3.length;
        for (this.clear(); ++t < e; ) {
          var r = n3[t];
          this.set(r[0], r[1]);
        }
      }
      function Qf() {
        this.__data__ = [], this.size = 0;
      }
      function Vf(n3) {
        var t = this.__data__, e = Be2(t, n3);
        if (e < 0)
          return false;
        var r = t.length - 1;
        return e == r ? t.pop() : Ne2.call(t, e, 1), --this.size, true;
      }
      function kf(n3) {
        var t = this.__data__, e = Be2(t, n3);
        return e < 0 ? i3 : t[e][1];
      }
      function jf(n3) {
        return Be2(this.__data__, n3) > -1;
      }
      function nc(n3, t) {
        var e = this.__data__, r = Be2(e, n3);
        return r < 0 ? (++this.size, e.push([n3, t])) : e[r][1] = t, this;
      }
      Bn.prototype.clear = Qf, Bn.prototype.delete = Vf, Bn.prototype.get = kf, Bn.prototype.has = jf, Bn.prototype.set = nc;
      function Gn(n3) {
        var t = -1, e = n3 == null ? 0 : n3.length;
        for (this.clear(); ++t < e; ) {
          var r = n3[t];
          this.set(r[0], r[1]);
        }
      }
      function tc() {
        this.size = 0, this.__data__ = { hash: new dt3(), map: new (te3 || Bn)(), string: new dt3() };
      }
      function ec(n3) {
        var t = nr2(this, n3).delete(n3);
        return this.size -= t ? 1 : 0, t;
      }
      function rc(n3) {
        return nr2(this, n3).get(n3);
      }
      function ic(n3) {
        return nr2(this, n3).has(n3);
      }
      function sc(n3, t) {
        var e = nr2(this, n3), r = e.size;
        return e.set(n3, t), this.size += e.size == r ? 0 : 1, this;
      }
      Gn.prototype.clear = tc, Gn.prototype.delete = ec, Gn.prototype.get = rc, Gn.prototype.has = ic, Gn.prototype.set = sc;
      function gt2(n3) {
        var t = -1, e = n3 == null ? 0 : n3.length;
        for (this.__data__ = new Gn(); ++t < e; )
          this.add(n3[t]);
      }
      function uc(n3) {
        return this.__data__.set(n3, zt3), this;
      }
      function ac(n3) {
        return this.__data__.has(n3);
      }
      gt2.prototype.add = gt2.prototype.push = uc, gt2.prototype.has = ac;
      function Rn2(n3) {
        var t = this.__data__ = new Bn(n3);
        this.size = t.size;
      }
      function oc() {
        this.__data__ = new Bn(), this.size = 0;
      }
      function fc(n3) {
        var t = this.__data__, e = t.delete(n3);
        return this.size = t.size, e;
      }
      function cc(n3) {
        return this.__data__.get(n3);
      }
      function hc(n3) {
        return this.__data__.has(n3);
      }
      function lc(n3, t) {
        var e = this.__data__;
        if (e instanceof Bn) {
          var r = e.__data__;
          if (!te3 || r.length < w4 - 1)
            return r.push([n3, t]), this.size = ++e.size, this;
          e = this.__data__ = new Gn(r);
        }
        return e.set(n3, t), this.size = e.size, this;
      }
      Rn2.prototype.clear = oc, Rn2.prototype.delete = fc, Rn2.prototype.get = cc, Rn2.prototype.has = hc, Rn2.prototype.set = lc;
      function Fs2(n3, t) {
        var e = O6(n3), r = !e && Pt2(n3), s2 = !e && !r && at3(n3), o = !e && !r && !s2 && Bt3(n3), f3 = e || r || s2 || o, c4 = f3 ? Fr(n3.length, Cf) : [], l3 = c4.length;
        for (var v4 in n3)
          (t || F3.call(n3, v4)) && !(f3 && (v4 == "length" || s2 && (v4 == "offset" || v4 == "parent") || o && (v4 == "buffer" || v4 == "byteLength" || v4 == "byteOffset") || Zn(v4, l3))) && c4.push(v4);
        return c4;
      }
      function Ms2(n3) {
        var t = n3.length;
        return t ? n3[ei(0, t - 1)] : i3;
      }
      function pc(n3, t) {
        return tr2(un2(n3), vt2(t, 0, n3.length));
      }
      function dc(n3) {
        return tr2(un2(n3));
      }
      function Yr(n3, t, e) {
        (e !== i3 && !bn(n3[t], e) || e === i3 && !(t in n3)) && zn2(n3, t, e);
      }
      function se(n3, t, e) {
        var r = n3[t];
        (!(F3.call(n3, t) && bn(r, e)) || e === i3 && !(t in n3)) && zn2(n3, t, e);
      }
      function Be2(n3, t) {
        for (var e = n3.length; e--; )
          if (bn(n3[e][0], t))
            return e;
        return -1;
      }
      function gc(n3, t, e, r) {
        return rt2(n3, function(s2, o, f3) {
          t(r, s2, e(s2), f3);
        }), r;
      }
      function qs2(n3, t) {
        return n3 && Un(t, V3(t), n3);
      }
      function vc(n3, t) {
        return n3 && Un(t, on(t), n3);
      }
      function zn2(n3, t, e) {
        t == "__proto__" && $e2 ? $e2(n3, t, { configurable: true, enumerable: true, value: e, writable: true }) : n3[t] = e;
      }
      function Zr(n3, t) {
        for (var e = -1, r = t.length, s2 = p5(r), o = n3 == null; ++e < r; )
          s2[e] = o ? i3 : Si(n3, t[e]);
        return s2;
      }
      function vt2(n3, t, e) {
        return n3 === n3 && (e !== i3 && (n3 = n3 <= e ? n3 : e), t !== i3 && (n3 = n3 >= t ? n3 : t)), n3;
      }
      function An(n3, t, e, r, s2, o) {
        var f3, c4 = t & Ln2, l3 = t & Fn2, v4 = t & xt3;
        if (e && (f3 = s2 ? e(n3, r, s2, o) : e(n3)), f3 !== i3)
          return f3;
        if (!K3(n3))
          return n3;
        var _5 = O6(n3);
        if (_5) {
          if (f3 = ih(n3), !c4)
            return un2(n3, f3);
        } else {
          var m2 = tn(n3), P2 = m2 == Pe || m2 == Gi2;
          if (at3(n3))
            return hu(n3, c4);
          if (m2 == qn || m2 == Ot2 || P2 && !s2) {
            if (f3 = l3 || P2 ? {} : bu(n3), !c4)
              return l3 ? Zc(n3, vc(f3, n3)) : Yc(n3, qs2(f3, n3));
          } else {
            if (!q3[m2])
              return s2 ? n3 : {};
            f3 = sh(n3, m2, c4);
          }
        }
        o || (o = new Rn2());
        var I2 = o.get(n3);
        if (I2)
          return I2;
        o.set(n3, f3), sa(n3) ? n3.forEach(function(y6) {
          f3.add(An(y6, t, e, y6, n3, o));
        }) : ra(n3) && n3.forEach(function(y6, D5) {
          f3.set(D5, An(y6, t, e, D5, n3, o));
        });
        var E5 = v4 ? l3 ? pi : li : l3 ? on : V3, b5 = _5 ? i3 : E5(n3);
        return mn(b5 || n3, function(y6, D5) {
          b5 && (D5 = y6, y6 = n3[D5]), se(f3, D5, An(y6, t, e, D5, n3, o));
        }), f3;
      }
      function _c(n3) {
        var t = V3(n3);
        return function(e) {
          return Bs2(e, n3, t);
        };
      }
      function Bs2(n3, t, e) {
        var r = e.length;
        if (n3 == null)
          return !r;
        for (n3 = M3(n3); r--; ) {
          var s2 = e[r], o = t[s2], f3 = n3[s2];
          if (f3 === i3 && !(s2 in n3) || !o(f3))
            return false;
        }
        return true;
      }
      function Gs2(n3, t, e) {
        if (typeof n3 != "function")
          throw new wn($3);
        return le3(function() {
          n3.apply(i3, e);
        }, t);
      }
      function ue2(n3, t, e, r) {
        var s2 = -1, o = Ee, f3 = true, c4 = n3.length, l3 = [], v4 = t.length;
        if (!c4)
          return l3;
        e && (t = G3(t, hn(e))), r ? (o = Dr2, f3 = false) : t.length >= w4 && (o = jt3, f3 = false, t = new gt2(t));
        n:
          for (; ++s2 < c4; ) {
            var _5 = n3[s2], m2 = e == null ? _5 : e(_5);
            if (_5 = r || _5 !== 0 ? _5 : 0, f3 && m2 === m2) {
              for (var P2 = v4; P2--; )
                if (t[P2] === m2)
                  continue n;
              l3.push(_5);
            } else
              o(t, m2, r) || l3.push(_5);
          }
        return l3;
      }
      var rt2 = vu($n), zs2 = vu(Xr, true);
      function mc(n3, t) {
        var e = true;
        return rt2(n3, function(r, s2, o) {
          return e = !!t(r, s2, o), e;
        }), e;
      }
      function Ge2(n3, t, e) {
        for (var r = -1, s2 = n3.length; ++r < s2; ) {
          var o = n3[r], f3 = t(o);
          if (f3 != null && (c4 === i3 ? f3 === f3 && !pn(f3) : e(f3, c4)))
            var c4 = f3, l3 = o;
        }
        return l3;
      }
      function wc(n3, t, e, r) {
        var s2 = n3.length;
        for (e = R2(e), e < 0 && (e = -e > s2 ? 0 : s2 + e), r = r === i3 || r > s2 ? s2 : R2(r), r < 0 && (r += s2), r = e > r ? 0 : aa(r); e < r; )
          n3[e++] = t;
        return n3;
      }
      function Ks2(n3, t) {
        var e = [];
        return rt2(n3, function(r, s2, o) {
          t(r, s2, o) && e.push(r);
        }), e;
      }
      function j5(n3, t, e, r, s2) {
        var o = -1, f3 = n3.length;
        for (e || (e = ah), s2 || (s2 = []); ++o < f3; ) {
          var c4 = n3[o];
          t > 0 && e(c4) ? t > 1 ? j5(c4, t - 1, e, r, s2) : nt3(s2, c4) : r || (s2[s2.length] = c4);
        }
        return s2;
      }
      var Jr = _u(), Ys2 = _u(true);
      function $n(n3, t) {
        return n3 && Jr(n3, t, V3);
      }
      function Xr(n3, t) {
        return n3 && Ys2(n3, t, V3);
      }
      function ze3(n3, t) {
        return jn2(t, function(e) {
          return Jn2(n3[e]);
        });
      }
      function _t2(n3, t) {
        t = st3(t, n3);
        for (var e = 0, r = t.length; n3 != null && e < r; )
          n3 = n3[Wn(t[e++])];
        return e && e == r ? n3 : i3;
      }
      function Zs2(n3, t, e) {
        var r = t(n3);
        return O6(n3) ? r : nt3(r, e(n3));
      }
      function en(n3) {
        return n3 == null ? n3 === i3 ? Ya : za : pt3 && pt3 in M3(n3) ? th(n3) : dh(n3);
      }
      function Qr(n3, t) {
        return n3 > t;
      }
      function Pc(n3, t) {
        return n3 != null && F3.call(n3, t);
      }
      function Ac(n3, t) {
        return n3 != null && t in M3(n3);
      }
      function Cc(n3, t, e) {
        return n3 >= nn(t, e) && n3 < Q4(t, e);
      }
      function Vr(n3, t, e) {
        for (var r = e ? Dr2 : Ee, s2 = n3[0].length, o = n3.length, f3 = o, c4 = p5(o), l3 = 1 / 0, v4 = []; f3--; ) {
          var _5 = n3[f3];
          f3 && t && (_5 = G3(_5, hn(t))), l3 = nn(_5.length, l3), c4[f3] = !e && (t || s2 >= 120 && _5.length >= 120) ? new gt2(f3 && _5) : i3;
        }
        _5 = n3[0];
        var m2 = -1, P2 = c4[0];
        n:
          for (; ++m2 < s2 && v4.length < l3; ) {
            var I2 = _5[m2], E5 = t ? t(I2) : I2;
            if (I2 = e || I2 !== 0 ? I2 : 0, !(P2 ? jt3(P2, E5) : r(v4, E5, e))) {
              for (f3 = o; --f3; ) {
                var b5 = c4[f3];
                if (!(b5 ? jt3(b5, E5) : r(n3[f3], E5, e)))
                  continue n;
              }
              P2 && P2.push(E5), v4.push(I2);
            }
          }
        return v4;
      }
      function Ic(n3, t, e, r) {
        return $n(n3, function(s2, o, f3) {
          t(r, e(s2), o, f3);
        }), r;
      }
      function ae2(n3, t, e) {
        t = st3(t, n3), n3 = Hu(n3, t);
        var r = n3 == null ? n3 : n3[Wn(In(t))];
        return r == null ? i3 : cn2(r, n3, e);
      }
      function Js2(n3) {
        return Y(n3) && en(n3) == Ot2;
      }
      function xc(n3) {
        return Y(n3) && en(n3) == kt3;
      }
      function Ec(n3) {
        return Y(n3) && en(n3) == Zt2;
      }
      function oe4(n3, t, e, r, s2) {
        return n3 === t ? true : n3 == null || t == null || !Y(n3) && !Y(t) ? n3 !== n3 && t !== t : yc(n3, t, e, r, oe4, s2);
      }
      function yc(n3, t, e, r, s2, o) {
        var f3 = O6(n3), c4 = O6(t), l3 = f3 ? me : tn(n3), v4 = c4 ? me : tn(t);
        l3 = l3 == Ot2 ? qn : l3, v4 = v4 == Ot2 ? qn : v4;
        var _5 = l3 == qn, m2 = v4 == qn, P2 = l3 == v4;
        if (P2 && at3(n3)) {
          if (!at3(t))
            return false;
          f3 = true, _5 = false;
        }
        if (P2 && !_5)
          return o || (o = new Rn2()), f3 || Bt3(n3) ? Su(n3, t, e, r, s2, o) : jc(n3, t, l3, e, r, s2, o);
        if (!(e & Et2)) {
          var I2 = _5 && F3.call(n3, "__wrapped__"), E5 = m2 && F3.call(t, "__wrapped__");
          if (I2 || E5) {
            var b5 = I2 ? n3.value() : n3, y6 = E5 ? t.value() : t;
            return o || (o = new Rn2()), s2(b5, y6, e, r, o);
          }
        }
        return P2 ? (o || (o = new Rn2()), nh(n3, t, e, r, s2, o)) : false;
      }
      function Sc(n3) {
        return Y(n3) && tn(n3) == yn;
      }
      function kr(n3, t, e, r) {
        var s2 = e.length, o = s2, f3 = !r;
        if (n3 == null)
          return !o;
        for (n3 = M3(n3); s2--; ) {
          var c4 = e[s2];
          if (f3 && c4[2] ? c4[1] !== n3[c4[0]] : !(c4[0] in n3))
            return false;
        }
        for (; ++s2 < o; ) {
          c4 = e[s2];
          var l3 = c4[0], v4 = n3[l3], _5 = c4[1];
          if (f3 && c4[2]) {
            if (v4 === i3 && !(l3 in n3))
              return false;
          } else {
            var m2 = new Rn2();
            if (r)
              var P2 = r(v4, _5, l3, n3, t, m2);
            if (!(P2 === i3 ? oe4(_5, v4, Et2 | ve2, r, m2) : P2))
              return false;
          }
        }
        return true;
      }
      function Xs2(n3) {
        if (!K3(n3) || fh(n3))
          return false;
        var t = Jn2(n3) ? Sf : vo;
        return t.test(wt2(n3));
      }
      function Oc(n3) {
        return Y(n3) && en(n3) == Xt2;
      }
      function Rc(n3) {
        return Y(n3) && tn(n3) == Sn;
      }
      function bc(n3) {
        return Y(n3) && ar2(n3.length) && !!B3[en(n3)];
      }
      function Qs2(n3) {
        return typeof n3 == "function" ? n3 : n3 == null ? fn : typeof n3 == "object" ? O6(n3) ? js2(n3[0], n3[1]) : ks2(n3) : ma(n3);
      }
      function jr(n3) {
        if (!he3(n3))
          return Df(n3);
        var t = [];
        for (var e in M3(n3))
          F3.call(n3, e) && e != "constructor" && t.push(e);
        return t;
      }
      function Tc(n3) {
        if (!K3(n3))
          return ph(n3);
        var t = he3(n3), e = [];
        for (var r in n3)
          r == "constructor" && (t || !F3.call(n3, r)) || e.push(r);
        return e;
      }
      function ni(n3, t) {
        return n3 < t;
      }
      function Vs2(n3, t) {
        var e = -1, r = an2(n3) ? p5(n3.length) : [];
        return rt2(n3, function(s2, o, f3) {
          r[++e] = t(s2, o, f3);
        }), r;
      }
      function ks2(n3) {
        var t = gi(n3);
        return t.length == 1 && t[0][2] ? Lu(t[0][0], t[0][1]) : function(e) {
          return e === n3 || kr(e, n3, t);
        };
      }
      function js2(n3, t) {
        return _i(n3) && Tu(t) ? Lu(Wn(n3), t) : function(e) {
          var r = Si(e, n3);
          return r === i3 && r === t ? Oi(e, n3) : oe4(t, r, Et2 | ve2);
        };
      }
      function Ke2(n3, t, e, r, s2) {
        n3 !== t && Jr(t, function(o, f3) {
          if (s2 || (s2 = new Rn2()), K3(o))
            Lc(n3, t, f3, e, Ke2, r, s2);
          else {
            var c4 = r ? r(wi(n3, f3), o, f3 + "", n3, t, s2) : i3;
            c4 === i3 && (c4 = o), Yr(n3, f3, c4);
          }
        }, on);
      }
      function Lc(n3, t, e, r, s2, o, f3) {
        var c4 = wi(n3, e), l3 = wi(t, e), v4 = f3.get(l3);
        if (v4) {
          Yr(n3, e, v4);
          return;
        }
        var _5 = o ? o(c4, l3, e + "", n3, t, f3) : i3, m2 = _5 === i3;
        if (m2) {
          var P2 = O6(l3), I2 = !P2 && at3(l3), E5 = !P2 && !I2 && Bt3(l3);
          _5 = l3, P2 || I2 || E5 ? O6(c4) ? _5 = c4 : Z2(c4) ? _5 = un2(c4) : I2 ? (m2 = false, _5 = hu(l3, true)) : E5 ? (m2 = false, _5 = lu(l3, true)) : _5 = [] : pe3(l3) || Pt2(l3) ? (_5 = c4, Pt2(c4) ? _5 = oa(c4) : (!K3(c4) || Jn2(c4)) && (_5 = bu(l3))) : m2 = false;
        }
        m2 && (f3.set(l3, _5), s2(_5, l3, r, o, f3), f3.delete(l3)), Yr(n3, e, _5);
      }
      function nu(n3, t) {
        var e = n3.length;
        if (e)
          return t += t < 0 ? e : 0, Zn(t, e) ? n3[t] : i3;
      }
      function tu(n3, t, e) {
        t.length ? t = G3(t, function(o) {
          return O6(o) ? function(f3) {
            return _t2(f3, o.length === 1 ? o[0] : o);
          } : o;
        }) : t = [fn];
        var r = -1;
        t = G3(t, hn(x3()));
        var s2 = Vs2(n3, function(o, f3, c4) {
          var l3 = G3(t, function(v4) {
            return v4(o);
          });
          return { criteria: l3, index: ++r, value: o };
        });
        return sf(s2, function(o, f3) {
          return Kc(o, f3, e);
        });
      }
      function Dc(n3, t) {
        return eu(n3, t, function(e, r) {
          return Oi(n3, r);
        });
      }
      function eu(n3, t, e) {
        for (var r = -1, s2 = t.length, o = {}; ++r < s2; ) {
          var f3 = t[r], c4 = _t2(n3, f3);
          e(c4, f3) && fe(o, st3(f3, n3), c4);
        }
        return o;
      }
      function Hc(n3) {
        return function(t) {
          return _t2(t, n3);
        };
      }
      function ti(n3, t, e, r) {
        var s2 = r ? rf : Tt2, o = -1, f3 = t.length, c4 = n3;
        for (n3 === t && (t = un2(t)), e && (c4 = G3(n3, hn(e))); ++o < f3; )
          for (var l3 = 0, v4 = t[o], _5 = e ? e(v4) : v4; (l3 = s2(c4, _5, l3, r)) > -1; )
            c4 !== n3 && Ne2.call(c4, l3, 1), Ne2.call(n3, l3, 1);
        return n3;
      }
      function ru(n3, t) {
        for (var e = n3 ? t.length : 0, r = e - 1; e--; ) {
          var s2 = t[e];
          if (e == r || s2 !== o) {
            var o = s2;
            Zn(s2) ? Ne2.call(n3, s2, 1) : si(n3, s2);
          }
        }
        return n3;
      }
      function ei(n3, t) {
        return n3 + We2(Us2() * (t - n3 + 1));
      }
      function Nc(n3, t, e, r) {
        for (var s2 = -1, o = Q4(Ue2((t - n3) / (e || 1)), 0), f3 = p5(o); o--; )
          f3[r ? o : ++s2] = n3, n3 += e;
        return f3;
      }
      function ri(n3, t) {
        var e = "";
        if (!n3 || t < 1 || t > kn2)
          return e;
        do
          t % 2 && (e += n3), t = We2(t / 2), t && (n3 += n3);
        while (t);
        return e;
      }
      function L3(n3, t) {
        return Pi(Du(n3, t, fn), n3 + "");
      }
      function $c(n3) {
        return Ms2(Gt3(n3));
      }
      function Uc(n3, t) {
        var e = Gt3(n3);
        return tr2(e, vt2(t, 0, e.length));
      }
      function fe(n3, t, e, r) {
        if (!K3(n3))
          return n3;
        t = st3(t, n3);
        for (var s2 = -1, o = t.length, f3 = o - 1, c4 = n3; c4 != null && ++s2 < o; ) {
          var l3 = Wn(t[s2]), v4 = e;
          if (l3 === "__proto__" || l3 === "constructor" || l3 === "prototype")
            return n3;
          if (s2 != f3) {
            var _5 = c4[l3];
            v4 = r ? r(_5, l3, c4) : i3, v4 === i3 && (v4 = K3(_5) ? _5 : Zn(t[s2 + 1]) ? [] : {});
          }
          se(c4, l3, v4), c4 = c4[l3];
        }
        return n3;
      }
      var iu = Fe2 ? function(n3, t) {
        return Fe2.set(n3, t), n3;
      } : fn, Wc = $e2 ? function(n3, t) {
        return $e2(n3, "toString", { configurable: true, enumerable: false, value: bi(t), writable: true });
      } : fn;
      function Fc(n3) {
        return tr2(Gt3(n3));
      }
      function Cn(n3, t, e) {
        var r = -1, s2 = n3.length;
        t < 0 && (t = -t > s2 ? 0 : s2 + t), e = e > s2 ? s2 : e, e < 0 && (e += s2), s2 = t > e ? 0 : e - t >>> 0, t >>>= 0;
        for (var o = p5(s2); ++r < s2; )
          o[r] = n3[r + t];
        return o;
      }
      function Mc(n3, t) {
        var e;
        return rt2(n3, function(r, s2, o) {
          return e = t(r, s2, o), !e;
        }), !!e;
      }
      function Ye3(n3, t, e) {
        var r = 0, s2 = n3 == null ? r : n3.length;
        if (typeof t == "number" && t === t && s2 <= Ma) {
          for (; r < s2; ) {
            var o = r + s2 >>> 1, f3 = n3[o];
            f3 !== null && !pn(f3) && (e ? f3 <= t : f3 < t) ? r = o + 1 : s2 = o;
          }
          return s2;
        }
        return ii(n3, t, fn, e);
      }
      function ii(n3, t, e, r) {
        var s2 = 0, o = n3 == null ? 0 : n3.length;
        if (o === 0)
          return 0;
        t = e(t);
        for (var f3 = t !== t, c4 = t === null, l3 = pn(t), v4 = t === i3; s2 < o; ) {
          var _5 = We2((s2 + o) / 2), m2 = e(n3[_5]), P2 = m2 !== i3, I2 = m2 === null, E5 = m2 === m2, b5 = pn(m2);
          if (f3)
            var y6 = r || E5;
          else
            v4 ? y6 = E5 && (r || P2) : c4 ? y6 = E5 && P2 && (r || !I2) : l3 ? y6 = E5 && P2 && !I2 && (r || !b5) : I2 || b5 ? y6 = false : y6 = r ? m2 <= t : m2 < t;
          y6 ? s2 = _5 + 1 : o = _5;
        }
        return nn(o, Fa);
      }
      function su(n3, t) {
        for (var e = -1, r = n3.length, s2 = 0, o = []; ++e < r; ) {
          var f3 = n3[e], c4 = t ? t(f3) : f3;
          if (!e || !bn(c4, l3)) {
            var l3 = c4;
            o[s2++] = f3 === 0 ? 0 : f3;
          }
        }
        return o;
      }
      function uu(n3) {
        return typeof n3 == "number" ? n3 : pn(n3) ? _e2 : +n3;
      }
      function ln(n3) {
        if (typeof n3 == "string")
          return n3;
        if (O6(n3))
          return G3(n3, ln) + "";
        if (pn(n3))
          return Ws2 ? Ws2.call(n3) : "";
        var t = n3 + "";
        return t == "0" && 1 / n3 == -ht2 ? "-0" : t;
      }
      function it3(n3, t, e) {
        var r = -1, s2 = Ee, o = n3.length, f3 = true, c4 = [], l3 = c4;
        if (e)
          f3 = false, s2 = Dr2;
        else if (o >= w4) {
          var v4 = t ? null : Vc(n3);
          if (v4)
            return Se2(v4);
          f3 = false, s2 = jt3, l3 = new gt2();
        } else
          l3 = t ? [] : c4;
        n:
          for (; ++r < o; ) {
            var _5 = n3[r], m2 = t ? t(_5) : _5;
            if (_5 = e || _5 !== 0 ? _5 : 0, f3 && m2 === m2) {
              for (var P2 = l3.length; P2--; )
                if (l3[P2] === m2)
                  continue n;
              t && l3.push(m2), c4.push(_5);
            } else
              s2(l3, m2, e) || (l3 !== c4 && l3.push(m2), c4.push(_5));
          }
        return c4;
      }
      function si(n3, t) {
        return t = st3(t, n3), n3 = Hu(n3, t), n3 == null || delete n3[Wn(In(t))];
      }
      function au(n3, t, e, r) {
        return fe(n3, t, e(_t2(n3, t)), r);
      }
      function Ze2(n3, t, e, r) {
        for (var s2 = n3.length, o = r ? s2 : -1; (r ? o-- : ++o < s2) && t(n3[o], o, n3); )
          ;
        return e ? Cn(n3, r ? 0 : o, r ? o + 1 : s2) : Cn(n3, r ? o + 1 : 0, r ? s2 : o);
      }
      function ou(n3, t) {
        var e = n3;
        return e instanceof H2 && (e = e.value()), Hr(t, function(r, s2) {
          return s2.func.apply(s2.thisArg, nt3([r], s2.args));
        }, e);
      }
      function ui(n3, t, e) {
        var r = n3.length;
        if (r < 2)
          return r ? it3(n3[0]) : [];
        for (var s2 = -1, o = p5(r); ++s2 < r; )
          for (var f3 = n3[s2], c4 = -1; ++c4 < r; )
            c4 != s2 && (o[s2] = ue2(o[s2] || f3, n3[c4], t, e));
        return it3(j5(o, 1), t, e);
      }
      function fu(n3, t, e) {
        for (var r = -1, s2 = n3.length, o = t.length, f3 = {}; ++r < s2; ) {
          var c4 = r < o ? t[r] : i3;
          e(f3, n3[r], c4);
        }
        return f3;
      }
      function ai(n3) {
        return Z2(n3) ? n3 : [];
      }
      function oi(n3) {
        return typeof n3 == "function" ? n3 : fn;
      }
      function st3(n3, t) {
        return O6(n3) ? n3 : _i(n3, t) ? [n3] : Wu(W3(n3));
      }
      var qc = L3;
      function ut3(n3, t, e) {
        var r = n3.length;
        return e = e === i3 ? r : e, !t && e >= r ? n3 : Cn(n3, t, e);
      }
      var cu = Of || function(n3) {
        return k3.clearTimeout(n3);
      };
      function hu(n3, t) {
        if (t)
          return n3.slice();
        var e = n3.length, r = Ls2 ? Ls2(e) : new n3.constructor(e);
        return n3.copy(r), r;
      }
      function fi(n3) {
        var t = new n3.constructor(n3.byteLength);
        return new De2(t).set(new De2(n3)), t;
      }
      function Bc(n3, t) {
        var e = t ? fi(n3.buffer) : n3.buffer;
        return new n3.constructor(e, n3.byteOffset, n3.byteLength);
      }
      function Gc(n3) {
        var t = new n3.constructor(n3.source, Ji2.exec(n3));
        return t.lastIndex = n3.lastIndex, t;
      }
      function zc(n3) {
        return ie2 ? M3(ie2.call(n3)) : {};
      }
      function lu(n3, t) {
        var e = t ? fi(n3.buffer) : n3.buffer;
        return new n3.constructor(e, n3.byteOffset, n3.length);
      }
      function pu(n3, t) {
        if (n3 !== t) {
          var e = n3 !== i3, r = n3 === null, s2 = n3 === n3, o = pn(n3), f3 = t !== i3, c4 = t === null, l3 = t === t, v4 = pn(t);
          if (!c4 && !v4 && !o && n3 > t || o && f3 && l3 && !c4 && !v4 || r && f3 && l3 || !e && l3 || !s2)
            return 1;
          if (!r && !o && !v4 && n3 < t || v4 && e && s2 && !r && !o || c4 && e && s2 || !f3 && s2 || !l3)
            return -1;
        }
        return 0;
      }
      function Kc(n3, t, e) {
        for (var r = -1, s2 = n3.criteria, o = t.criteria, f3 = s2.length, c4 = e.length; ++r < f3; ) {
          var l3 = pu(s2[r], o[r]);
          if (l3) {
            if (r >= c4)
              return l3;
            var v4 = e[r];
            return l3 * (v4 == "desc" ? -1 : 1);
          }
        }
        return n3.index - t.index;
      }
      function du(n3, t, e, r) {
        for (var s2 = -1, o = n3.length, f3 = e.length, c4 = -1, l3 = t.length, v4 = Q4(o - f3, 0), _5 = p5(l3 + v4), m2 = !r; ++c4 < l3; )
          _5[c4] = t[c4];
        for (; ++s2 < f3; )
          (m2 || s2 < o) && (_5[e[s2]] = n3[s2]);
        for (; v4--; )
          _5[c4++] = n3[s2++];
        return _5;
      }
      function gu(n3, t, e, r) {
        for (var s2 = -1, o = n3.length, f3 = -1, c4 = e.length, l3 = -1, v4 = t.length, _5 = Q4(o - c4, 0), m2 = p5(_5 + v4), P2 = !r; ++s2 < _5; )
          m2[s2] = n3[s2];
        for (var I2 = s2; ++l3 < v4; )
          m2[I2 + l3] = t[l3];
        for (; ++f3 < c4; )
          (P2 || s2 < o) && (m2[I2 + e[f3]] = n3[s2++]);
        return m2;
      }
      function un2(n3, t) {
        var e = -1, r = n3.length;
        for (t || (t = p5(r)); ++e < r; )
          t[e] = n3[e];
        return t;
      }
      function Un(n3, t, e, r) {
        var s2 = !e;
        e || (e = {});
        for (var o = -1, f3 = t.length; ++o < f3; ) {
          var c4 = t[o], l3 = r ? r(e[c4], n3[c4], c4, e, n3) : i3;
          l3 === i3 && (l3 = n3[c4]), s2 ? zn2(e, c4, l3) : se(e, c4, l3);
        }
        return e;
      }
      function Yc(n3, t) {
        return Un(n3, vi(n3), t);
      }
      function Zc(n3, t) {
        return Un(n3, Ou(n3), t);
      }
      function Je3(n3, t) {
        return function(e, r) {
          var s2 = O6(e) ? Vo : gc, o = t ? t() : {};
          return s2(e, n3, x3(r, 2), o);
        };
      }
      function Ft3(n3) {
        return L3(function(t, e) {
          var r = -1, s2 = e.length, o = s2 > 1 ? e[s2 - 1] : i3, f3 = s2 > 2 ? e[2] : i3;
          for (o = n3.length > 3 && typeof o == "function" ? (s2--, o) : i3, f3 && rn(e[0], e[1], f3) && (o = s2 < 3 ? i3 : o, s2 = 1), t = M3(t); ++r < s2; ) {
            var c4 = e[r];
            c4 && n3(t, c4, r, o);
          }
          return t;
        });
      }
      function vu(n3, t) {
        return function(e, r) {
          if (e == null)
            return e;
          if (!an2(e))
            return n3(e, r);
          for (var s2 = e.length, o = t ? s2 : -1, f3 = M3(e); (t ? o-- : ++o < s2) && r(f3[o], o, f3) !== false; )
            ;
          return e;
        };
      }
      function _u(n3) {
        return function(t, e, r) {
          for (var s2 = -1, o = M3(t), f3 = r(t), c4 = f3.length; c4--; ) {
            var l3 = f3[n3 ? c4 : ++s2];
            if (e(o[l3], l3, o) === false)
              break;
          }
          return t;
        };
      }
      function Jc(n3, t, e) {
        var r = t & vn, s2 = ce3(n3);
        function o() {
          var f3 = this && this !== k3 && this instanceof o ? s2 : n3;
          return f3.apply(r ? e : this, arguments);
        }
        return o;
      }
      function mu(n3) {
        return function(t) {
          t = W3(t);
          var e = Lt3(t) ? On(t) : i3, r = e ? e[0] : t.charAt(0), s2 = e ? ut3(e, 1).join("") : t.slice(1);
          return r[n3]() + s2;
        };
      }
      function Mt3(n3) {
        return function(t) {
          return Hr(va(ga(t).replace(Uo, "")), n3, "");
        };
      }
      function ce3(n3) {
        return function() {
          var t = arguments;
          switch (t.length) {
            case 0:
              return new n3();
            case 1:
              return new n3(t[0]);
            case 2:
              return new n3(t[0], t[1]);
            case 3:
              return new n3(t[0], t[1], t[2]);
            case 4:
              return new n3(t[0], t[1], t[2], t[3]);
            case 5:
              return new n3(t[0], t[1], t[2], t[3], t[4]);
            case 6:
              return new n3(t[0], t[1], t[2], t[3], t[4], t[5]);
            case 7:
              return new n3(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);
          }
          var e = Wt2(n3.prototype), r = n3.apply(e, t);
          return K3(r) ? r : e;
        };
      }
      function Xc(n3, t, e) {
        var r = ce3(n3);
        function s2() {
          for (var o = arguments.length, f3 = p5(o), c4 = o, l3 = qt3(s2); c4--; )
            f3[c4] = arguments[c4];
          var v4 = o < 3 && f3[0] !== l3 && f3[o - 1] !== l3 ? [] : tt2(f3, l3);
          if (o -= v4.length, o < e)
            return Iu(n3, t, Xe3, s2.placeholder, i3, f3, v4, i3, i3, e - o);
          var _5 = this && this !== k3 && this instanceof s2 ? r : n3;
          return cn2(_5, this, f3);
        }
        return s2;
      }
      function wu(n3) {
        return function(t, e, r) {
          var s2 = M3(t);
          if (!an2(t)) {
            var o = x3(e, 3);
            t = V3(t), e = function(c4) {
              return o(s2[c4], c4, s2);
            };
          }
          var f3 = n3(t, e, r);
          return f3 > -1 ? s2[o ? t[f3] : f3] : i3;
        };
      }
      function Pu(n3) {
        return Yn(function(t) {
          var e = t.length, r = e, s2 = Pn.prototype.thru;
          for (n3 && t.reverse(); r--; ) {
            var o = t[r];
            if (typeof o != "function")
              throw new wn($3);
            if (s2 && !f3 && je3(o) == "wrapper")
              var f3 = new Pn([], true);
          }
          for (r = f3 ? r : e; ++r < e; ) {
            o = t[r];
            var c4 = je3(o), l3 = c4 == "wrapper" ? di(o) : i3;
            l3 && mi(l3[0]) && l3[1] == (Mn2 | Dn2 | Hn | Kt3) && !l3[4].length && l3[9] == 1 ? f3 = f3[je3(l3[0])].apply(f3, l3[3]) : f3 = o.length == 1 && mi(o) ? f3[c4]() : f3.thru(o);
          }
          return function() {
            var v4 = arguments, _5 = v4[0];
            if (f3 && v4.length == 1 && O6(_5))
              return f3.plant(_5).value();
            for (var m2 = 0, P2 = e ? t[m2].apply(this, v4) : _5; ++m2 < e; )
              P2 = t[m2].call(this, P2);
            return P2;
          };
        });
      }
      function Xe3(n3, t, e, r, s2, o, f3, c4, l3, v4) {
        var _5 = t & Mn2, m2 = t & vn, P2 = t & ct3, I2 = t & (Dn2 | yt3), E5 = t & dr, b5 = P2 ? i3 : ce3(n3);
        function y6() {
          for (var D5 = arguments.length, N5 = p5(D5), dn = D5; dn--; )
            N5[dn] = arguments[dn];
          if (I2)
            var sn = qt3(y6), gn = af(N5, sn);
          if (r && (N5 = du(N5, r, s2, I2)), o && (N5 = gu(N5, o, f3, I2)), D5 -= gn, I2 && D5 < v4) {
            var J2 = tt2(N5, sn);
            return Iu(n3, t, Xe3, y6.placeholder, e, N5, J2, c4, l3, v4 - D5);
          }
          var Tn = m2 ? e : this, Qn = P2 ? Tn[n3] : n3;
          return D5 = N5.length, c4 ? N5 = gh(N5, c4) : E5 && D5 > 1 && N5.reverse(), _5 && l3 < D5 && (N5.length = l3), this && this !== k3 && this instanceof y6 && (Qn = b5 || ce3(Qn)), Qn.apply(Tn, N5);
        }
        return y6;
      }
      function Au(n3, t) {
        return function(e, r) {
          return Ic(e, n3, t(r), {});
        };
      }
      function Qe2(n3, t) {
        return function(e, r) {
          var s2;
          if (e === i3 && r === i3)
            return t;
          if (e !== i3 && (s2 = e), r !== i3) {
            if (s2 === i3)
              return r;
            typeof e == "string" || typeof r == "string" ? (e = ln(e), r = ln(r)) : (e = uu(e), r = uu(r)), s2 = n3(e, r);
          }
          return s2;
        };
      }
      function ci(n3) {
        return Yn(function(t) {
          return t = G3(t, hn(x3())), L3(function(e) {
            var r = this;
            return n3(t, function(s2) {
              return cn2(s2, r, e);
            });
          });
        });
      }
      function Ve2(n3, t) {
        t = t === i3 ? " " : ln(t);
        var e = t.length;
        if (e < 2)
          return e ? ri(t, n3) : t;
        var r = ri(t, Ue2(n3 / Dt3(t)));
        return Lt3(t) ? ut3(On(r), 0, n3).join("") : r.slice(0, n3);
      }
      function Qc(n3, t, e, r) {
        var s2 = t & vn, o = ce3(n3);
        function f3() {
          for (var c4 = -1, l3 = arguments.length, v4 = -1, _5 = r.length, m2 = p5(_5 + l3), P2 = this && this !== k3 && this instanceof f3 ? o : n3; ++v4 < _5; )
            m2[v4] = r[v4];
          for (; l3--; )
            m2[v4++] = arguments[++c4];
          return cn2(P2, s2 ? e : this, m2);
        }
        return f3;
      }
      function Cu(n3) {
        return function(t, e, r) {
          return r && typeof r != "number" && rn(t, e, r) && (e = r = i3), t = Xn(t), e === i3 ? (e = t, t = 0) : e = Xn(e), r = r === i3 ? t < e ? 1 : -1 : Xn(r), Nc(t, e, r, n3);
        };
      }
      function ke2(n3) {
        return function(t, e) {
          return typeof t == "string" && typeof e == "string" || (t = xn2(t), e = xn2(e)), n3(t, e);
        };
      }
      function Iu(n3, t, e, r, s2, o, f3, c4, l3, v4) {
        var _5 = t & Dn2, m2 = _5 ? f3 : i3, P2 = _5 ? i3 : f3, I2 = _5 ? o : i3, E5 = _5 ? i3 : o;
        t |= _5 ? Hn : St2, t &= ~(_5 ? St2 : Hn), t & qi2 || (t &= ~(vn | ct3));
        var b5 = [n3, t, s2, I2, m2, E5, P2, c4, l3, v4], y6 = e.apply(i3, b5);
        return mi(n3) && Nu(y6, b5), y6.placeholder = r, $u(y6, n3, t);
      }
      function hi(n3) {
        var t = X3[n3];
        return function(e, r) {
          if (e = xn2(e), r = r == null ? 0 : nn(R2(r), 292), r && $s2(e)) {
            var s2 = (W3(e) + "e").split("e"), o = t(s2[0] + "e" + (+s2[1] + r));
            return s2 = (W3(o) + "e").split("e"), +(s2[0] + "e" + (+s2[1] - r));
          }
          return t(e);
        };
      }
      var Vc = $t3 && 1 / Se2(new $t3([, -0]))[1] == ht2 ? function(n3) {
        return new $t3(n3);
      } : Di;
      function xu(n3) {
        return function(t) {
          var e = tn(t);
          return e == yn ? qr(t) : e == Sn ? df(t) : uf(t, n3(t));
        };
      }
      function Kn2(n3, t, e, r, s2, o, f3, c4) {
        var l3 = t & ct3;
        if (!l3 && typeof n3 != "function")
          throw new wn($3);
        var v4 = r ? r.length : 0;
        if (v4 || (t &= ~(Hn | St2), r = s2 = i3), f3 = f3 === i3 ? f3 : Q4(R2(f3), 0), c4 = c4 === i3 ? c4 : R2(c4), v4 -= s2 ? s2.length : 0, t & St2) {
          var _5 = r, m2 = s2;
          r = s2 = i3;
        }
        var P2 = l3 ? i3 : di(n3), I2 = [n3, t, e, r, s2, _5, m2, o, f3, c4];
        if (P2 && lh(I2, P2), n3 = I2[0], t = I2[1], e = I2[2], r = I2[3], s2 = I2[4], c4 = I2[9] = I2[9] === i3 ? l3 ? 0 : n3.length : Q4(I2[9] - v4, 0), !c4 && t & (Dn2 | yt3) && (t &= ~(Dn2 | yt3)), !t || t == vn)
          var E5 = Jc(n3, t, e);
        else
          t == Dn2 || t == yt3 ? E5 = Xc(n3, t, c4) : (t == Hn || t == (vn | Hn)) && !s2.length ? E5 = Qc(n3, t, e, r) : E5 = Xe3.apply(i3, I2);
        var b5 = P2 ? iu : Nu;
        return $u(b5(E5, I2), n3, t);
      }
      function Eu(n3, t, e, r) {
        return n3 === i3 || bn(n3, Nt3[e]) && !F3.call(r, e) ? t : n3;
      }
      function yu(n3, t, e, r, s2, o) {
        return K3(n3) && K3(t) && (o.set(t, n3), Ke2(n3, t, i3, yu, o), o.delete(t)), n3;
      }
      function kc(n3) {
        return pe3(n3) ? i3 : n3;
      }
      function Su(n3, t, e, r, s2, o) {
        var f3 = e & Et2, c4 = n3.length, l3 = t.length;
        if (c4 != l3 && !(f3 && l3 > c4))
          return false;
        var v4 = o.get(n3), _5 = o.get(t);
        if (v4 && _5)
          return v4 == t && _5 == n3;
        var m2 = -1, P2 = true, I2 = e & ve2 ? new gt2() : i3;
        for (o.set(n3, t), o.set(t, n3); ++m2 < c4; ) {
          var E5 = n3[m2], b5 = t[m2];
          if (r)
            var y6 = f3 ? r(b5, E5, m2, t, n3, o) : r(E5, b5, m2, n3, t, o);
          if (y6 !== i3) {
            if (y6)
              continue;
            P2 = false;
            break;
          }
          if (I2) {
            if (!Nr(t, function(D5, N5) {
              if (!jt3(I2, N5) && (E5 === D5 || s2(E5, D5, e, r, o)))
                return I2.push(N5);
            })) {
              P2 = false;
              break;
            }
          } else if (!(E5 === b5 || s2(E5, b5, e, r, o))) {
            P2 = false;
            break;
          }
        }
        return o.delete(n3), o.delete(t), P2;
      }
      function jc(n3, t, e, r, s2, o, f3) {
        switch (e) {
          case Rt2:
            if (n3.byteLength != t.byteLength || n3.byteOffset != t.byteOffset)
              return false;
            n3 = n3.buffer, t = t.buffer;
          case kt3:
            return !(n3.byteLength != t.byteLength || !o(new De2(n3), new De2(t)));
          case Yt:
          case Zt2:
          case Jt:
            return bn(+n3, +t);
          case we:
            return n3.name == t.name && n3.message == t.message;
          case Xt2:
          case Qt2:
            return n3 == t + "";
          case yn:
            var c4 = qr;
          case Sn:
            var l3 = r & Et2;
            if (c4 || (c4 = Se2), n3.size != t.size && !l3)
              return false;
            var v4 = f3.get(n3);
            if (v4)
              return v4 == t;
            r |= ve2, f3.set(n3, t);
            var _5 = Su(c4(n3), c4(t), r, s2, o, f3);
            return f3.delete(n3), _5;
          case Ae:
            if (ie2)
              return ie2.call(n3) == ie2.call(t);
        }
        return false;
      }
      function nh(n3, t, e, r, s2, o) {
        var f3 = e & Et2, c4 = li(n3), l3 = c4.length, v4 = li(t), _5 = v4.length;
        if (l3 != _5 && !f3)
          return false;
        for (var m2 = l3; m2--; ) {
          var P2 = c4[m2];
          if (!(f3 ? P2 in t : F3.call(t, P2)))
            return false;
        }
        var I2 = o.get(n3), E5 = o.get(t);
        if (I2 && E5)
          return I2 == t && E5 == n3;
        var b5 = true;
        o.set(n3, t), o.set(t, n3);
        for (var y6 = f3; ++m2 < l3; ) {
          P2 = c4[m2];
          var D5 = n3[P2], N5 = t[P2];
          if (r)
            var dn = f3 ? r(N5, D5, P2, t, n3, o) : r(D5, N5, P2, n3, t, o);
          if (!(dn === i3 ? D5 === N5 || s2(D5, N5, e, r, o) : dn)) {
            b5 = false;
            break;
          }
          y6 || (y6 = P2 == "constructor");
        }
        if (b5 && !y6) {
          var sn = n3.constructor, gn = t.constructor;
          sn != gn && "constructor" in n3 && "constructor" in t && !(typeof sn == "function" && sn instanceof sn && typeof gn == "function" && gn instanceof gn) && (b5 = false);
        }
        return o.delete(n3), o.delete(t), b5;
      }
      function Yn(n3) {
        return Pi(Du(n3, i3, Bu), n3 + "");
      }
      function li(n3) {
        return Zs2(n3, V3, vi);
      }
      function pi(n3) {
        return Zs2(n3, on, Ou);
      }
      var di = Fe2 ? function(n3) {
        return Fe2.get(n3);
      } : Di;
      function je3(n3) {
        for (var t = n3.name + "", e = Ut2[t], r = F3.call(Ut2, t) ? e.length : 0; r--; ) {
          var s2 = e[r], o = s2.func;
          if (o == null || o == n3)
            return s2.name;
        }
        return t;
      }
      function qt3(n3) {
        var t = F3.call(a2, "placeholder") ? a2 : n3;
        return t.placeholder;
      }
      function x3() {
        var n3 = a2.iteratee || Ti;
        return n3 = n3 === Ti ? Qs2 : n3, arguments.length ? n3(arguments[0], arguments[1]) : n3;
      }
      function nr2(n3, t) {
        var e = n3.__data__;
        return oh(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
      }
      function gi(n3) {
        for (var t = V3(n3), e = t.length; e--; ) {
          var r = t[e], s2 = n3[r];
          t[e] = [r, s2, Tu(s2)];
        }
        return t;
      }
      function mt3(n3, t) {
        var e = hf(n3, t);
        return Xs2(e) ? e : i3;
      }
      function th(n3) {
        var t = F3.call(n3, pt3), e = n3[pt3];
        try {
          n3[pt3] = i3;
          var r = true;
        } catch {
        }
        var s2 = Te.call(n3);
        return r && (t ? n3[pt3] = e : delete n3[pt3]), s2;
      }
      var vi = Gr ? function(n3) {
        return n3 == null ? [] : (n3 = M3(n3), jn2(Gr(n3), function(t) {
          return Hs2.call(n3, t);
        }));
      } : Hi2, Ou = Gr ? function(n3) {
        for (var t = []; n3; )
          nt3(t, vi(n3)), n3 = He2(n3);
        return t;
      } : Hi2, tn = en;
      (zr && tn(new zr(new ArrayBuffer(1))) != Rt2 || te3 && tn(new te3()) != yn || Kr && tn(Kr.resolve()) != zi2 || $t3 && tn(new $t3()) != Sn || ee3 && tn(new ee3()) != Vt3) && (tn = function(n3) {
        var t = en(n3), e = t == qn ? n3.constructor : i3, r = e ? wt2(e) : "";
        if (r)
          switch (r) {
            case Uf:
              return Rt2;
            case Wf:
              return yn;
            case Ff:
              return zi2;
            case Mf:
              return Sn;
            case qf:
              return Vt3;
          }
        return t;
      });
      function eh(n3, t, e) {
        for (var r = -1, s2 = e.length; ++r < s2; ) {
          var o = e[r], f3 = o.size;
          switch (o.type) {
            case "drop":
              n3 += f3;
              break;
            case "dropRight":
              t -= f3;
              break;
            case "take":
              t = nn(t, n3 + f3);
              break;
            case "takeRight":
              n3 = Q4(n3, t - f3);
              break;
          }
        }
        return { start: n3, end: t };
      }
      function rh(n3) {
        var t = n3.match(ao);
        return t ? t[1].split(oo) : [];
      }
      function Ru(n3, t, e) {
        t = st3(t, n3);
        for (var r = -1, s2 = t.length, o = false; ++r < s2; ) {
          var f3 = Wn(t[r]);
          if (!(o = n3 != null && e(n3, f3)))
            break;
          n3 = n3[f3];
        }
        return o || ++r != s2 ? o : (s2 = n3 == null ? 0 : n3.length, !!s2 && ar2(s2) && Zn(f3, s2) && (O6(n3) || Pt2(n3)));
      }
      function ih(n3) {
        var t = n3.length, e = new n3.constructor(t);
        return t && typeof n3[0] == "string" && F3.call(n3, "index") && (e.index = n3.index, e.input = n3.input), e;
      }
      function bu(n3) {
        return typeof n3.constructor == "function" && !he3(n3) ? Wt2(He2(n3)) : {};
      }
      function sh(n3, t, e) {
        var r = n3.constructor;
        switch (t) {
          case kt3:
            return fi(n3);
          case Yt:
          case Zt2:
            return new r(+n3);
          case Rt2:
            return Bc(n3, e);
          case gr:
          case vr2:
          case _r2:
          case mr2:
          case wr2:
          case Pr2:
          case Ar2:
          case Cr2:
          case Ir2:
            return lu(n3, e);
          case yn:
            return new r();
          case Jt:
          case Qt2:
            return new r(n3);
          case Xt2:
            return Gc(n3);
          case Sn:
            return new r();
          case Ae:
            return zc(n3);
        }
      }
      function uh(n3, t) {
        var e = t.length;
        if (!e)
          return n3;
        var r = e - 1;
        return t[r] = (e > 1 ? "& " : "") + t[r], t = t.join(e > 2 ? ", " : " "), n3.replace(uo, `{
/* [wrapped with ` + t + `] */
`);
      }
      function ah(n3) {
        return O6(n3) || Pt2(n3) || !!(Ns2 && n3 && n3[Ns2]);
      }
      function Zn(n3, t) {
        var e = typeof n3;
        return t = t ?? kn2, !!t && (e == "number" || e != "symbol" && mo.test(n3)) && n3 > -1 && n3 % 1 == 0 && n3 < t;
      }
      function rn(n3, t, e) {
        if (!K3(e))
          return false;
        var r = typeof t;
        return (r == "number" ? an2(e) && Zn(t, e.length) : r == "string" && t in e) ? bn(e[t], n3) : false;
      }
      function _i(n3, t) {
        if (O6(n3))
          return false;
        var e = typeof n3;
        return e == "number" || e == "symbol" || e == "boolean" || n3 == null || pn(n3) ? true : eo.test(n3) || !to.test(n3) || t != null && n3 in M3(t);
      }
      function oh(n3) {
        var t = typeof n3;
        return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? n3 !== "__proto__" : n3 === null;
      }
      function mi(n3) {
        var t = je3(n3), e = a2[t];
        if (typeof e != "function" || !(t in H2.prototype))
          return false;
        if (n3 === e)
          return true;
        var r = di(e);
        return !!r && n3 === r[0];
      }
      function fh(n3) {
        return !!Ts2 && Ts2 in n3;
      }
      var ch = Re3 ? Jn2 : Ni2;
      function he3(n3) {
        var t = n3 && n3.constructor, e = typeof t == "function" && t.prototype || Nt3;
        return n3 === e;
      }
      function Tu(n3) {
        return n3 === n3 && !K3(n3);
      }
      function Lu(n3, t) {
        return function(e) {
          return e == null ? false : e[n3] === t && (t !== i3 || n3 in M3(e));
        };
      }
      function hh(n3) {
        var t = sr2(n3, function(r) {
          return e.size === pr && e.clear(), r;
        }), e = t.cache;
        return t;
      }
      function lh(n3, t) {
        var e = n3[1], r = t[1], s2 = e | r, o = s2 < (vn | ct3 | Mn2), f3 = r == Mn2 && e == Dn2 || r == Mn2 && e == Kt3 && n3[7].length <= t[8] || r == (Mn2 | Kt3) && t[7].length <= t[8] && e == Dn2;
        if (!(o || f3))
          return n3;
        r & vn && (n3[2] = t[2], s2 |= e & vn ? 0 : qi2);
        var c4 = t[3];
        if (c4) {
          var l3 = n3[3];
          n3[3] = l3 ? du(l3, c4, t[4]) : c4, n3[4] = l3 ? tt2(n3[3], It2) : t[4];
        }
        return c4 = t[5], c4 && (l3 = n3[5], n3[5] = l3 ? gu(l3, c4, t[6]) : c4, n3[6] = l3 ? tt2(n3[5], It2) : t[6]), c4 = t[7], c4 && (n3[7] = c4), r & Mn2 && (n3[8] = n3[8] == null ? t[8] : nn(n3[8], t[8])), n3[9] == null && (n3[9] = t[9]), n3[0] = t[0], n3[1] = s2, n3;
      }
      function ph(n3) {
        var t = [];
        if (n3 != null)
          for (var e in M3(n3))
            t.push(e);
        return t;
      }
      function dh(n3) {
        return Te.call(n3);
      }
      function Du(n3, t, e) {
        return t = Q4(t === i3 ? n3.length - 1 : t, 0), function() {
          for (var r = arguments, s2 = -1, o = Q4(r.length - t, 0), f3 = p5(o); ++s2 < o; )
            f3[s2] = r[t + s2];
          s2 = -1;
          for (var c4 = p5(t + 1); ++s2 < t; )
            c4[s2] = r[s2];
          return c4[t] = e(f3), cn2(n3, this, c4);
        };
      }
      function Hu(n3, t) {
        return t.length < 2 ? n3 : _t2(n3, Cn(t, 0, -1));
      }
      function gh(n3, t) {
        for (var e = n3.length, r = nn(t.length, e), s2 = un2(n3); r--; ) {
          var o = t[r];
          n3[r] = Zn(o, e) ? s2[o] : i3;
        }
        return n3;
      }
      function wi(n3, t) {
        if (!(t === "constructor" && typeof n3[t] == "function") && t != "__proto__")
          return n3[t];
      }
      var Nu = Uu(iu), le3 = bf || function(n3, t) {
        return k3.setTimeout(n3, t);
      }, Pi = Uu(Wc);
      function $u(n3, t, e) {
        var r = t + "";
        return Pi(n3, uh(r, vh(rh(r), e)));
      }
      function Uu(n3) {
        var t = 0, e = 0;
        return function() {
          var r = Hf(), s2 = Na - (r - e);
          if (e = r, s2 > 0) {
            if (++t >= Ha)
              return arguments[0];
          } else
            t = 0;
          return n3.apply(i3, arguments);
        };
      }
      function tr2(n3, t) {
        var e = -1, r = n3.length, s2 = r - 1;
        for (t = t === i3 ? r : t; ++e < t; ) {
          var o = ei(e, s2), f3 = n3[o];
          n3[o] = n3[e], n3[e] = f3;
        }
        return n3.length = t, n3;
      }
      var Wu = hh(function(n3) {
        var t = [];
        return n3.charCodeAt(0) === 46 && t.push(""), n3.replace(ro, function(e, r, s2, o) {
          t.push(s2 ? o.replace(ho, "$1") : r || e);
        }), t;
      });
      function Wn(n3) {
        if (typeof n3 == "string" || pn(n3))
          return n3;
        var t = n3 + "";
        return t == "0" && 1 / n3 == -ht2 ? "-0" : t;
      }
      function wt2(n3) {
        if (n3 != null) {
          try {
            return be.call(n3);
          } catch {
          }
          try {
            return n3 + "";
          } catch {
          }
        }
        return "";
      }
      function vh(n3, t) {
        return mn(qa, function(e) {
          var r = "_." + e[0];
          t & e[1] && !Ee(n3, r) && n3.push(r);
        }), n3.sort();
      }
      function Fu(n3) {
        if (n3 instanceof H2)
          return n3.clone();
        var t = new Pn(n3.__wrapped__, n3.__chain__);
        return t.__actions__ = un2(n3.__actions__), t.__index__ = n3.__index__, t.__values__ = n3.__values__, t;
      }
      function _h(n3, t, e) {
        (e ? rn(n3, t, e) : t === i3) ? t = 1 : t = Q4(R2(t), 0);
        var r = n3 == null ? 0 : n3.length;
        if (!r || t < 1)
          return [];
        for (var s2 = 0, o = 0, f3 = p5(Ue2(r / t)); s2 < r; )
          f3[o++] = Cn(n3, s2, s2 += t);
        return f3;
      }
      function mh(n3) {
        for (var t = -1, e = n3 == null ? 0 : n3.length, r = 0, s2 = []; ++t < e; ) {
          var o = n3[t];
          o && (s2[r++] = o);
        }
        return s2;
      }
      function wh() {
        var n3 = arguments.length;
        if (!n3)
          return [];
        for (var t = p5(n3 - 1), e = arguments[0], r = n3; r--; )
          t[r - 1] = arguments[r];
        return nt3(O6(e) ? un2(e) : [e], j5(t, 1));
      }
      var Ph = L3(function(n3, t) {
        return Z2(n3) ? ue2(n3, j5(t, 1, Z2, true)) : [];
      }), Ah = L3(function(n3, t) {
        var e = In(t);
        return Z2(e) && (e = i3), Z2(n3) ? ue2(n3, j5(t, 1, Z2, true), x3(e, 2)) : [];
      }), Ch = L3(function(n3, t) {
        var e = In(t);
        return Z2(e) && (e = i3), Z2(n3) ? ue2(n3, j5(t, 1, Z2, true), i3, e) : [];
      });
      function Ih(n3, t, e) {
        var r = n3 == null ? 0 : n3.length;
        return r ? (t = e || t === i3 ? 1 : R2(t), Cn(n3, t < 0 ? 0 : t, r)) : [];
      }
      function xh(n3, t, e) {
        var r = n3 == null ? 0 : n3.length;
        return r ? (t = e || t === i3 ? 1 : R2(t), t = r - t, Cn(n3, 0, t < 0 ? 0 : t)) : [];
      }
      function Eh(n3, t) {
        return n3 && n3.length ? Ze2(n3, x3(t, 3), true, true) : [];
      }
      function yh(n3, t) {
        return n3 && n3.length ? Ze2(n3, x3(t, 3), true) : [];
      }
      function Sh(n3, t, e, r) {
        var s2 = n3 == null ? 0 : n3.length;
        return s2 ? (e && typeof e != "number" && rn(n3, t, e) && (e = 0, r = s2), wc(n3, t, e, r)) : [];
      }
      function Mu(n3, t, e) {
        var r = n3 == null ? 0 : n3.length;
        if (!r)
          return -1;
        var s2 = e == null ? 0 : R2(e);
        return s2 < 0 && (s2 = Q4(r + s2, 0)), ye(n3, x3(t, 3), s2);
      }
      function qu(n3, t, e) {
        var r = n3 == null ? 0 : n3.length;
        if (!r)
          return -1;
        var s2 = r - 1;
        return e !== i3 && (s2 = R2(e), s2 = e < 0 ? Q4(r + s2, 0) : nn(s2, r - 1)), ye(n3, x3(t, 3), s2, true);
      }
      function Bu(n3) {
        var t = n3 == null ? 0 : n3.length;
        return t ? j5(n3, 1) : [];
      }
      function Oh(n3) {
        var t = n3 == null ? 0 : n3.length;
        return t ? j5(n3, ht2) : [];
      }
      function Rh(n3, t) {
        var e = n3 == null ? 0 : n3.length;
        return e ? (t = t === i3 ? 1 : R2(t), j5(n3, t)) : [];
      }
      function bh(n3) {
        for (var t = -1, e = n3 == null ? 0 : n3.length, r = {}; ++t < e; ) {
          var s2 = n3[t];
          r[s2[0]] = s2[1];
        }
        return r;
      }
      function Gu(n3) {
        return n3 && n3.length ? n3[0] : i3;
      }
      function Th(n3, t, e) {
        var r = n3 == null ? 0 : n3.length;
        if (!r)
          return -1;
        var s2 = e == null ? 0 : R2(e);
        return s2 < 0 && (s2 = Q4(r + s2, 0)), Tt2(n3, t, s2);
      }
      function Lh(n3) {
        var t = n3 == null ? 0 : n3.length;
        return t ? Cn(n3, 0, -1) : [];
      }
      var Dh = L3(function(n3) {
        var t = G3(n3, ai);
        return t.length && t[0] === n3[0] ? Vr(t) : [];
      }), Hh = L3(function(n3) {
        var t = In(n3), e = G3(n3, ai);
        return t === In(e) ? t = i3 : e.pop(), e.length && e[0] === n3[0] ? Vr(e, x3(t, 2)) : [];
      }), Nh = L3(function(n3) {
        var t = In(n3), e = G3(n3, ai);
        return t = typeof t == "function" ? t : i3, t && e.pop(), e.length && e[0] === n3[0] ? Vr(e, i3, t) : [];
      });
      function $h(n3, t) {
        return n3 == null ? "" : Lf.call(n3, t);
      }
      function In(n3) {
        var t = n3 == null ? 0 : n3.length;
        return t ? n3[t - 1] : i3;
      }
      function Uh(n3, t, e) {
        var r = n3 == null ? 0 : n3.length;
        if (!r)
          return -1;
        var s2 = r;
        return e !== i3 && (s2 = R2(e), s2 = s2 < 0 ? Q4(r + s2, 0) : nn(s2, r - 1)), t === t ? vf(n3, t, s2) : ye(n3, Is2, s2, true);
      }
      function Wh(n3, t) {
        return n3 && n3.length ? nu(n3, R2(t)) : i3;
      }
      var Fh = L3(zu);
      function zu(n3, t) {
        return n3 && n3.length && t && t.length ? ti(n3, t) : n3;
      }
      function Mh(n3, t, e) {
        return n3 && n3.length && t && t.length ? ti(n3, t, x3(e, 2)) : n3;
      }
      function qh(n3, t, e) {
        return n3 && n3.length && t && t.length ? ti(n3, t, i3, e) : n3;
      }
      var Bh = Yn(function(n3, t) {
        var e = n3 == null ? 0 : n3.length, r = Zr(n3, t);
        return ru(n3, G3(t, function(s2) {
          return Zn(s2, e) ? +s2 : s2;
        }).sort(pu)), r;
      });
      function Gh(n3, t) {
        var e = [];
        if (!(n3 && n3.length))
          return e;
        var r = -1, s2 = [], o = n3.length;
        for (t = x3(t, 3); ++r < o; ) {
          var f3 = n3[r];
          t(f3, r, n3) && (e.push(f3), s2.push(r));
        }
        return ru(n3, s2), e;
      }
      function Ai2(n3) {
        return n3 == null ? n3 : $f.call(n3);
      }
      function zh(n3, t, e) {
        var r = n3 == null ? 0 : n3.length;
        return r ? (e && typeof e != "number" && rn(n3, t, e) ? (t = 0, e = r) : (t = t == null ? 0 : R2(t), e = e === i3 ? r : R2(e)), Cn(n3, t, e)) : [];
      }
      function Kh(n3, t) {
        return Ye3(n3, t);
      }
      function Yh(n3, t, e) {
        return ii(n3, t, x3(e, 2));
      }
      function Zh(n3, t) {
        var e = n3 == null ? 0 : n3.length;
        if (e) {
          var r = Ye3(n3, t);
          if (r < e && bn(n3[r], t))
            return r;
        }
        return -1;
      }
      function Jh(n3, t) {
        return Ye3(n3, t, true);
      }
      function Xh(n3, t, e) {
        return ii(n3, t, x3(e, 2), true);
      }
      function Qh(n3, t) {
        var e = n3 == null ? 0 : n3.length;
        if (e) {
          var r = Ye3(n3, t, true) - 1;
          if (bn(n3[r], t))
            return r;
        }
        return -1;
      }
      function Vh(n3) {
        return n3 && n3.length ? su(n3) : [];
      }
      function kh(n3, t) {
        return n3 && n3.length ? su(n3, x3(t, 2)) : [];
      }
      function jh(n3) {
        var t = n3 == null ? 0 : n3.length;
        return t ? Cn(n3, 1, t) : [];
      }
      function nl(n3, t, e) {
        return n3 && n3.length ? (t = e || t === i3 ? 1 : R2(t), Cn(n3, 0, t < 0 ? 0 : t)) : [];
      }
      function tl(n3, t, e) {
        var r = n3 == null ? 0 : n3.length;
        return r ? (t = e || t === i3 ? 1 : R2(t), t = r - t, Cn(n3, t < 0 ? 0 : t, r)) : [];
      }
      function el(n3, t) {
        return n3 && n3.length ? Ze2(n3, x3(t, 3), false, true) : [];
      }
      function rl(n3, t) {
        return n3 && n3.length ? Ze2(n3, x3(t, 3)) : [];
      }
      var il = L3(function(n3) {
        return it3(j5(n3, 1, Z2, true));
      }), sl = L3(function(n3) {
        var t = In(n3);
        return Z2(t) && (t = i3), it3(j5(n3, 1, Z2, true), x3(t, 2));
      }), ul = L3(function(n3) {
        var t = In(n3);
        return t = typeof t == "function" ? t : i3, it3(j5(n3, 1, Z2, true), i3, t);
      });
      function al(n3) {
        return n3 && n3.length ? it3(n3) : [];
      }
      function ol(n3, t) {
        return n3 && n3.length ? it3(n3, x3(t, 2)) : [];
      }
      function fl(n3, t) {
        return t = typeof t == "function" ? t : i3, n3 && n3.length ? it3(n3, i3, t) : [];
      }
      function Ci(n3) {
        if (!(n3 && n3.length))
          return [];
        var t = 0;
        return n3 = jn2(n3, function(e) {
          if (Z2(e))
            return t = Q4(e.length, t), true;
        }), Fr(t, function(e) {
          return G3(n3, $r(e));
        });
      }
      function Ku(n3, t) {
        if (!(n3 && n3.length))
          return [];
        var e = Ci(n3);
        return t == null ? e : G3(e, function(r) {
          return cn2(t, i3, r);
        });
      }
      var cl = L3(function(n3, t) {
        return Z2(n3) ? ue2(n3, t) : [];
      }), hl = L3(function(n3) {
        return ui(jn2(n3, Z2));
      }), ll = L3(function(n3) {
        var t = In(n3);
        return Z2(t) && (t = i3), ui(jn2(n3, Z2), x3(t, 2));
      }), pl = L3(function(n3) {
        var t = In(n3);
        return t = typeof t == "function" ? t : i3, ui(jn2(n3, Z2), i3, t);
      }), dl = L3(Ci);
      function gl(n3, t) {
        return fu(n3 || [], t || [], se);
      }
      function vl(n3, t) {
        return fu(n3 || [], t || [], fe);
      }
      var _l = L3(function(n3) {
        var t = n3.length, e = t > 1 ? n3[t - 1] : i3;
        return e = typeof e == "function" ? (n3.pop(), e) : i3, Ku(n3, e);
      });
      function Yu(n3) {
        var t = a2(n3);
        return t.__chain__ = true, t;
      }
      function ml(n3, t) {
        return t(n3), n3;
      }
      function er3(n3, t) {
        return t(n3);
      }
      var wl = Yn(function(n3) {
        var t = n3.length, e = t ? n3[0] : 0, r = this.__wrapped__, s2 = function(o) {
          return Zr(o, n3);
        };
        return t > 1 || this.__actions__.length || !(r instanceof H2) || !Zn(e) ? this.thru(s2) : (r = r.slice(e, +e + (t ? 1 : 0)), r.__actions__.push({ func: er3, args: [s2], thisArg: i3 }), new Pn(r, this.__chain__).thru(function(o) {
          return t && !o.length && o.push(i3), o;
        }));
      });
      function Pl() {
        return Yu(this);
      }
      function Al() {
        return new Pn(this.value(), this.__chain__);
      }
      function Cl() {
        this.__values__ === i3 && (this.__values__ = ua(this.value()));
        var n3 = this.__index__ >= this.__values__.length, t = n3 ? i3 : this.__values__[this.__index__++];
        return { done: n3, value: t };
      }
      function Il() {
        return this;
      }
      function xl(n3) {
        for (var t, e = this; e instanceof qe2; ) {
          var r = Fu(e);
          r.__index__ = 0, r.__values__ = i3, t ? s2.__wrapped__ = r : t = r;
          var s2 = r;
          e = e.__wrapped__;
        }
        return s2.__wrapped__ = n3, t;
      }
      function El() {
        var n3 = this.__wrapped__;
        if (n3 instanceof H2) {
          var t = n3;
          return this.__actions__.length && (t = new H2(this)), t = t.reverse(), t.__actions__.push({ func: er3, args: [Ai2], thisArg: i3 }), new Pn(t, this.__chain__);
        }
        return this.thru(Ai2);
      }
      function yl() {
        return ou(this.__wrapped__, this.__actions__);
      }
      var Sl = Je3(function(n3, t, e) {
        F3.call(n3, e) ? ++n3[e] : zn2(n3, e, 1);
      });
      function Ol(n3, t, e) {
        var r = O6(n3) ? As2 : mc;
        return e && rn(n3, t, e) && (t = i3), r(n3, x3(t, 3));
      }
      function Rl(n3, t) {
        var e = O6(n3) ? jn2 : Ks2;
        return e(n3, x3(t, 3));
      }
      var bl = wu(Mu), Tl = wu(qu);
      function Ll(n3, t) {
        return j5(rr2(n3, t), 1);
      }
      function Dl(n3, t) {
        return j5(rr2(n3, t), ht2);
      }
      function Hl(n3, t, e) {
        return e = e === i3 ? 1 : R2(e), j5(rr2(n3, t), e);
      }
      function Zu(n3, t) {
        var e = O6(n3) ? mn : rt2;
        return e(n3, x3(t, 3));
      }
      function Ju(n3, t) {
        var e = O6(n3) ? ko : zs2;
        return e(n3, x3(t, 3));
      }
      var Nl = Je3(function(n3, t, e) {
        F3.call(n3, e) ? n3[e].push(t) : zn2(n3, e, [t]);
      });
      function $l(n3, t, e, r) {
        n3 = an2(n3) ? n3 : Gt3(n3), e = e && !r ? R2(e) : 0;
        var s2 = n3.length;
        return e < 0 && (e = Q4(s2 + e, 0)), or2(n3) ? e <= s2 && n3.indexOf(t, e) > -1 : !!s2 && Tt2(n3, t, e) > -1;
      }
      var Ul = L3(function(n3, t, e) {
        var r = -1, s2 = typeof t == "function", o = an2(n3) ? p5(n3.length) : [];
        return rt2(n3, function(f3) {
          o[++r] = s2 ? cn2(t, f3, e) : ae2(f3, t, e);
        }), o;
      }), Wl = Je3(function(n3, t, e) {
        zn2(n3, e, t);
      });
      function rr2(n3, t) {
        var e = O6(n3) ? G3 : Vs2;
        return e(n3, x3(t, 3));
      }
      function Fl(n3, t, e, r) {
        return n3 == null ? [] : (O6(t) || (t = t == null ? [] : [t]), e = r ? i3 : e, O6(e) || (e = e == null ? [] : [e]), tu(n3, t, e));
      }
      var Ml = Je3(function(n3, t, e) {
        n3[e ? 0 : 1].push(t);
      }, function() {
        return [[], []];
      });
      function ql(n3, t, e) {
        var r = O6(n3) ? Hr : Es2, s2 = arguments.length < 3;
        return r(n3, x3(t, 4), e, s2, rt2);
      }
      function Bl(n3, t, e) {
        var r = O6(n3) ? jo : Es2, s2 = arguments.length < 3;
        return r(n3, x3(t, 4), e, s2, zs2);
      }
      function Gl(n3, t) {
        var e = O6(n3) ? jn2 : Ks2;
        return e(n3, ur2(x3(t, 3)));
      }
      function zl(n3) {
        var t = O6(n3) ? Ms2 : $c;
        return t(n3);
      }
      function Kl(n3, t, e) {
        (e ? rn(n3, t, e) : t === i3) ? t = 1 : t = R2(t);
        var r = O6(n3) ? pc : Uc;
        return r(n3, t);
      }
      function Yl(n3) {
        var t = O6(n3) ? dc : Fc;
        return t(n3);
      }
      function Zl(n3) {
        if (n3 == null)
          return 0;
        if (an2(n3))
          return or2(n3) ? Dt3(n3) : n3.length;
        var t = tn(n3);
        return t == yn || t == Sn ? n3.size : jr(n3).length;
      }
      function Jl(n3, t, e) {
        var r = O6(n3) ? Nr : Mc;
        return e && rn(n3, t, e) && (t = i3), r(n3, x3(t, 3));
      }
      var Xl = L3(function(n3, t) {
        if (n3 == null)
          return [];
        var e = t.length;
        return e > 1 && rn(n3, t[0], t[1]) ? t = [] : e > 2 && rn(t[0], t[1], t[2]) && (t = [t[0]]), tu(n3, j5(t, 1), []);
      }), ir2 = Rf || function() {
        return k3.Date.now();
      };
      function Ql(n3, t) {
        if (typeof t != "function")
          throw new wn($3);
        return n3 = R2(n3), function() {
          if (--n3 < 1)
            return t.apply(this, arguments);
        };
      }
      function Xu(n3, t, e) {
        return t = e ? i3 : t, t = n3 && t == null ? n3.length : t, Kn2(n3, Mn2, i3, i3, i3, i3, t);
      }
      function Qu(n3, t) {
        var e;
        if (typeof t != "function")
          throw new wn($3);
        return n3 = R2(n3), function() {
          return --n3 > 0 && (e = t.apply(this, arguments)), n3 <= 1 && (t = i3), e;
        };
      }
      var Ii = L3(function(n3, t, e) {
        var r = vn;
        if (e.length) {
          var s2 = tt2(e, qt3(Ii));
          r |= Hn;
        }
        return Kn2(n3, r, t, e, s2);
      }), Vu = L3(function(n3, t, e) {
        var r = vn | ct3;
        if (e.length) {
          var s2 = tt2(e, qt3(Vu));
          r |= Hn;
        }
        return Kn2(t, r, n3, e, s2);
      });
      function ku(n3, t, e) {
        t = e ? i3 : t;
        var r = Kn2(n3, Dn2, i3, i3, i3, i3, i3, t);
        return r.placeholder = ku.placeholder, r;
      }
      function ju(n3, t, e) {
        t = e ? i3 : t;
        var r = Kn2(n3, yt3, i3, i3, i3, i3, i3, t);
        return r.placeholder = ju.placeholder, r;
      }
      function na(n3, t, e) {
        var r, s2, o, f3, c4, l3, v4 = 0, _5 = false, m2 = false, P2 = true;
        if (typeof n3 != "function")
          throw new wn($3);
        t = xn2(t) || 0, K3(e) && (_5 = !!e.leading, m2 = "maxWait" in e, o = m2 ? Q4(xn2(e.maxWait) || 0, t) : o, P2 = "trailing" in e ? !!e.trailing : P2);
        function I2(J2) {
          var Tn = r, Qn = s2;
          return r = s2 = i3, v4 = J2, f3 = n3.apply(Qn, Tn), f3;
        }
        function E5(J2) {
          return v4 = J2, c4 = le3(D5, t), _5 ? I2(J2) : f3;
        }
        function b5(J2) {
          var Tn = J2 - l3, Qn = J2 - v4, wa = t - Tn;
          return m2 ? nn(wa, o - Qn) : wa;
        }
        function y6(J2) {
          var Tn = J2 - l3, Qn = J2 - v4;
          return l3 === i3 || Tn >= t || Tn < 0 || m2 && Qn >= o;
        }
        function D5() {
          var J2 = ir2();
          if (y6(J2))
            return N5(J2);
          c4 = le3(D5, b5(J2));
        }
        function N5(J2) {
          return c4 = i3, P2 && r ? I2(J2) : (r = s2 = i3, f3);
        }
        function dn() {
          c4 !== i3 && cu(c4), v4 = 0, r = l3 = s2 = c4 = i3;
        }
        function sn() {
          return c4 === i3 ? f3 : N5(ir2());
        }
        function gn() {
          var J2 = ir2(), Tn = y6(J2);
          if (r = arguments, s2 = this, l3 = J2, Tn) {
            if (c4 === i3)
              return E5(l3);
            if (m2)
              return cu(c4), c4 = le3(D5, t), I2(l3);
          }
          return c4 === i3 && (c4 = le3(D5, t)), f3;
        }
        return gn.cancel = dn, gn.flush = sn, gn;
      }
      var Vl = L3(function(n3, t) {
        return Gs2(n3, 1, t);
      }), kl = L3(function(n3, t, e) {
        return Gs2(n3, xn2(t) || 0, e);
      });
      function jl(n3) {
        return Kn2(n3, dr);
      }
      function sr2(n3, t) {
        if (typeof n3 != "function" || t != null && typeof t != "function")
          throw new wn($3);
        var e = function() {
          var r = arguments, s2 = t ? t.apply(this, r) : r[0], o = e.cache;
          if (o.has(s2))
            return o.get(s2);
          var f3 = n3.apply(this, r);
          return e.cache = o.set(s2, f3) || o, f3;
        };
        return e.cache = new (sr2.Cache || Gn)(), e;
      }
      sr2.Cache = Gn;
      function ur2(n3) {
        if (typeof n3 != "function")
          throw new wn($3);
        return function() {
          var t = arguments;
          switch (t.length) {
            case 0:
              return !n3.call(this);
            case 1:
              return !n3.call(this, t[0]);
            case 2:
              return !n3.call(this, t[0], t[1]);
            case 3:
              return !n3.call(this, t[0], t[1], t[2]);
          }
          return !n3.apply(this, t);
        };
      }
      function np(n3) {
        return Qu(2, n3);
      }
      var tp = qc(function(n3, t) {
        t = t.length == 1 && O6(t[0]) ? G3(t[0], hn(x3())) : G3(j5(t, 1), hn(x3()));
        var e = t.length;
        return L3(function(r) {
          for (var s2 = -1, o = nn(r.length, e); ++s2 < o; )
            r[s2] = t[s2].call(this, r[s2]);
          return cn2(n3, this, r);
        });
      }), xi = L3(function(n3, t) {
        var e = tt2(t, qt3(xi));
        return Kn2(n3, Hn, i3, t, e);
      }), ta = L3(function(n3, t) {
        var e = tt2(t, qt3(ta));
        return Kn2(n3, St2, i3, t, e);
      }), ep = Yn(function(n3, t) {
        return Kn2(n3, Kt3, i3, i3, i3, t);
      });
      function rp(n3, t) {
        if (typeof n3 != "function")
          throw new wn($3);
        return t = t === i3 ? t : R2(t), L3(n3, t);
      }
      function ip(n3, t) {
        if (typeof n3 != "function")
          throw new wn($3);
        return t = t == null ? 0 : Q4(R2(t), 0), L3(function(e) {
          var r = e[t], s2 = ut3(e, 0, t);
          return r && nt3(s2, r), cn2(n3, this, s2);
        });
      }
      function sp(n3, t, e) {
        var r = true, s2 = true;
        if (typeof n3 != "function")
          throw new wn($3);
        return K3(e) && (r = "leading" in e ? !!e.leading : r, s2 = "trailing" in e ? !!e.trailing : s2), na(n3, t, { leading: r, maxWait: t, trailing: s2 });
      }
      function up(n3) {
        return Xu(n3, 1);
      }
      function ap(n3, t) {
        return xi(oi(t), n3);
      }
      function op() {
        if (!arguments.length)
          return [];
        var n3 = arguments[0];
        return O6(n3) ? n3 : [n3];
      }
      function fp(n3) {
        return An(n3, xt3);
      }
      function cp(n3, t) {
        return t = typeof t == "function" ? t : i3, An(n3, xt3, t);
      }
      function hp(n3) {
        return An(n3, Ln2 | xt3);
      }
      function lp(n3, t) {
        return t = typeof t == "function" ? t : i3, An(n3, Ln2 | xt3, t);
      }
      function pp(n3, t) {
        return t == null || Bs2(n3, t, V3(t));
      }
      function bn(n3, t) {
        return n3 === t || n3 !== n3 && t !== t;
      }
      var dp = ke2(Qr), gp = ke2(function(n3, t) {
        return n3 >= t;
      }), Pt2 = Js2(function() {
        return arguments;
      }()) ? Js2 : function(n3) {
        return Y(n3) && F3.call(n3, "callee") && !Hs2.call(n3, "callee");
      }, O6 = p5.isArray, vp = gs2 ? hn(gs2) : xc;
      function an2(n3) {
        return n3 != null && ar2(n3.length) && !Jn2(n3);
      }
      function Z2(n3) {
        return Y(n3) && an2(n3);
      }
      function _p(n3) {
        return n3 === true || n3 === false || Y(n3) && en(n3) == Yt;
      }
      var at3 = Tf || Ni2, mp = vs2 ? hn(vs2) : Ec;
      function wp(n3) {
        return Y(n3) && n3.nodeType === 1 && !pe3(n3);
      }
      function Pp(n3) {
        if (n3 == null)
          return true;
        if (an2(n3) && (O6(n3) || typeof n3 == "string" || typeof n3.splice == "function" || at3(n3) || Bt3(n3) || Pt2(n3)))
          return !n3.length;
        var t = tn(n3);
        if (t == yn || t == Sn)
          return !n3.size;
        if (he3(n3))
          return !jr(n3).length;
        for (var e in n3)
          if (F3.call(n3, e))
            return false;
        return true;
      }
      function Ap(n3, t) {
        return oe4(n3, t);
      }
      function Cp(n3, t, e) {
        e = typeof e == "function" ? e : i3;
        var r = e ? e(n3, t) : i3;
        return r === i3 ? oe4(n3, t, i3, e) : !!r;
      }
      function Ei(n3) {
        if (!Y(n3))
          return false;
        var t = en(n3);
        return t == we || t == Ga || typeof n3.message == "string" && typeof n3.name == "string" && !pe3(n3);
      }
      function Ip(n3) {
        return typeof n3 == "number" && $s2(n3);
      }
      function Jn2(n3) {
        if (!K3(n3))
          return false;
        var t = en(n3);
        return t == Pe || t == Gi2 || t == Ba || t == Ka;
      }
      function ea(n3) {
        return typeof n3 == "number" && n3 == R2(n3);
      }
      function ar2(n3) {
        return typeof n3 == "number" && n3 > -1 && n3 % 1 == 0 && n3 <= kn2;
      }
      function K3(n3) {
        var t = typeof n3;
        return n3 != null && (t == "object" || t == "function");
      }
      function Y(n3) {
        return n3 != null && typeof n3 == "object";
      }
      var ra = _s2 ? hn(_s2) : Sc;
      function xp(n3, t) {
        return n3 === t || kr(n3, t, gi(t));
      }
      function Ep(n3, t, e) {
        return e = typeof e == "function" ? e : i3, kr(n3, t, gi(t), e);
      }
      function yp(n3) {
        return ia(n3) && n3 != +n3;
      }
      function Sp(n3) {
        if (ch(n3))
          throw new S5(T3);
        return Xs2(n3);
      }
      function Op(n3) {
        return n3 === null;
      }
      function Rp(n3) {
        return n3 == null;
      }
      function ia(n3) {
        return typeof n3 == "number" || Y(n3) && en(n3) == Jt;
      }
      function pe3(n3) {
        if (!Y(n3) || en(n3) != qn)
          return false;
        var t = He2(n3);
        if (t === null)
          return true;
        var e = F3.call(t, "constructor") && t.constructor;
        return typeof e == "function" && e instanceof e && be.call(e) == Ef;
      }
      var yi = ms2 ? hn(ms2) : Oc;
      function bp(n3) {
        return ea(n3) && n3 >= -kn2 && n3 <= kn2;
      }
      var sa = ws2 ? hn(ws2) : Rc;
      function or2(n3) {
        return typeof n3 == "string" || !O6(n3) && Y(n3) && en(n3) == Qt2;
      }
      function pn(n3) {
        return typeof n3 == "symbol" || Y(n3) && en(n3) == Ae;
      }
      var Bt3 = Ps2 ? hn(Ps2) : bc;
      function Tp(n3) {
        return n3 === i3;
      }
      function Lp(n3) {
        return Y(n3) && tn(n3) == Vt3;
      }
      function Dp(n3) {
        return Y(n3) && en(n3) == Za;
      }
      var Hp = ke2(ni), Np = ke2(function(n3, t) {
        return n3 <= t;
      });
      function ua(n3) {
        if (!n3)
          return [];
        if (an2(n3))
          return or2(n3) ? On(n3) : un2(n3);
        if (ne2 && n3[ne2])
          return pf(n3[ne2]());
        var t = tn(n3), e = t == yn ? qr : t == Sn ? Se2 : Gt3;
        return e(n3);
      }
      function Xn(n3) {
        if (!n3)
          return n3 === 0 ? n3 : 0;
        if (n3 = xn2(n3), n3 === ht2 || n3 === -ht2) {
          var t = n3 < 0 ? -1 : 1;
          return t * Wa;
        }
        return n3 === n3 ? n3 : 0;
      }
      function R2(n3) {
        var t = Xn(n3), e = t % 1;
        return t === t ? e ? t - e : t : 0;
      }
      function aa(n3) {
        return n3 ? vt2(R2(n3), 0, Nn) : 0;
      }
      function xn2(n3) {
        if (typeof n3 == "number")
          return n3;
        if (pn(n3))
          return _e2;
        if (K3(n3)) {
          var t = typeof n3.valueOf == "function" ? n3.valueOf() : n3;
          n3 = K3(t) ? t + "" : t;
        }
        if (typeof n3 != "string")
          return n3 === 0 ? n3 : +n3;
        n3 = ys2(n3);
        var e = go.test(n3);
        return e || _o.test(n3) ? Xo(n3.slice(2), e ? 2 : 8) : po.test(n3) ? _e2 : +n3;
      }
      function oa(n3) {
        return Un(n3, on(n3));
      }
      function $p(n3) {
        return n3 ? vt2(R2(n3), -kn2, kn2) : n3 === 0 ? n3 : 0;
      }
      function W3(n3) {
        return n3 == null ? "" : ln(n3);
      }
      var Up = Ft3(function(n3, t) {
        if (he3(t) || an2(t)) {
          Un(t, V3(t), n3);
          return;
        }
        for (var e in t)
          F3.call(t, e) && se(n3, e, t[e]);
      }), fa = Ft3(function(n3, t) {
        Un(t, on(t), n3);
      }), fr2 = Ft3(function(n3, t, e, r) {
        Un(t, on(t), n3, r);
      }), Wp = Ft3(function(n3, t, e, r) {
        Un(t, V3(t), n3, r);
      }), Fp = Yn(Zr);
      function Mp(n3, t) {
        var e = Wt2(n3);
        return t == null ? e : qs2(e, t);
      }
      var qp = L3(function(n3, t) {
        n3 = M3(n3);
        var e = -1, r = t.length, s2 = r > 2 ? t[2] : i3;
        for (s2 && rn(t[0], t[1], s2) && (r = 1); ++e < r; )
          for (var o = t[e], f3 = on(o), c4 = -1, l3 = f3.length; ++c4 < l3; ) {
            var v4 = f3[c4], _5 = n3[v4];
            (_5 === i3 || bn(_5, Nt3[v4]) && !F3.call(n3, v4)) && (n3[v4] = o[v4]);
          }
        return n3;
      }), Bp = L3(function(n3) {
        return n3.push(i3, yu), cn2(ca, i3, n3);
      });
      function Gp(n3, t) {
        return Cs2(n3, x3(t, 3), $n);
      }
      function zp(n3, t) {
        return Cs2(n3, x3(t, 3), Xr);
      }
      function Kp(n3, t) {
        return n3 == null ? n3 : Jr(n3, x3(t, 3), on);
      }
      function Yp(n3, t) {
        return n3 == null ? n3 : Ys2(n3, x3(t, 3), on);
      }
      function Zp(n3, t) {
        return n3 && $n(n3, x3(t, 3));
      }
      function Jp(n3, t) {
        return n3 && Xr(n3, x3(t, 3));
      }
      function Xp(n3) {
        return n3 == null ? [] : ze3(n3, V3(n3));
      }
      function Qp(n3) {
        return n3 == null ? [] : ze3(n3, on(n3));
      }
      function Si(n3, t, e) {
        var r = n3 == null ? i3 : _t2(n3, t);
        return r === i3 ? e : r;
      }
      function Vp(n3, t) {
        return n3 != null && Ru(n3, t, Pc);
      }
      function Oi(n3, t) {
        return n3 != null && Ru(n3, t, Ac);
      }
      var kp = Au(function(n3, t, e) {
        t != null && typeof t.toString != "function" && (t = Te.call(t)), n3[t] = e;
      }, bi(fn)), jp = Au(function(n3, t, e) {
        t != null && typeof t.toString != "function" && (t = Te.call(t)), F3.call(n3, t) ? n3[t].push(e) : n3[t] = [e];
      }, x3), nd = L3(ae2);
      function V3(n3) {
        return an2(n3) ? Fs2(n3) : jr(n3);
      }
      function on(n3) {
        return an2(n3) ? Fs2(n3, true) : Tc(n3);
      }
      function td(n3, t) {
        var e = {};
        return t = x3(t, 3), $n(n3, function(r, s2, o) {
          zn2(e, t(r, s2, o), r);
        }), e;
      }
      function ed(n3, t) {
        var e = {};
        return t = x3(t, 3), $n(n3, function(r, s2, o) {
          zn2(e, s2, t(r, s2, o));
        }), e;
      }
      var rd = Ft3(function(n3, t, e) {
        Ke2(n3, t, e);
      }), ca = Ft3(function(n3, t, e, r) {
        Ke2(n3, t, e, r);
      }), id = Yn(function(n3, t) {
        var e = {};
        if (n3 == null)
          return e;
        var r = false;
        t = G3(t, function(o) {
          return o = st3(o, n3), r || (r = o.length > 1), o;
        }), Un(n3, pi(n3), e), r && (e = An(e, Ln2 | Fn2 | xt3, kc));
        for (var s2 = t.length; s2--; )
          si(e, t[s2]);
        return e;
      });
      function sd(n3, t) {
        return ha(n3, ur2(x3(t)));
      }
      var ud = Yn(function(n3, t) {
        return n3 == null ? {} : Dc(n3, t);
      });
      function ha(n3, t) {
        if (n3 == null)
          return {};
        var e = G3(pi(n3), function(r) {
          return [r];
        });
        return t = x3(t), eu(n3, e, function(r, s2) {
          return t(r, s2[0]);
        });
      }
      function ad(n3, t, e) {
        t = st3(t, n3);
        var r = -1, s2 = t.length;
        for (s2 || (s2 = 1, n3 = i3); ++r < s2; ) {
          var o = n3 == null ? i3 : n3[Wn(t[r])];
          o === i3 && (r = s2, o = e), n3 = Jn2(o) ? o.call(n3) : o;
        }
        return n3;
      }
      function od(n3, t, e) {
        return n3 == null ? n3 : fe(n3, t, e);
      }
      function fd(n3, t, e, r) {
        return r = typeof r == "function" ? r : i3, n3 == null ? n3 : fe(n3, t, e, r);
      }
      var la = xu(V3), pa = xu(on);
      function cd(n3, t, e) {
        var r = O6(n3), s2 = r || at3(n3) || Bt3(n3);
        if (t = x3(t, 4), e == null) {
          var o = n3 && n3.constructor;
          s2 ? e = r ? new o() : [] : K3(n3) ? e = Jn2(o) ? Wt2(He2(n3)) : {} : e = {};
        }
        return (s2 ? mn : $n)(n3, function(f3, c4, l3) {
          return t(e, f3, c4, l3);
        }), e;
      }
      function hd(n3, t) {
        return n3 == null ? true : si(n3, t);
      }
      function ld(n3, t, e) {
        return n3 == null ? n3 : au(n3, t, oi(e));
      }
      function pd(n3, t, e, r) {
        return r = typeof r == "function" ? r : i3, n3 == null ? n3 : au(n3, t, oi(e), r);
      }
      function Gt3(n3) {
        return n3 == null ? [] : Mr(n3, V3(n3));
      }
      function dd(n3) {
        return n3 == null ? [] : Mr(n3, on(n3));
      }
      function gd(n3, t, e) {
        return e === i3 && (e = t, t = i3), e !== i3 && (e = xn2(e), e = e === e ? e : 0), t !== i3 && (t = xn2(t), t = t === t ? t : 0), vt2(xn2(n3), t, e);
      }
      function vd(n3, t, e) {
        return t = Xn(t), e === i3 ? (e = t, t = 0) : e = Xn(e), n3 = xn2(n3), Cc(n3, t, e);
      }
      function _d(n3, t, e) {
        if (e && typeof e != "boolean" && rn(n3, t, e) && (t = e = i3), e === i3 && (typeof t == "boolean" ? (e = t, t = i3) : typeof n3 == "boolean" && (e = n3, n3 = i3)), n3 === i3 && t === i3 ? (n3 = 0, t = 1) : (n3 = Xn(n3), t === i3 ? (t = n3, n3 = 0) : t = Xn(t)), n3 > t) {
          var r = n3;
          n3 = t, t = r;
        }
        if (e || n3 % 1 || t % 1) {
          var s2 = Us2();
          return nn(n3 + s2 * (t - n3 + Jo("1e-" + ((s2 + "").length - 1))), t);
        }
        return ei(n3, t);
      }
      var md = Mt3(function(n3, t, e) {
        return t = t.toLowerCase(), n3 + (e ? da(t) : t);
      });
      function da(n3) {
        return Ri(W3(n3).toLowerCase());
      }
      function ga(n3) {
        return n3 = W3(n3), n3 && n3.replace(wo, of).replace(Wo, "");
      }
      function wd(n3, t, e) {
        n3 = W3(n3), t = ln(t);
        var r = n3.length;
        e = e === i3 ? r : vt2(R2(e), 0, r);
        var s2 = e;
        return e -= t.length, e >= 0 && n3.slice(e, s2) == t;
      }
      function Pd(n3) {
        return n3 = W3(n3), n3 && ka.test(n3) ? n3.replace(Yi2, ff) : n3;
      }
      function Ad(n3) {
        return n3 = W3(n3), n3 && io.test(n3) ? n3.replace(xr2, "\\$&") : n3;
      }
      var Cd = Mt3(function(n3, t, e) {
        return n3 + (e ? "-" : "") + t.toLowerCase();
      }), Id = Mt3(function(n3, t, e) {
        return n3 + (e ? " " : "") + t.toLowerCase();
      }), xd = mu("toLowerCase");
      function Ed(n3, t, e) {
        n3 = W3(n3), t = R2(t);
        var r = t ? Dt3(n3) : 0;
        if (!t || r >= t)
          return n3;
        var s2 = (t - r) / 2;
        return Ve2(We2(s2), e) + n3 + Ve2(Ue2(s2), e);
      }
      function yd(n3, t, e) {
        n3 = W3(n3), t = R2(t);
        var r = t ? Dt3(n3) : 0;
        return t && r < t ? n3 + Ve2(t - r, e) : n3;
      }
      function Sd(n3, t, e) {
        n3 = W3(n3), t = R2(t);
        var r = t ? Dt3(n3) : 0;
        return t && r < t ? Ve2(t - r, e) + n3 : n3;
      }
      function Od(n3, t, e) {
        return e || t == null ? t = 0 : t && (t = +t), Nf(W3(n3).replace(Er2, ""), t || 0);
      }
      function Rd(n3, t, e) {
        return (e ? rn(n3, t, e) : t === i3) ? t = 1 : t = R2(t), ri(W3(n3), t);
      }
      function bd() {
        var n3 = arguments, t = W3(n3[0]);
        return n3.length < 3 ? t : t.replace(n3[1], n3[2]);
      }
      var Td = Mt3(function(n3, t, e) {
        return n3 + (e ? "_" : "") + t.toLowerCase();
      });
      function Ld(n3, t, e) {
        return e && typeof e != "number" && rn(n3, t, e) && (t = e = i3), e = e === i3 ? Nn : e >>> 0, e ? (n3 = W3(n3), n3 && (typeof t == "string" || t != null && !yi(t)) && (t = ln(t), !t && Lt3(n3)) ? ut3(On(n3), 0, e) : n3.split(t, e)) : [];
      }
      var Dd = Mt3(function(n3, t, e) {
        return n3 + (e ? " " : "") + Ri(t);
      });
      function Hd(n3, t, e) {
        return n3 = W3(n3), e = e == null ? 0 : vt2(R2(e), 0, n3.length), t = ln(t), n3.slice(e, e + t.length) == t;
      }
      function Nd(n3, t, e) {
        var r = a2.templateSettings;
        e && rn(n3, t, e) && (t = i3), n3 = W3(n3), t = fr2({}, t, r, Eu);
        var s2 = fr2({}, t.imports, r.imports, Eu), o = V3(s2), f3 = Mr(s2, o), c4, l3, v4 = 0, _5 = t.interpolate || Ce2, m2 = "__p += '", P2 = Br((t.escape || Ce2).source + "|" + _5.source + "|" + (_5 === Zi2 ? lo : Ce2).source + "|" + (t.evaluate || Ce2).source + "|$", "g"), I2 = "//# sourceURL=" + (F3.call(t, "sourceURL") ? (t.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Go + "]") + `
`;
        n3.replace(P2, function(y6, D5, N5, dn, sn, gn) {
          return N5 || (N5 = dn), m2 += n3.slice(v4, gn).replace(Po, cf), D5 && (c4 = true, m2 += `' +
__e(` + D5 + `) +
'`), sn && (l3 = true, m2 += `';
` + sn + `;
__p += '`), N5 && (m2 += `' +
((__t = (` + N5 + `)) == null ? '' : __t) +
'`), v4 = gn + y6.length, y6;
        }), m2 += `';
`;
        var E5 = F3.call(t, "variable") && t.variable;
        if (!E5)
          m2 = `with (obj) {
` + m2 + `
}
`;
        else if (co.test(E5))
          throw new S5(En);
        m2 = (l3 ? m2.replace(Ja, "") : m2).replace(Xa, "$1").replace(Qa, "$1;"), m2 = "function(" + (E5 || "obj") + `) {
` + (E5 ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (c4 ? ", __e = _.escape" : "") + (l3 ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + m2 + `return __p
}`;
        var b5 = _a(function() {
          return U6(o, I2 + "return " + m2).apply(i3, f3);
        });
        if (b5.source = m2, Ei(b5))
          throw b5;
        return b5;
      }
      function $d(n3) {
        return W3(n3).toLowerCase();
      }
      function Ud(n3) {
        return W3(n3).toUpperCase();
      }
      function Wd(n3, t, e) {
        if (n3 = W3(n3), n3 && (e || t === i3))
          return ys2(n3);
        if (!n3 || !(t = ln(t)))
          return n3;
        var r = On(n3), s2 = On(t), o = Ss2(r, s2), f3 = Os2(r, s2) + 1;
        return ut3(r, o, f3).join("");
      }
      function Fd(n3, t, e) {
        if (n3 = W3(n3), n3 && (e || t === i3))
          return n3.slice(0, bs2(n3) + 1);
        if (!n3 || !(t = ln(t)))
          return n3;
        var r = On(n3), s2 = Os2(r, On(t)) + 1;
        return ut3(r, 0, s2).join("");
      }
      function Md(n3, t, e) {
        if (n3 = W3(n3), n3 && (e || t === i3))
          return n3.replace(Er2, "");
        if (!n3 || !(t = ln(t)))
          return n3;
        var r = On(n3), s2 = Ss2(r, On(t));
        return ut3(r, s2).join("");
      }
      function qd(n3, t) {
        var e = La, r = Da;
        if (K3(t)) {
          var s2 = "separator" in t ? t.separator : s2;
          e = "length" in t ? R2(t.length) : e, r = "omission" in t ? ln(t.omission) : r;
        }
        n3 = W3(n3);
        var o = n3.length;
        if (Lt3(n3)) {
          var f3 = On(n3);
          o = f3.length;
        }
        if (e >= o)
          return n3;
        var c4 = e - Dt3(r);
        if (c4 < 1)
          return r;
        var l3 = f3 ? ut3(f3, 0, c4).join("") : n3.slice(0, c4);
        if (s2 === i3)
          return l3 + r;
        if (f3 && (c4 += l3.length - c4), yi(s2)) {
          if (n3.slice(c4).search(s2)) {
            var v4, _5 = l3;
            for (s2.global || (s2 = Br(s2.source, W3(Ji2.exec(s2)) + "g")), s2.lastIndex = 0; v4 = s2.exec(_5); )
              var m2 = v4.index;
            l3 = l3.slice(0, m2 === i3 ? c4 : m2);
          }
        } else if (n3.indexOf(ln(s2), c4) != c4) {
          var P2 = l3.lastIndexOf(s2);
          P2 > -1 && (l3 = l3.slice(0, P2));
        }
        return l3 + r;
      }
      function Bd(n3) {
        return n3 = W3(n3), n3 && Va.test(n3) ? n3.replace(Ki2, _f) : n3;
      }
      var Gd = Mt3(function(n3, t, e) {
        return n3 + (e ? " " : "") + t.toUpperCase();
      }), Ri = mu("toUpperCase");
      function va(n3, t, e) {
        return n3 = W3(n3), t = e ? i3 : t, t === i3 ? lf(n3) ? Pf(n3) : ef(n3) : n3.match(t) || [];
      }
      var _a = L3(function(n3, t) {
        try {
          return cn2(n3, i3, t);
        } catch (e) {
          return Ei(e) ? e : new S5(e);
        }
      }), zd = Yn(function(n3, t) {
        return mn(t, function(e) {
          e = Wn(e), zn2(n3, e, Ii(n3[e], n3));
        }), n3;
      });
      function Kd(n3) {
        var t = n3 == null ? 0 : n3.length, e = x3();
        return n3 = t ? G3(n3, function(r) {
          if (typeof r[1] != "function")
            throw new wn($3);
          return [e(r[0]), r[1]];
        }) : [], L3(function(r) {
          for (var s2 = -1; ++s2 < t; ) {
            var o = n3[s2];
            if (cn2(o[0], this, r))
              return cn2(o[1], this, r);
          }
        });
      }
      function Yd(n3) {
        return _c(An(n3, Ln2));
      }
      function bi(n3) {
        return function() {
          return n3;
        };
      }
      function Zd(n3, t) {
        return n3 == null || n3 !== n3 ? t : n3;
      }
      var Jd = Pu(), Xd = Pu(true);
      function fn(n3) {
        return n3;
      }
      function Ti(n3) {
        return Qs2(typeof n3 == "function" ? n3 : An(n3, Ln2));
      }
      function Qd(n3) {
        return ks2(An(n3, Ln2));
      }
      function Vd(n3, t) {
        return js2(n3, An(t, Ln2));
      }
      var kd = L3(function(n3, t) {
        return function(e) {
          return ae2(e, n3, t);
        };
      }), jd = L3(function(n3, t) {
        return function(e) {
          return ae2(n3, e, t);
        };
      });
      function Li(n3, t, e) {
        var r = V3(t), s2 = ze3(t, r);
        e == null && !(K3(t) && (s2.length || !r.length)) && (e = t, t = n3, n3 = this, s2 = ze3(t, V3(t)));
        var o = !(K3(e) && "chain" in e) || !!e.chain, f3 = Jn2(n3);
        return mn(s2, function(c4) {
          var l3 = t[c4];
          n3[c4] = l3, f3 && (n3.prototype[c4] = function() {
            var v4 = this.__chain__;
            if (o || v4) {
              var _5 = n3(this.__wrapped__), m2 = _5.__actions__ = un2(this.__actions__);
              return m2.push({ func: l3, args: arguments, thisArg: n3 }), _5.__chain__ = v4, _5;
            }
            return l3.apply(n3, nt3([this.value()], arguments));
          });
        }), n3;
      }
      function ng() {
        return k3._ === this && (k3._ = yf), this;
      }
      function Di() {
      }
      function tg(n3) {
        return n3 = R2(n3), L3(function(t) {
          return nu(t, n3);
        });
      }
      var eg = ci(G3), rg = ci(As2), ig = ci(Nr);
      function ma(n3) {
        return _i(n3) ? $r(Wn(n3)) : Hc(n3);
      }
      function sg(n3) {
        return function(t) {
          return n3 == null ? i3 : _t2(n3, t);
        };
      }
      var ug = Cu(), ag = Cu(true);
      function Hi2() {
        return [];
      }
      function Ni2() {
        return false;
      }
      function og() {
        return {};
      }
      function fg() {
        return "";
      }
      function cg() {
        return true;
      }
      function hg(n3, t) {
        if (n3 = R2(n3), n3 < 1 || n3 > kn2)
          return [];
        var e = Nn, r = nn(n3, Nn);
        t = x3(t), n3 -= Nn;
        for (var s2 = Fr(r, t); ++e < n3; )
          t(e);
        return s2;
      }
      function lg(n3) {
        return O6(n3) ? G3(n3, Wn) : pn(n3) ? [n3] : un2(Wu(W3(n3)));
      }
      function pg(n3) {
        var t = ++xf;
        return W3(n3) + t;
      }
      var dg = Qe2(function(n3, t) {
        return n3 + t;
      }, 0), gg = hi("ceil"), vg = Qe2(function(n3, t) {
        return n3 / t;
      }, 1), _g = hi("floor");
      function mg(n3) {
        return n3 && n3.length ? Ge2(n3, fn, Qr) : i3;
      }
      function wg(n3, t) {
        return n3 && n3.length ? Ge2(n3, x3(t, 2), Qr) : i3;
      }
      function Pg(n3) {
        return xs2(n3, fn);
      }
      function Ag(n3, t) {
        return xs2(n3, x3(t, 2));
      }
      function Cg(n3) {
        return n3 && n3.length ? Ge2(n3, fn, ni) : i3;
      }
      function Ig(n3, t) {
        return n3 && n3.length ? Ge2(n3, x3(t, 2), ni) : i3;
      }
      var xg = Qe2(function(n3, t) {
        return n3 * t;
      }, 1), Eg = hi("round"), yg = Qe2(function(n3, t) {
        return n3 - t;
      }, 0);
      function Sg(n3) {
        return n3 && n3.length ? Wr(n3, fn) : 0;
      }
      function Og(n3, t) {
        return n3 && n3.length ? Wr(n3, x3(t, 2)) : 0;
      }
      return a2.after = Ql, a2.ary = Xu, a2.assign = Up, a2.assignIn = fa, a2.assignInWith = fr2, a2.assignWith = Wp, a2.at = Fp, a2.before = Qu, a2.bind = Ii, a2.bindAll = zd, a2.bindKey = Vu, a2.castArray = op, a2.chain = Yu, a2.chunk = _h, a2.compact = mh, a2.concat = wh, a2.cond = Kd, a2.conforms = Yd, a2.constant = bi, a2.countBy = Sl, a2.create = Mp, a2.curry = ku, a2.curryRight = ju, a2.debounce = na, a2.defaults = qp, a2.defaultsDeep = Bp, a2.defer = Vl, a2.delay = kl, a2.difference = Ph, a2.differenceBy = Ah, a2.differenceWith = Ch, a2.drop = Ih, a2.dropRight = xh, a2.dropRightWhile = Eh, a2.dropWhile = yh, a2.fill = Sh, a2.filter = Rl, a2.flatMap = Ll, a2.flatMapDeep = Dl, a2.flatMapDepth = Hl, a2.flatten = Bu, a2.flattenDeep = Oh, a2.flattenDepth = Rh, a2.flip = jl, a2.flow = Jd, a2.flowRight = Xd, a2.fromPairs = bh, a2.functions = Xp, a2.functionsIn = Qp, a2.groupBy = Nl, a2.initial = Lh, a2.intersection = Dh, a2.intersectionBy = Hh, a2.intersectionWith = Nh, a2.invert = kp, a2.invertBy = jp, a2.invokeMap = Ul, a2.iteratee = Ti, a2.keyBy = Wl, a2.keys = V3, a2.keysIn = on, a2.map = rr2, a2.mapKeys = td, a2.mapValues = ed, a2.matches = Qd, a2.matchesProperty = Vd, a2.memoize = sr2, a2.merge = rd, a2.mergeWith = ca, a2.method = kd, a2.methodOf = jd, a2.mixin = Li, a2.negate = ur2, a2.nthArg = tg, a2.omit = id, a2.omitBy = sd, a2.once = np, a2.orderBy = Fl, a2.over = eg, a2.overArgs = tp, a2.overEvery = rg, a2.overSome = ig, a2.partial = xi, a2.partialRight = ta, a2.partition = Ml, a2.pick = ud, a2.pickBy = ha, a2.property = ma, a2.propertyOf = sg, a2.pull = Fh, a2.pullAll = zu, a2.pullAllBy = Mh, a2.pullAllWith = qh, a2.pullAt = Bh, a2.range = ug, a2.rangeRight = ag, a2.rearg = ep, a2.reject = Gl, a2.remove = Gh, a2.rest = rp, a2.reverse = Ai2, a2.sampleSize = Kl, a2.set = od, a2.setWith = fd, a2.shuffle = Yl, a2.slice = zh, a2.sortBy = Xl, a2.sortedUniq = Vh, a2.sortedUniqBy = kh, a2.split = Ld, a2.spread = ip, a2.tail = jh, a2.take = nl, a2.takeRight = tl, a2.takeRightWhile = el, a2.takeWhile = rl, a2.tap = ml, a2.throttle = sp, a2.thru = er3, a2.toArray = ua, a2.toPairs = la, a2.toPairsIn = pa, a2.toPath = lg, a2.toPlainObject = oa, a2.transform = cd, a2.unary = up, a2.union = il, a2.unionBy = sl, a2.unionWith = ul, a2.uniq = al, a2.uniqBy = ol, a2.uniqWith = fl, a2.unset = hd, a2.unzip = Ci, a2.unzipWith = Ku, a2.update = ld, a2.updateWith = pd, a2.values = Gt3, a2.valuesIn = dd, a2.without = cl, a2.words = va, a2.wrap = ap, a2.xor = hl, a2.xorBy = ll, a2.xorWith = pl, a2.zip = dl, a2.zipObject = gl, a2.zipObjectDeep = vl, a2.zipWith = _l, a2.entries = la, a2.entriesIn = pa, a2.extend = fa, a2.extendWith = fr2, Li(a2, a2), a2.add = dg, a2.attempt = _a, a2.camelCase = md, a2.capitalize = da, a2.ceil = gg, a2.clamp = gd, a2.clone = fp, a2.cloneDeep = hp, a2.cloneDeepWith = lp, a2.cloneWith = cp, a2.conformsTo = pp, a2.deburr = ga, a2.defaultTo = Zd, a2.divide = vg, a2.endsWith = wd, a2.eq = bn, a2.escape = Pd, a2.escapeRegExp = Ad, a2.every = Ol, a2.find = bl, a2.findIndex = Mu, a2.findKey = Gp, a2.findLast = Tl, a2.findLastIndex = qu, a2.findLastKey = zp, a2.floor = _g, a2.forEach = Zu, a2.forEachRight = Ju, a2.forIn = Kp, a2.forInRight = Yp, a2.forOwn = Zp, a2.forOwnRight = Jp, a2.get = Si, a2.gt = dp, a2.gte = gp, a2.has = Vp, a2.hasIn = Oi, a2.head = Gu, a2.identity = fn, a2.includes = $l, a2.indexOf = Th, a2.inRange = vd, a2.invoke = nd, a2.isArguments = Pt2, a2.isArray = O6, a2.isArrayBuffer = vp, a2.isArrayLike = an2, a2.isArrayLikeObject = Z2, a2.isBoolean = _p, a2.isBuffer = at3, a2.isDate = mp, a2.isElement = wp, a2.isEmpty = Pp, a2.isEqual = Ap, a2.isEqualWith = Cp, a2.isError = Ei, a2.isFinite = Ip, a2.isFunction = Jn2, a2.isInteger = ea, a2.isLength = ar2, a2.isMap = ra, a2.isMatch = xp, a2.isMatchWith = Ep, a2.isNaN = yp, a2.isNative = Sp, a2.isNil = Rp, a2.isNull = Op, a2.isNumber = ia, a2.isObject = K3, a2.isObjectLike = Y, a2.isPlainObject = pe3, a2.isRegExp = yi, a2.isSafeInteger = bp, a2.isSet = sa, a2.isString = or2, a2.isSymbol = pn, a2.isTypedArray = Bt3, a2.isUndefined = Tp, a2.isWeakMap = Lp, a2.isWeakSet = Dp, a2.join = $h, a2.kebabCase = Cd, a2.last = In, a2.lastIndexOf = Uh, a2.lowerCase = Id, a2.lowerFirst = xd, a2.lt = Hp, a2.lte = Np, a2.max = mg, a2.maxBy = wg, a2.mean = Pg, a2.meanBy = Ag, a2.min = Cg, a2.minBy = Ig, a2.stubArray = Hi2, a2.stubFalse = Ni2, a2.stubObject = og, a2.stubString = fg, a2.stubTrue = cg, a2.multiply = xg, a2.nth = Wh, a2.noConflict = ng, a2.noop = Di, a2.now = ir2, a2.pad = Ed, a2.padEnd = yd, a2.padStart = Sd, a2.parseInt = Od, a2.random = _d, a2.reduce = ql, a2.reduceRight = Bl, a2.repeat = Rd, a2.replace = bd, a2.result = ad, a2.round = Eg, a2.runInContext = h5, a2.sample = zl, a2.size = Zl, a2.snakeCase = Td, a2.some = Jl, a2.sortedIndex = Kh, a2.sortedIndexBy = Yh, a2.sortedIndexOf = Zh, a2.sortedLastIndex = Jh, a2.sortedLastIndexBy = Xh, a2.sortedLastIndexOf = Qh, a2.startCase = Dd, a2.startsWith = Hd, a2.subtract = yg, a2.sum = Sg, a2.sumBy = Og, a2.template = Nd, a2.times = hg, a2.toFinite = Xn, a2.toInteger = R2, a2.toLength = aa, a2.toLower = $d, a2.toNumber = xn2, a2.toSafeInteger = $p, a2.toString = W3, a2.toUpper = Ud, a2.trim = Wd, a2.trimEnd = Fd, a2.trimStart = Md, a2.truncate = qd, a2.unescape = Bd, a2.uniqueId = pg, a2.upperCase = Gd, a2.upperFirst = Ri, a2.each = Zu, a2.eachRight = Ju, a2.first = Gu, Li(a2, function() {
        var n3 = {};
        return $n(a2, function(t, e) {
          F3.call(a2.prototype, e) || (n3[e] = t);
        }), n3;
      }(), { chain: false }), a2.VERSION = d3, mn(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(n3) {
        a2[n3].placeholder = a2;
      }), mn(["drop", "take"], function(n3, t) {
        H2.prototype[n3] = function(e) {
          e = e === i3 ? 1 : Q4(R2(e), 0);
          var r = this.__filtered__ && !t ? new H2(this) : this.clone();
          return r.__filtered__ ? r.__takeCount__ = nn(e, r.__takeCount__) : r.__views__.push({ size: nn(e, Nn), type: n3 + (r.__dir__ < 0 ? "Right" : "") }), r;
        }, H2.prototype[n3 + "Right"] = function(e) {
          return this.reverse()[n3](e).reverse();
        };
      }), mn(["filter", "map", "takeWhile"], function(n3, t) {
        var e = t + 1, r = e == Bi2 || e == Ua;
        H2.prototype[n3] = function(s2) {
          var o = this.clone();
          return o.__iteratees__.push({ iteratee: x3(s2, 3), type: e }), o.__filtered__ = o.__filtered__ || r, o;
        };
      }), mn(["head", "last"], function(n3, t) {
        var e = "take" + (t ? "Right" : "");
        H2.prototype[n3] = function() {
          return this[e](1).value()[0];
        };
      }), mn(["initial", "tail"], function(n3, t) {
        var e = "drop" + (t ? "" : "Right");
        H2.prototype[n3] = function() {
          return this.__filtered__ ? new H2(this) : this[e](1);
        };
      }), H2.prototype.compact = function() {
        return this.filter(fn);
      }, H2.prototype.find = function(n3) {
        return this.filter(n3).head();
      }, H2.prototype.findLast = function(n3) {
        return this.reverse().find(n3);
      }, H2.prototype.invokeMap = L3(function(n3, t) {
        return typeof n3 == "function" ? new H2(this) : this.map(function(e) {
          return ae2(e, n3, t);
        });
      }), H2.prototype.reject = function(n3) {
        return this.filter(ur2(x3(n3)));
      }, H2.prototype.slice = function(n3, t) {
        n3 = R2(n3);
        var e = this;
        return e.__filtered__ && (n3 > 0 || t < 0) ? new H2(e) : (n3 < 0 ? e = e.takeRight(-n3) : n3 && (e = e.drop(n3)), t !== i3 && (t = R2(t), e = t < 0 ? e.dropRight(-t) : e.take(t - n3)), e);
      }, H2.prototype.takeRightWhile = function(n3) {
        return this.reverse().takeWhile(n3).reverse();
      }, H2.prototype.toArray = function() {
        return this.take(Nn);
      }, $n(H2.prototype, function(n3, t) {
        var e = /^(?:filter|find|map|reject)|While$/.test(t), r = /^(?:head|last)$/.test(t), s2 = a2[r ? "take" + (t == "last" ? "Right" : "") : t], o = r || /^find/.test(t);
        s2 && (a2.prototype[t] = function() {
          var f3 = this.__wrapped__, c4 = r ? [1] : arguments, l3 = f3 instanceof H2, v4 = c4[0], _5 = l3 || O6(f3), m2 = function(D5) {
            var N5 = s2.apply(a2, nt3([D5], c4));
            return r && P2 ? N5[0] : N5;
          };
          _5 && e && typeof v4 == "function" && v4.length != 1 && (l3 = _5 = false);
          var P2 = this.__chain__, I2 = !!this.__actions__.length, E5 = o && !P2, b5 = l3 && !I2;
          if (!o && _5) {
            f3 = b5 ? f3 : new H2(this);
            var y6 = n3.apply(f3, c4);
            return y6.__actions__.push({ func: er3, args: [m2], thisArg: i3 }), new Pn(y6, P2);
          }
          return E5 && b5 ? n3.apply(this, c4) : (y6 = this.thru(m2), E5 ? r ? y6.value()[0] : y6.value() : y6);
        });
      }), mn(["pop", "push", "shift", "sort", "splice", "unshift"], function(n3) {
        var t = Oe[n3], e = /^(?:push|sort|unshift)$/.test(n3) ? "tap" : "thru", r = /^(?:pop|shift)$/.test(n3);
        a2.prototype[n3] = function() {
          var s2 = arguments;
          if (r && !this.__chain__) {
            var o = this.value();
            return t.apply(O6(o) ? o : [], s2);
          }
          return this[e](function(f3) {
            return t.apply(O6(f3) ? f3 : [], s2);
          });
        };
      }), $n(H2.prototype, function(n3, t) {
        var e = a2[t];
        if (e) {
          var r = e.name + "";
          F3.call(Ut2, r) || (Ut2[r] = []), Ut2[r].push({ name: t, func: e });
        }
      }), Ut2[Xe3(i3, ct3).name] = [{ name: "wrapper", func: i3 }], H2.prototype.clone = Bf, H2.prototype.reverse = Gf, H2.prototype.value = zf, a2.prototype.at = wl, a2.prototype.chain = Pl, a2.prototype.commit = Al, a2.prototype.next = Cl, a2.prototype.plant = xl, a2.prototype.reverse = El, a2.prototype.toJSON = a2.prototype.valueOf = a2.prototype.value = yl, a2.prototype.first = a2.prototype.head, ne2 && (a2.prototype[ne2] = Il), a2;
    }, Ht2 = Af();
    lt3 ? ((lt3.exports = Ht2)._ = Ht2, Tr2._ = Ht2) : k3._ = Ht2;
  }).call(ge2);
})(Ui, Ui.exports);
var qg = Object.defineProperty;
var Bg = Object.defineProperties;
var Gg = Object.getOwnPropertyDescriptors;
var Ea = Object.getOwnPropertySymbols;
var zg = Object.prototype.hasOwnProperty;
var Kg = Object.prototype.propertyIsEnumerable;
var ya = (C, u3, i3) => u3 in C ? qg(C, u3, { enumerable: true, configurable: true, writable: true, value: i3 }) : C[u3] = i3;
var cr2 = (C, u3) => {
  for (var i3 in u3 || (u3 = {}))
    zg.call(u3, i3) && ya(C, i3, u3[i3]);
  if (Ea)
    for (var i3 of Ea(u3))
      Kg.call(u3, i3) && ya(C, i3, u3[i3]);
  return C;
};
var Yg = (C, u3) => Bg(C, Gg(u3));
function ft3(C, u3, i3) {
  var d3;
  const w4 = ve(C);
  return ((d3 = u3.rpcMap) == null ? void 0 : d3[w4.reference]) || `${Mg}?chainId=${w4.namespace}:${w4.reference}&projectId=${i3}`;
}
function Ct2(C) {
  return C.includes(":") ? C.split(":")[1] : C;
}
function Sa(C) {
  return C.map((u3) => `${u3.split(":")[0]}:${u3.split(":")[1]}`);
}
function Zg(C, u3) {
  const i3 = Object.keys(u3.namespaces).filter((w4) => w4.includes(C));
  if (!i3.length)
    return [];
  const d3 = [];
  return i3.forEach((w4) => {
    const T3 = u3.namespaces[w4].accounts;
    d3.push(...T3);
  }), d3;
}
function Jg(C = {}, u3 = {}) {
  const i3 = Oa(C), d3 = Oa(u3);
  return Ui.exports.merge(i3, d3);
}
function Oa(C) {
  var u3, i3, d3, w4;
  const T3 = {};
  if (!B(C))
    return T3;
  for (const [$3, En] of Object.entries(C)) {
    const zt3 = oe($3) ? [$3] : En.chains, pr = En.methods || [], It2 = En.events || [], Ln2 = En.rpcMap || {}, Fn2 = Xe($3);
    T3[Fn2] = Yg(cr2(cr2({}, T3[Fn2]), En), { chains: S(zt3, (u3 = T3[Fn2]) == null ? void 0 : u3.chains), methods: S(pr, (i3 = T3[Fn2]) == null ? void 0 : i3.methods), events: S(It2, (d3 = T3[Fn2]) == null ? void 0 : d3.events), rpcMap: cr2(cr2({}, Ln2), (w4 = T3[Fn2]) == null ? void 0 : w4.rpcMap) });
  }
  return T3;
}
function Xg(C) {
  return C.includes(":") ? C.split(":")[2] : C;
}
function Qg(C) {
  const u3 = {};
  for (const [i3, d3] of Object.entries(C)) {
    const w4 = d3.methods || [], T3 = d3.events || [], $3 = d3.accounts || [], En = oe(i3) ? [i3] : d3.chains ? d3.chains : Sa(d3.accounts);
    u3[i3] = { chains: En, methods: w4, events: T3, accounts: $3 };
  }
  return u3;
}
function Wi2(C) {
  return typeof C == "number" ? C : C.includes("0x") ? parseInt(C, 16) : C.includes(":") ? Number(C.split(":")[1]) : Number(C);
}
var Ra = {};
var z3 = (C) => Ra[C];
var Fi = (C, u3) => {
  Ra[C] = u3;
};
var Vg = class {
  constructor(u3) {
    this.name = "polkadot", this.namespace = u3.namespace, this.events = z3("events"), this.client = z3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u3}`);
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const w4 = Ct2(i3);
      u3[w4] = this.createHttpProvider(w4, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft3(u3, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new esm_default(d3, z3("disableProviderPing")));
  }
};
var kg = class {
  constructor(u3) {
    this.name = "eip155", this.namespace = u3.namespace, this.events = z3("events"), this.client = z3("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(u3) {
    switch (u3.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(u3);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
    }
    return this.namespace.methods.includes(u3.request.method) ? await this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(parseInt(u3), i3), this.chainId = parseInt(u3), this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u3}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId.toString();
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft3(`${this.name}:${u3}`, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new HttpConnection(d3, z3("disableProviderPing")));
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const w4 = parseInt(Ct2(i3));
      u3[w4] = this.createHttpProvider(w4, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const u3 = this.chainId, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  async handleSwitchChain(u3) {
    var i3, d3;
    let w4 = u3.request.params ? (i3 = u3.request.params[0]) == null ? void 0 : i3.chainId : "0x0";
    w4 = w4.startsWith("0x") ? w4 : `0x${w4}`;
    const T3 = parseInt(w4, 16);
    if (this.isChainApproved(T3))
      this.setDefaultChain(`${T3}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
      await this.client.request({ topic: u3.topic, request: { method: u3.request.method, params: [{ chainId: w4 }] }, chainId: (d3 = this.namespace.chains) == null ? void 0 : d3[0] }), this.setDefaultChain(`${T3}`);
    else
      throw new Error(`Failed to switch to chain 'eip155:${T3}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(u3) {
    return this.namespace.chains.includes(`${this.name}:${u3}`);
  }
};
var jg = class {
  constructor(u3) {
    this.name = "solana", this.namespace = u3.namespace, this.events = z3("events"), this.client = z3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u3}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const w4 = Ct2(i3);
      u3[w4] = this.createHttpProvider(w4, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft3(u3, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new esm_default(d3, z3("disableProviderPing")));
  }
};
var nv = class {
  constructor(u3) {
    this.name = "cosmos", this.namespace = u3.namespace, this.events = z3("events"), this.client = z3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const w4 = Ct2(i3);
      u3[w4] = this.createHttpProvider(w4, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft3(u3, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new esm_default(d3, z3("disableProviderPing")));
  }
};
var tv = class {
  constructor(u3) {
    this.name = "cip34", this.namespace = u3.namespace, this.events = z3("events"), this.client = z3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      const d3 = this.getCardanoRPCUrl(i3), w4 = Ct2(i3);
      u3[w4] = this.createHttpProvider(w4, d3);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  getCardanoRPCUrl(u3) {
    const i3 = this.namespace.rpcMap;
    if (i3)
      return i3[u3];
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || this.getCardanoRPCUrl(u3);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new esm_default(d3, z3("disableProviderPing")));
  }
};
var ev = class {
  constructor(u3) {
    this.name = "elrond", this.namespace = u3.namespace, this.events = z3("events"), this.client = z3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u3}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const w4 = Ct2(i3);
      u3[w4] = this.createHttpProvider(w4, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft3(u3, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new esm_default(d3, z3("disableProviderPing")));
  }
};
var rv = class {
  constructor(u3) {
    this.name = "multiversx", this.namespace = u3.namespace, this.events = z3("events"), this.client = z3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    this.httpProviders[u3] || this.setHttpProvider(u3, i3), this.chainId = u3, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u3}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? [...new Set(u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      const w4 = Ct2(i3);
      u3[w4] = this.createHttpProvider(w4, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft3(u3, this.namespace, this.client.core.projectId);
    if (!d3)
      throw new Error(`No RPC url provided for chainId: ${u3}`);
    return new JsonRpcProvider(new esm_default(d3, z3("disableProviderPing")));
  }
};
var iv = class {
  constructor(u3) {
    this.name = "near", this.namespace = u3.namespace, this.events = z3("events"), this.client = z3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u3) {
    this.namespace = Object.assign(this.namespace, u3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u3 = this.namespace.chains[0];
    if (!u3)
      throw new Error("ChainId not found");
    return u3.split(":")[1];
  }
  request(u3) {
    return this.namespace.methods.includes(u3.request.method) ? this.client.request(u3) : this.getHttpProvider().request(u3.request);
  }
  setDefaultChain(u3, i3) {
    if (this.chainId = u3, !this.httpProviders[u3]) {
      const d3 = i3 || ft3(`${this.name}:${u3}`, this.namespace);
      if (!d3)
        throw new Error(`No RPC url provided for chainId: ${u3}`);
      this.setHttpProvider(u3, d3);
    }
    this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const u3 = this.namespace.accounts;
    return u3 ? u3.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const u3 = {};
    return this.namespace.chains.forEach((i3) => {
      var d3;
      u3[i3] = this.createHttpProvider(i3, (d3 = this.namespace.rpcMap) == null ? void 0 : d3[i3]);
    }), u3;
  }
  getHttpProvider() {
    const u3 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[u3];
    if (typeof i3 > "u")
      throw new Error(`JSON-RPC provider for ${u3} not found`);
    return i3;
  }
  setHttpProvider(u3, i3) {
    const d3 = this.createHttpProvider(u3, i3);
    d3 && (this.httpProviders[u3] = d3);
  }
  createHttpProvider(u3, i3) {
    const d3 = i3 || ft3(u3, this.namespace);
    return typeof d3 > "u" ? void 0 : new JsonRpcProvider(new esm_default(d3, z3("disableProviderPing")));
  }
};
var sv = Object.defineProperty;
var uv = Object.defineProperties;
var av = Object.getOwnPropertyDescriptors;
var ba = Object.getOwnPropertySymbols;
var ov = Object.prototype.hasOwnProperty;
var fv = Object.prototype.propertyIsEnumerable;
var Ta = (C, u3, i3) => u3 in C ? sv(C, u3, { enumerable: true, configurable: true, writable: true, value: i3 }) : C[u3] = i3;
var hr2 = (C, u3) => {
  for (var i3 in u3 || (u3 = {}))
    ov.call(u3, i3) && Ta(C, i3, u3[i3]);
  if (ba)
    for (var i3 of ba(u3))
      fv.call(u3, i3) && Ta(C, i3, u3[i3]);
  return C;
};
var Mi = (C, u3) => uv(C, av(u3));
var lr = class _lr {
  constructor(u3) {
    this.events = new import_events6.default(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = false, this.maxPairingAttempts = 10, this.disableProviderPing = false, this.providerOpts = u3, this.logger = typeof (u3 == null ? void 0 : u3.logger) < "u" && typeof (u3 == null ? void 0 : u3.logger) != "string" ? u3.logger : (0, import_pino2.default)(k2({ level: (u3 == null ? void 0 : u3.logger) || Ia })), this.disableProviderPing = (u3 == null ? void 0 : u3.disableProviderPing) || false;
  }
  static async init(u3) {
    const i3 = new _lr(u3);
    return await i3.initialize(), i3;
  }
  async request(u3, i3) {
    const [d3, w4] = this.validateChain(i3);
    if (!this.session)
      throw new Error("Please call connect() before request()");
    return await this.getProvider(d3).request({ request: hr2({}, u3), chainId: `${d3}:${w4}`, topic: this.session.topic });
  }
  sendAsync(u3, i3, d3) {
    this.request(u3, d3).then((w4) => i3(null, w4)).catch((w4) => i3(w4, void 0));
  }
  async enable() {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var u3;
    if (!this.session)
      throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (u3 = this.session) == null ? void 0 : u3.topic, reason: U("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(u3) {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    if (this.setNamespaces(u3), await this.cleanupPendingPairings(), !u3.skipPairing)
      return await this.pair(u3.pairingTopic);
  }
  on(u3, i3) {
    this.events.on(u3, i3);
  }
  once(u3, i3) {
    this.events.once(u3, i3);
  }
  removeListener(u3, i3) {
    this.events.removeListener(u3, i3);
  }
  off(u3, i3) {
    this.events.off(u3, i3);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(u3) {
    this.shouldAbortPairingAttempt = false;
    let i3 = 0;
    do {
      if (this.shouldAbortPairingAttempt)
        throw new Error("Pairing aborted");
      if (i3 >= this.maxPairingAttempts)
        throw new Error("Max auto pairing attempts reached");
      const { uri: d3, approval: w4 } = await this.client.connect({ pairingTopic: u3, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      d3 && (this.uri = d3, this.events.emit("display_uri", d3)), await w4().then((T3) => {
        this.session = T3, this.namespaces || (this.namespaces = Qg(T3.namespaces), this.persist("namespaces", this.namespaces));
      }).catch((T3) => {
        if (T3.message !== oe3)
          throw T3;
        i3++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(u3, i3) {
    try {
      if (!this.session)
        return;
      const [d3, w4] = this.validateChain(u3);
      this.getProvider(d3).setDefaultChain(w4, i3);
    } catch (d3) {
      if (!/Please call connect/.test(d3.message))
        throw d3;
    }
  }
  async cleanupPendingPairings(u3 = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const i3 = this.client.pairing.getAll();
    if (D(i3)) {
      for (const d3 of i3)
        u3.deletePairings ? this.client.core.expirer.set(d3.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(d3.topic);
      this.logger.info(`Inactive pairings cleared: ${i3.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = true;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const u3 = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[u3]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await Q2.init({ logger: this.providerOpts.logger || Ia, relayUrl: this.providerOpts.relayUrl || Ug, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    if (!this.session)
      throw new Error("Session not initialized. Please call connect() before enable()");
    const u3 = [...new Set(Object.keys(this.session.namespaces).map((i3) => Xe(i3)))];
    Fi("client", this.client), Fi("events", this.events), Fi("disableProviderPing", this.disableProviderPing), u3.forEach((i3) => {
      if (!this.session)
        return;
      const d3 = Zg(i3, this.session), w4 = Sa(d3), T3 = Jg(this.namespaces, this.optionalNamespaces), $3 = Mi(hr2({}, T3[i3]), { accounts: d3, chains: w4 });
      switch (i3) {
        case "eip155":
          this.rpcProviders[i3] = new kg({ namespace: $3 });
          break;
        case "solana":
          this.rpcProviders[i3] = new jg({ namespace: $3 });
          break;
        case "cosmos":
          this.rpcProviders[i3] = new nv({ namespace: $3 });
          break;
        case "polkadot":
          this.rpcProviders[i3] = new Vg({ namespace: $3 });
          break;
        case "cip34":
          this.rpcProviders[i3] = new tv({ namespace: $3 });
          break;
        case "elrond":
          this.rpcProviders[i3] = new ev({ namespace: $3 });
          break;
        case "multiversx":
          this.rpcProviders[i3] = new rv({ namespace: $3 });
          break;
        case "near":
          this.rpcProviders[i3] = new iv({ namespace: $3 });
          break;
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u")
      throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (u3) => {
      this.events.emit("session_ping", u3);
    }), this.client.on("session_event", (u3) => {
      const { params: i3 } = u3, { event: d3 } = i3;
      if (d3.name === "accountsChanged") {
        const w4 = d3.data;
        w4 && D(w4) && this.events.emit("accountsChanged", w4.map(Xg));
      } else if (d3.name === "chainChanged") {
        const w4 = i3.chainId, T3 = i3.event.data, $3 = Xe(w4), En = Wi2(w4) !== Wi2(T3) ? `${$3}:${Wi2(T3)}` : w4;
        this.onChainChanged(En);
      } else
        this.events.emit(d3.name, d3.data);
      this.events.emit("session_event", u3);
    }), this.client.on("session_update", ({ topic: u3, params: i3 }) => {
      var d3;
      const { namespaces: w4 } = i3, T3 = (d3 = this.client) == null ? void 0 : d3.session.get(u3);
      this.session = Mi(hr2({}, T3), { namespaces: w4 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: u3, params: i3 });
    }), this.client.on("session_delete", async (u3) => {
      await this.cleanup(), this.events.emit("session_delete", u3), this.events.emit("disconnect", Mi(hr2({}, U("USER_DISCONNECTED")), { data: u3.topic }));
    }), this.on(Vn2.DEFAULT_CHAIN_CHANGED, (u3) => {
      this.onChainChanged(u3, true);
    });
  }
  getProvider(u3) {
    if (!this.rpcProviders[u3])
      throw new Error(`Provider not found: ${u3}`);
    return this.rpcProviders[u3];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((u3) => {
      var i3;
      this.getProvider(u3).updateNamespace((i3 = this.session) == null ? void 0 : i3.namespaces[u3]);
    });
  }
  setNamespaces(u3) {
    const { namespaces: i3, optionalNamespaces: d3, sessionProperties: w4 } = u3;
    i3 && Object.keys(i3).length && (this.namespaces = i3), d3 && Object.keys(d3).length && (this.optionalNamespaces = d3), this.sessionProperties = w4, this.persist("namespaces", i3), this.persist("optionalNamespaces", d3);
  }
  validateChain(u3) {
    const [i3, d3] = (u3 == null ? void 0 : u3.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length)
      return [i3, d3];
    if (i3 && !Object.keys(this.namespaces || {}).map(($3) => Xe($3)).includes(i3))
      throw new Error(`Namespace '${i3}' is not configured. Please call connect() first with namespace config.`);
    if (i3 && d3)
      return [i3, d3];
    const w4 = Xe(Object.keys(this.namespaces)[0]), T3 = this.rpcProviders[w4].getDefaultChain();
    return [w4, T3];
  }
  async requestAccounts() {
    const [u3] = this.validateChain();
    return await this.getProvider(u3).requestAccounts();
  }
  onChainChanged(u3, i3 = false) {
    var d3;
    if (!this.namespaces)
      return;
    const [w4, T3] = this.validateChain(u3);
    i3 || this.getProvider(w4).setDefaultChain(T3), ((d3 = this.namespaces[w4]) != null ? d3 : this.namespaces[`${w4}:${T3}`]).defaultChain = T3, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", T3);
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: true });
  }
  persist(u3, i3) {
    this.client.core.storage.setItem(`${xa}/${u3}`, i3);
  }
  async getFromStore(u3) {
    return await this.client.core.storage.getItem(`${xa}/${u3}`);
  }
};
var cv = lr;

// node_modules/.pnpm/@walletconnect+ethereum-provider@2.10.2_@walletconnect+modal@2.6.2/node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var P = "wc";
var S4 = "ethereum_provider";
var $2 = `${P}@2:${S4}:`;
var j4 = "https://rpc.walletconnect.com/v1/";
var u2 = ["eth_sendTransaction", "personal_sign"];
var E4 = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"];
var m = ["chainChanged", "accountsChanged"];
var _4 = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var N4 = Object.defineProperty;
var q2 = Object.defineProperties;
var D4 = Object.getOwnPropertyDescriptors;
var y5 = Object.getOwnPropertySymbols;
var U5 = Object.prototype.hasOwnProperty;
var Q3 = Object.prototype.propertyIsEnumerable;
var O5 = (a2, t, s2) => t in a2 ? N4(a2, t, { enumerable: true, configurable: true, writable: true, value: s2 }) : a2[t] = s2;
var p4 = (a2, t) => {
  for (var s2 in t || (t = {}))
    U5.call(t, s2) && O5(a2, s2, t[s2]);
  if (y5)
    for (var s2 of y5(t))
      Q3.call(t, s2) && O5(a2, s2, t[s2]);
  return a2;
};
var M2 = (a2, t) => q2(a2, D4(t));
function g5(a2) {
  return Number(a2[0].split(":")[1]);
}
function f2(a2) {
  return `0x${a2.toString(16)}`;
}
function L2(a2) {
  const { chains: t, optionalChains: s2, methods: i3, optionalMethods: n3, events: e, optionalEvents: h5, rpcMap: c4 } = a2;
  if (!D(t))
    throw new Error("Invalid chains");
  const o = { chains: t, methods: i3 || u2, events: e || m, rpcMap: p4({}, t.length ? { [g5(t)]: c4[g5(t)] } : {}) }, r = e == null ? void 0 : e.filter((l3) => !m.includes(l3)), d3 = i3 == null ? void 0 : i3.filter((l3) => !u2.includes(l3));
  if (!s2 && !h5 && !n3 && !(r != null && r.length) && !(d3 != null && d3.length))
    return { required: t.length ? o : void 0 };
  const C = (r == null ? void 0 : r.length) && (d3 == null ? void 0 : d3.length) || !s2, I2 = { chains: [...new Set(C ? o.chains.concat(s2 || []) : s2)], methods: [...new Set(o.methods.concat(n3 != null && n3.length ? n3 : E4))], events: [...new Set(o.events.concat(h5 != null && h5.length ? h5 : _4))], rpcMap: c4 };
  return { required: t.length ? o : void 0, optional: s2.length ? I2 : void 0 };
}
var v3 = class _v {
  constructor() {
    this.events = new import_events7.EventEmitter(), this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = $2, this.on = (t, s2) => (this.events.on(t, s2), this), this.once = (t, s2) => (this.events.once(t, s2), this), this.removeListener = (t, s2) => (this.events.removeListener(t, s2), this), this.off = (t, s2) => (this.events.off(t, s2), this), this.parseAccount = (t) => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t, this.signer = {}, this.rpc = {};
  }
  static async init(t) {
    const s2 = new _v();
    return await s2.initialize(t), s2;
  }
  async request(t) {
    return await this.signer.request(t, this.formatChainId(this.chainId));
  }
  sendAsync(t, s2) {
    this.signer.sendAsync(t, s2, this.formatChainId(this.chainId));
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : false;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : false;
  }
  async enable() {
    return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
  }
  async connect(t) {
    if (!this.signer.client)
      throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(t);
    const { required: s2, optional: i3 } = L2(this.rpc);
    try {
      const n3 = await new Promise(async (h5, c4) => {
        var o;
        this.rpc.showQrModal && ((o = this.modal) == null || o.subscribeModal((r) => {
          !r.open && !this.signer.session && (this.signer.abortPairingAttempt(), c4(new Error("Connection request reset. Please try again.")));
        })), await this.signer.connect(M2(p4({ namespaces: p4({}, s2 && { [this.namespace]: s2 }) }, i3 && { optionalNamespaces: { [this.namespace]: i3 } }), { pairingTopic: t == null ? void 0 : t.pairingTopic })).then((r) => {
          h5(r);
        }).catch((r) => {
          c4(new Error(r.message));
        });
      });
      if (!n3)
        return;
      const e = Rn(n3.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : e), this.setAccounts(e), this.events.emit("connect", { chainId: f2(this.chainId) });
    } catch (n3) {
      throw this.signer.logger.error(n3), n3;
    } finally {
      this.modal && this.modal.closeModal();
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset();
  }
  get isWalletConnect() {
    return true;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (t) => {
      const { params: s2 } = t, { event: i3 } = s2;
      i3.name === "accountsChanged" ? (this.accounts = this.parseAccounts(i3.data), this.events.emit("accountsChanged", this.accounts)) : i3.name === "chainChanged" ? this.setChainId(this.formatChainId(i3.data)) : this.events.emit(i3.name, i3.data), this.events.emit("session_event", t);
    }), this.signer.on("chainChanged", (t) => {
      const s2 = parseInt(t);
      this.chainId = s2, this.events.emit("chainChanged", f2(this.chainId)), this.persist();
    }), this.signer.on("session_update", (t) => {
      this.events.emit("session_update", t);
    }), this.signer.on("session_delete", (t) => {
      this.reset(), this.events.emit("session_delete", t), this.events.emit("disconnect", M2(p4({}, U("USER_DISCONNECTED")), { data: t.topic, name: "USER_DISCONNECTED" }));
    }), this.signer.on("display_uri", (t) => {
      var s2, i3;
      this.rpc.showQrModal && ((s2 = this.modal) == null || s2.closeModal(), (i3 = this.modal) == null || i3.openModal({ uri: t })), this.events.emit("display_uri", t);
    });
  }
  switchEthereumChain(t) {
    this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t.toString(16) }] });
  }
  isCompatibleChainId(t) {
    return typeof t == "string" ? t.startsWith(`${this.namespace}:`) : false;
  }
  formatChainId(t) {
    return `${this.namespace}:${t}`;
  }
  parseChainId(t) {
    return Number(t.split(":")[1]);
  }
  setChainIds(t) {
    const s2 = t.filter((i3) => this.isCompatibleChainId(i3)).map((i3) => this.parseChainId(i3));
    s2.length && (this.chainId = s2[0], this.events.emit("chainChanged", f2(this.chainId)), this.persist());
  }
  setChainId(t) {
    if (this.isCompatibleChainId(t)) {
      const s2 = this.parseChainId(t);
      this.chainId = s2, this.switchEthereumChain(s2);
    }
  }
  parseAccountId(t) {
    const [s2, i3, n3] = t.split(":");
    return { chainId: `${s2}:${i3}`, address: n3 };
  }
  setAccounts(t) {
    this.accounts = t.filter((s2) => this.parseChainId(this.parseAccountId(s2).chainId) === this.chainId).map((s2) => this.parseAccountId(s2).address), this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(t) {
    var s2, i3;
    const n3 = (s2 = t == null ? void 0 : t.chains) != null ? s2 : [], e = (i3 = t == null ? void 0 : t.optionalChains) != null ? i3 : [], h5 = n3.concat(e);
    if (!h5.length)
      throw new Error("No chains specified in either `chains` or `optionalChains`");
    const c4 = n3.length ? (t == null ? void 0 : t.methods) || u2 : [], o = n3.length ? (t == null ? void 0 : t.events) || m : [], r = (t == null ? void 0 : t.optionalMethods) || [], d3 = (t == null ? void 0 : t.optionalEvents) || [], C = (t == null ? void 0 : t.rpcMap) || this.buildRpcMap(h5, t.projectId), I2 = (t == null ? void 0 : t.qrModalOptions) || void 0;
    return { chains: n3 == null ? void 0 : n3.map((l3) => this.formatChainId(l3)), optionalChains: e.map((l3) => this.formatChainId(l3)), methods: c4, events: o, optionalMethods: r, optionalEvents: d3, rpcMap: C, showQrModal: !!(t != null && t.showQrModal), qrModalOptions: I2, projectId: t.projectId, metadata: t.metadata };
  }
  buildRpcMap(t, s2) {
    const i3 = {};
    return t.forEach((n3) => {
      i3[n3] = this.getRpcUrl(n3, s2);
    }), i3;
  }
  async initialize(t) {
    if (this.rpc = this.getRpcConfig(t), this.chainId = this.rpc.chains.length ? g5(this.rpc.chains) : g5(this.rpc.optionalChains), this.signer = await cv.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata, disableProviderPing: t.disableProviderPing, relayUrl: t.relayUrl, storageOptions: t.storageOptions }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
      let s2;
      try {
        const { WalletConnectModal: i3 } = await import("./dist-ZGUAELDV.js");
        s2 = i3;
      } catch {
        throw new Error("To use QR modal, please install @walletconnect/modal package");
      }
      if (s2)
        try {
          this.modal = new s2(p4({ walletConnectVersion: 2, projectId: this.rpc.projectId, standaloneChains: this.rpc.chains }, this.rpc.qrModalOptions));
        } catch (i3) {
          throw this.signer.logger.error(i3), new Error("Could not generate WalletConnectModal Instance");
        }
    }
  }
  loadConnectOpts(t) {
    if (!t)
      return;
    const { chains: s2, optionalChains: i3, rpcMap: n3 } = t;
    s2 && D(s2) && (this.rpc.chains = s2.map((e) => this.formatChainId(e)), s2.forEach((e) => {
      this.rpc.rpcMap[e] = (n3 == null ? void 0 : n3[e]) || this.getRpcUrl(e);
    })), i3 && D(i3) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i3 == null ? void 0 : i3.map((e) => this.formatChainId(e)), i3.forEach((e) => {
      this.rpc.rpcMap[e] = (n3 == null ? void 0 : n3[e]) || this.getRpcUrl(e);
    }));
  }
  getRpcUrl(t, s2) {
    var i3;
    return ((i3 = this.rpc.rpcMap) == null ? void 0 : i3[t]) || `${j4}?chainId=eip155:${t}&projectId=${s2 || this.rpc.projectId}`;
  }
  async loadPersistedSession() {
    if (!this.session)
      return;
    const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), s2 = this.session.namespaces[`${this.namespace}:${t}`] ? this.session.namespaces[`${this.namespace}:${t}`] : this.session.namespaces[this.namespace];
    this.setChainIds(t ? [this.formatChainId(t)] : s2 == null ? void 0 : s2.accounts), this.setAccounts(s2 == null ? void 0 : s2.accounts);
  }
  reset() {
    this.chainId = 1, this.accounts = [];
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
  }
  parseAccounts(t) {
    return typeof t == "string" || t instanceof String ? [this.parseAccount(t)] : t.map((s2) => this.parseAccount(s2));
  }
};
var G2 = v3;
export {
  G2 as EthereumProvider,
  _4 as OPTIONAL_EVENTS,
  E4 as OPTIONAL_METHODS,
  m as REQUIRED_EVENTS,
  u2 as REQUIRED_METHODS,
  v3 as default
};
/*! Bundled license information:

@walletconnect/universal-provider/dist/index.es.js:
  (**
  * @license
  * Lodash <https://lodash.com/>
  * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
  * Released under MIT license <https://lodash.com/license>
  * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
  * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  *)
*/
//# sourceMappingURL=index.es-RF34WLSO.js.map
